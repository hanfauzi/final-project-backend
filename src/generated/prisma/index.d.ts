
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerAddress
 * 
 */
export type CustomerAddress = $Result.DefaultSelection<Prisma.$CustomerAddressPayload>
/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = $Result.DefaultSelection<Prisma.$ServiceCategoryPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Outlet
 * 
 */
export type Outlet = $Result.DefaultSelection<Prisma.$OutletPayload>
/**
 * Model OutletSchedule
 * 
 */
export type OutletSchedule = $Result.DefaultSelection<Prisma.$OutletSchedulePayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model LeaveRequest
 * 
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>
/**
 * Model OrderHeader
 * 
 */
export type OrderHeader = $Result.DefaultSelection<Prisma.$OrderHeaderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model WorkerStation
 * 
 */
export type WorkerStation = $Result.DefaultSelection<Prisma.$WorkerStationPayload>
/**
 * Model EmployeeTask
 * 
 */
export type EmployeeTask = $Result.DefaultSelection<Prisma.$EmployeeTaskPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const EmployeeRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  OUTLET_ADMIN: 'OUTLET_ADMIN',
  DRIVER: 'DRIVER',
  WORKER: 'WORKER'
};

export type EmployeeRole = (typeof EmployeeRole)[keyof typeof EmployeeRole]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EARLY_LEAVE: 'EARLY_LEAVE',
  ON_LEAVE: 'ON_LEAVE',
  SICK: 'SICK',
  HOLIDAY: 'HOLIDAY'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const LeaveType: {
  SICK: 'SICK',
  ANNUAL: 'ANNUAL',
  MATERNITY: 'MATERNITY',
  PATERNITY: 'PATERNITY',
  MARRIAGE: 'MARRIAGE',
  BEREAVEMENT: 'BEREAVEMENT',
  UNPAID: 'UNPAID',
  OTHER: 'OTHER'
};

export type LeaveType = (typeof LeaveType)[keyof typeof LeaveType]


export const LeaveReqStat: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type LeaveReqStat = (typeof LeaveReqStat)[keyof typeof LeaveReqStat]


export const OrderStatus: {
  WAITING_FOR_DRIVER_PICKUP: 'WAITING_FOR_DRIVER_PICKUP',
  ON_THE_WAY_TO_OUTLET: 'ON_THE_WAY_TO_OUTLET',
  ARRIVED_AT_OUTLET: 'ARRIVED_AT_OUTLET',
  WASHING_IN_PROGRESS: 'WASHING_IN_PROGRESS',
  IRONING_IN_PROGRESS: 'IRONING_IN_PROGRESS',
  PACKING_IN_PROGRESS: 'PACKING_IN_PROGRESS',
  WAITING_FOR_PAYMENT: 'WAITING_FOR_PAYMENT',
  READY_FOR_DELIVERY: 'READY_FOR_DELIVERY',
  OUT_FOR_DELIVERY: 'OUT_FOR_DELIVERY',
  DELIVERED_TO_CUSTOMER: 'DELIVERED_TO_CUSTOMER'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  DEBIT: 'DEBIT',
  CREDIT: 'CREDIT',
  BANK_TRANSFER: 'BANK_TRANSFER',
  QRIS: 'QRIS',
  E_WALLET: 'E_WALLET'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const Station: {
  WASHING: 'WASHING',
  IRONING: 'IRONING',
  PACKING: 'PACKING',
  DRIVING_PICKUP: 'DRIVING_PICKUP',
  DRIVING_DELIVERY: 'DRIVING_DELIVERY',
  QA: 'QA',
  ADMIN: 'ADMIN'
};

export type Station = (typeof Station)[keyof typeof Station]


export const TaskStatus: {
  PENDING: 'PENDING',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  ON_HOLD: 'ON_HOLD',
  DONE: 'DONE',
  CANCELLED: 'CANCELLED',
  REJECTED: 'REJECTED',
  REQUEST_BYPASS: 'REQUEST_BYPASS'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Label: {
  HOME: 'HOME',
  OFFICE: 'OFFICE',
  APARTMENT: 'APARTMENT',
  OTHER: 'OTHER'
};

export type Label = (typeof Label)[keyof typeof Label]

}

export type EmployeeRole = $Enums.EmployeeRole

export const EmployeeRole: typeof $Enums.EmployeeRole

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type LeaveType = $Enums.LeaveType

export const LeaveType: typeof $Enums.LeaveType

export type LeaveReqStat = $Enums.LeaveReqStat

export const LeaveReqStat: typeof $Enums.LeaveReqStat

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type Station = $Enums.Station

export const Station: typeof $Enums.Station

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type Label = $Enums.Label

export const Label: typeof $Enums.Label

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerAddress`: Exposes CRUD operations for the **CustomerAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerAddresses
    * const customerAddresses = await prisma.customerAddress.findMany()
    * ```
    */
  get customerAddress(): Prisma.CustomerAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outlet`: Exposes CRUD operations for the **Outlet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Outlets
    * const outlets = await prisma.outlet.findMany()
    * ```
    */
  get outlet(): Prisma.OutletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outletSchedule`: Exposes CRUD operations for the **OutletSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutletSchedules
    * const outletSchedules = await prisma.outletSchedule.findMany()
    * ```
    */
  get outletSchedule(): Prisma.OutletScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderHeader`: Exposes CRUD operations for the **OrderHeader** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderHeaders
    * const orderHeaders = await prisma.orderHeader.findMany()
    * ```
    */
  get orderHeader(): Prisma.OrderHeaderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workerStation`: Exposes CRUD operations for the **WorkerStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkerStations
    * const workerStations = await prisma.workerStation.findMany()
    * ```
    */
  get workerStation(): Prisma.WorkerStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeTask`: Exposes CRUD operations for the **EmployeeTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeTasks
    * const employeeTasks = await prisma.employeeTask.findMany()
    * ```
    */
  get employeeTask(): Prisma.EmployeeTaskDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    CustomerAddress: 'CustomerAddress',
    ServiceCategory: 'ServiceCategory',
    Service: 'Service',
    Outlet: 'Outlet',
    OutletSchedule: 'OutletSchedule',
    Employee: 'Employee',
    Shift: 'Shift',
    Attendance: 'Attendance',
    LeaveRequest: 'LeaveRequest',
    OrderHeader: 'OrderHeader',
    OrderItem: 'OrderItem',
    WorkerStation: 'WorkerStation',
    EmployeeTask: 'EmployeeTask'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "customer" | "customerAddress" | "serviceCategory" | "service" | "outlet" | "outletSchedule" | "employee" | "shift" | "attendance" | "leaveRequest" | "orderHeader" | "orderItem" | "workerStation" | "employeeTask"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerAddress: {
        payload: Prisma.$CustomerAddressPayload<ExtArgs>
        fields: Prisma.CustomerAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findFirst: {
            args: Prisma.CustomerAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findMany: {
            args: Prisma.CustomerAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          create: {
            args: Prisma.CustomerAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          createMany: {
            args: Prisma.CustomerAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          delete: {
            args: Prisma.CustomerAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          update: {
            args: Prisma.CustomerAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          deleteMany: {
            args: Prisma.CustomerAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          upsert: {
            args: Prisma.CustomerAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          aggregate: {
            args: Prisma.CustomerAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerAddress>
          }
          groupBy: {
            args: Prisma.CustomerAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerAddressCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: Prisma.$ServiceCategoryPayload<ExtArgs>
        fields: Prisma.ServiceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Outlet: {
        payload: Prisma.$OutletPayload<ExtArgs>
        fields: Prisma.OutletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          findFirst: {
            args: Prisma.OutletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          findMany: {
            args: Prisma.OutletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>[]
          }
          create: {
            args: Prisma.OutletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          createMany: {
            args: Prisma.OutletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>[]
          }
          delete: {
            args: Prisma.OutletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          update: {
            args: Prisma.OutletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          deleteMany: {
            args: Prisma.OutletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>[]
          }
          upsert: {
            args: Prisma.OutletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          aggregate: {
            args: Prisma.OutletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutlet>
          }
          groupBy: {
            args: Prisma.OutletGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutletGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutletCountArgs<ExtArgs>
            result: $Utils.Optional<OutletCountAggregateOutputType> | number
          }
        }
      }
      OutletSchedule: {
        payload: Prisma.$OutletSchedulePayload<ExtArgs>
        fields: Prisma.OutletScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutletScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutletScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          findFirst: {
            args: Prisma.OutletScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutletScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          findMany: {
            args: Prisma.OutletScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>[]
          }
          create: {
            args: Prisma.OutletScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          createMany: {
            args: Prisma.OutletScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutletScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>[]
          }
          delete: {
            args: Prisma.OutletScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          update: {
            args: Prisma.OutletScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          deleteMany: {
            args: Prisma.OutletScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutletScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutletScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>[]
          }
          upsert: {
            args: Prisma.OutletScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          aggregate: {
            args: Prisma.OutletScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutletSchedule>
          }
          groupBy: {
            args: Prisma.OutletScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutletScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutletScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<OutletScheduleCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          createMany: {
            args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
      OrderHeader: {
        payload: Prisma.$OrderHeaderPayload<ExtArgs>
        fields: Prisma.OrderHeaderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderHeaderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderHeaderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          findFirst: {
            args: Prisma.OrderHeaderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderHeaderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          findMany: {
            args: Prisma.OrderHeaderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>[]
          }
          create: {
            args: Prisma.OrderHeaderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          createMany: {
            args: Prisma.OrderHeaderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderHeaderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>[]
          }
          delete: {
            args: Prisma.OrderHeaderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          update: {
            args: Prisma.OrderHeaderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          deleteMany: {
            args: Prisma.OrderHeaderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderHeaderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderHeaderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>[]
          }
          upsert: {
            args: Prisma.OrderHeaderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          aggregate: {
            args: Prisma.OrderHeaderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderHeader>
          }
          groupBy: {
            args: Prisma.OrderHeaderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderHeaderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderHeaderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderHeaderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      WorkerStation: {
        payload: Prisma.$WorkerStationPayload<ExtArgs>
        fields: Prisma.WorkerStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload>
          }
          findFirst: {
            args: Prisma.WorkerStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload>
          }
          findMany: {
            args: Prisma.WorkerStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload>[]
          }
          create: {
            args: Prisma.WorkerStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload>
          }
          createMany: {
            args: Prisma.WorkerStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerStationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload>[]
          }
          delete: {
            args: Prisma.WorkerStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload>
          }
          update: {
            args: Prisma.WorkerStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload>
          }
          deleteMany: {
            args: Prisma.WorkerStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkerStationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload>[]
          }
          upsert: {
            args: Prisma.WorkerStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerStationPayload>
          }
          aggregate: {
            args: Prisma.WorkerStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkerStation>
          }
          groupBy: {
            args: Prisma.WorkerStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerStationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerStationCountAggregateOutputType> | number
          }
        }
      }
      EmployeeTask: {
        payload: Prisma.$EmployeeTaskPayload<ExtArgs>
        fields: Prisma.EmployeeTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          findFirst: {
            args: Prisma.EmployeeTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          findMany: {
            args: Prisma.EmployeeTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>[]
          }
          create: {
            args: Prisma.EmployeeTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          createMany: {
            args: Prisma.EmployeeTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>[]
          }
          delete: {
            args: Prisma.EmployeeTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          update: {
            args: Prisma.EmployeeTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          aggregate: {
            args: Prisma.EmployeeTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeTask>
          }
          groupBy: {
            args: Prisma.EmployeeTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeTaskCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeTaskCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customer?: CustomerOmit
    customerAddress?: CustomerAddressOmit
    serviceCategory?: ServiceCategoryOmit
    service?: ServiceOmit
    outlet?: OutletOmit
    outletSchedule?: OutletScheduleOmit
    employee?: EmployeeOmit
    shift?: ShiftOmit
    attendance?: AttendanceOmit
    leaveRequest?: LeaveRequestOmit
    orderHeader?: OrderHeaderOmit
    orderItem?: OrderItemOmit
    workerStation?: WorkerStationOmit
    employeeTask?: EmployeeTaskOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    addresses: number
    orders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | CustomerCountOutputTypeCountAddressesArgs
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHeaderWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    services: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategoryCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    orderItems: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ServiceCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type OutletCountOutputType
   */

  export type OutletCountOutputType = {
    schedules: number
    employees: number
    orders: number
    attendances: number
    leaves: number
    tasks: number
  }

  export type OutletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | OutletCountOutputTypeCountSchedulesArgs
    employees?: boolean | OutletCountOutputTypeCountEmployeesArgs
    orders?: boolean | OutletCountOutputTypeCountOrdersArgs
    attendances?: boolean | OutletCountOutputTypeCountAttendancesArgs
    leaves?: boolean | OutletCountOutputTypeCountLeavesArgs
    tasks?: boolean | OutletCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletCountOutputType
     */
    select?: OutletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutletScheduleWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHeaderWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    attendances: number
    leaves: number
    leavesApproved: number
    workerTasks: number
    workerTasksAssigned: number
    ordersHandled: number
    approvedBy: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | EmployeeCountOutputTypeCountAttendancesArgs
    leaves?: boolean | EmployeeCountOutputTypeCountLeavesArgs
    leavesApproved?: boolean | EmployeeCountOutputTypeCountLeavesApprovedArgs
    workerTasks?: boolean | EmployeeCountOutputTypeCountWorkerTasksArgs
    workerTasksAssigned?: boolean | EmployeeCountOutputTypeCountWorkerTasksAssignedArgs
    ordersHandled?: boolean | EmployeeCountOutputTypeCountOrdersHandledArgs
    approvedBy?: boolean | EmployeeCountOutputTypeCountApprovedByArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeavesApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWorkerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWorkerTasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountOrdersHandledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHeaderWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountApprovedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    employees: number
    attendances: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | ShiftCountOutputTypeCountEmployeesArgs
    attendances?: boolean | ShiftCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type OrderHeaderCountOutputType
   */

  export type OrderHeaderCountOutputType = {
    items: number
    tasks: number
  }

  export type OrderHeaderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderHeaderCountOutputTypeCountItemsArgs
    tasks?: boolean | OrderHeaderCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * OrderHeaderCountOutputType without action
   */
  export type OrderHeaderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeaderCountOutputType
     */
    select?: OrderHeaderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderHeaderCountOutputType without action
   */
  export type OrderHeaderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderHeaderCountOutputType without action
   */
  export type OrderHeaderCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }


  /**
   * Count Type WorkerStationCountOutputType
   */

  export type WorkerStationCountOutputType = {
    tasks: number
  }

  export type WorkerStationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | WorkerStationCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * WorkerStationCountOutputType without action
   */
  export type WorkerStationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStationCountOutputType
     */
    select?: WorkerStationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerStationCountOutputType without action
   */
  export type WorkerStationCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    role: string | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    isVerified: boolean | null
    resetPasswordToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    role: string | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    isVerified: boolean | null
    resetPasswordToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    role: number
    name: number
    email: number
    password: number
    phoneNumber: number
    isVerified: number
    resetPasswordToken: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    isVerified?: true
    resetPasswordToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    isVerified?: true
    resetPasswordToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    isVerified?: true
    resetPasswordToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    role: string
    name: string | null
    email: string
    password: string
    phoneNumber: string | null
    isVerified: boolean
    resetPasswordToken: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    isVerified?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    isVerified?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    isVerified?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    isVerified?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "name" | "email" | "password" | "phoneNumber" | "isVerified" | "resetPasswordToken" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      addresses: Prisma.$CustomerAddressPayload<ExtArgs>[]
      orders: Prisma.$OrderHeaderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: string
      name: string | null
      email: string
      password: string
      phoneNumber: string | null
      isVerified: boolean
      resetPasswordToken: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addresses<T extends Customer$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly role: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly password: FieldRef<"Customer", 'String'>
    readonly phoneNumber: FieldRef<"Customer", 'String'>
    readonly isVerified: FieldRef<"Customer", 'Boolean'>
    readonly resetPasswordToken: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly deletedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.addresses
   */
  export type Customer$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    cursor?: CustomerAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    where?: OrderHeaderWhereInput
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    cursor?: OrderHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerAddress
   */

  export type AggregateCustomerAddress = {
    _count: CustomerAddressCountAggregateOutputType | null
    _avg: CustomerAddressAvgAggregateOutputType | null
    _sum: CustomerAddressSumAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  export type CustomerAddressAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CustomerAddressSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CustomerAddressMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    label: $Enums.Label | null
    address: string | null
    city: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    notes: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerAddressMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    label: $Enums.Label | null
    address: string | null
    city: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    notes: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerAddressCountAggregateOutputType = {
    id: number
    customerId: number
    label: number
    address: number
    city: number
    postalCode: number
    latitude: number
    longitude: number
    notes: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CustomerAddressAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CustomerAddressSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CustomerAddressMinAggregateInputType = {
    id?: true
    customerId?: true
    label?: true
    address?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    notes?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerAddressMaxAggregateInputType = {
    id?: true
    customerId?: true
    label?: true
    address?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    notes?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerAddressCountAggregateInputType = {
    id?: true
    customerId?: true
    label?: true
    address?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    notes?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CustomerAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddress to aggregate.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerAddresses
    **/
    _count?: true | CustomerAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type GetCustomerAddressAggregateType<T extends CustomerAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerAddress[P]>
      : GetScalarType<T[P], AggregateCustomerAddress[P]>
  }




  export type CustomerAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithAggregationInput | CustomerAddressOrderByWithAggregationInput[]
    by: CustomerAddressScalarFieldEnum[] | CustomerAddressScalarFieldEnum
    having?: CustomerAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerAddressCountAggregateInputType | true
    _avg?: CustomerAddressAvgAggregateInputType
    _sum?: CustomerAddressSumAggregateInputType
    _min?: CustomerAddressMinAggregateInputType
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type CustomerAddressGroupByOutputType = {
    id: string
    customerId: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes: string | null
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CustomerAddressCountAggregateOutputType | null
    _avg: CustomerAddressAvgAggregateOutputType | null
    _sum: CustomerAddressSumAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  type GetCustomerAddressGroupByPayload<T extends CustomerAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
        }
      >
    >


  export type CustomerAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    label?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    label?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    label?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectScalar = {
    id?: boolean
    customerId?: boolean
    label?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CustomerAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "label" | "address" | "city" | "postalCode" | "latitude" | "longitude" | "notes" | "isPrimary" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["customerAddress"]>
  export type CustomerAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerAddress"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      label: $Enums.Label
      address: string
      city: string
      postalCode: string
      latitude: number
      longitude: number
      notes: string | null
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["customerAddress"]>
    composites: {}
  }

  type CustomerAddressGetPayload<S extends boolean | null | undefined | CustomerAddressDefaultArgs> = $Result.GetResult<Prisma.$CustomerAddressPayload, S>

  type CustomerAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerAddressCountAggregateInputType | true
    }

  export interface CustomerAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerAddress'], meta: { name: 'CustomerAddress' } }
    /**
     * Find zero or one CustomerAddress that matches the filter.
     * @param {CustomerAddressFindUniqueArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerAddressFindUniqueArgs>(args: SelectSubset<T, CustomerAddressFindUniqueArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerAddressFindUniqueOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerAddressFindFirstArgs>(args?: SelectSubset<T, CustomerAddressFindFirstArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany()
     * 
     * // Get first 10 CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerAddressFindManyArgs>(args?: SelectSubset<T, CustomerAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerAddress.
     * @param {CustomerAddressCreateArgs} args - Arguments to create a CustomerAddress.
     * @example
     * // Create one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.create({
     *   data: {
     *     // ... data to create a CustomerAddress
     *   }
     * })
     * 
     */
    create<T extends CustomerAddressCreateArgs>(args: SelectSubset<T, CustomerAddressCreateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerAddresses.
     * @param {CustomerAddressCreateManyArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerAddressCreateManyArgs>(args?: SelectSubset<T, CustomerAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerAddresses and returns the data saved in the database.
     * @param {CustomerAddressCreateManyAndReturnArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerAddress.
     * @param {CustomerAddressDeleteArgs} args - Arguments to delete one CustomerAddress.
     * @example
     * // Delete one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.delete({
     *   where: {
     *     // ... filter to delete one CustomerAddress
     *   }
     * })
     * 
     */
    delete<T extends CustomerAddressDeleteArgs>(args: SelectSubset<T, CustomerAddressDeleteArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerAddress.
     * @param {CustomerAddressUpdateArgs} args - Arguments to update one CustomerAddress.
     * @example
     * // Update one CustomerAddress
     * const customerAddress = await prisma.customerAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerAddressUpdateArgs>(args: SelectSubset<T, CustomerAddressUpdateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerAddresses.
     * @param {CustomerAddressDeleteManyArgs} args - Arguments to filter CustomerAddresses to delete.
     * @example
     * // Delete a few CustomerAddresses
     * const { count } = await prisma.customerAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerAddressDeleteManyArgs>(args?: SelectSubset<T, CustomerAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerAddressUpdateManyArgs>(args: SelectSubset<T, CustomerAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses and returns the data updated in the database.
     * @param {CustomerAddressUpdateManyAndReturnArgs} args - Arguments to update many CustomerAddresses.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerAddress.
     * @param {CustomerAddressUpsertArgs} args - Arguments to update or create a CustomerAddress.
     * @example
     * // Update or create a CustomerAddress
     * const customerAddress = await prisma.customerAddress.upsert({
     *   create: {
     *     // ... data to create a CustomerAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerAddress we want to update
     *   }
     * })
     */
    upsert<T extends CustomerAddressUpsertArgs>(args: SelectSubset<T, CustomerAddressUpsertArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressCountArgs} args - Arguments to filter CustomerAddresses to count.
     * @example
     * // Count the number of CustomerAddresses
     * const count = await prisma.customerAddress.count({
     *   where: {
     *     // ... the filter for the CustomerAddresses we want to count
     *   }
     * })
    **/
    count<T extends CustomerAddressCountArgs>(
      args?: Subset<T, CustomerAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAddressAggregateArgs>(args: Subset<T, CustomerAddressAggregateArgs>): Prisma.PrismaPromise<GetCustomerAddressAggregateType<T>>

    /**
     * Group by CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerAddressGroupByArgs['orderBy'] }
        : { orderBy?: CustomerAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerAddress model
   */
  readonly fields: CustomerAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerAddress model
   */
  interface CustomerAddressFieldRefs {
    readonly id: FieldRef<"CustomerAddress", 'String'>
    readonly customerId: FieldRef<"CustomerAddress", 'String'>
    readonly label: FieldRef<"CustomerAddress", 'Label'>
    readonly address: FieldRef<"CustomerAddress", 'String'>
    readonly city: FieldRef<"CustomerAddress", 'String'>
    readonly postalCode: FieldRef<"CustomerAddress", 'String'>
    readonly latitude: FieldRef<"CustomerAddress", 'Float'>
    readonly longitude: FieldRef<"CustomerAddress", 'Float'>
    readonly notes: FieldRef<"CustomerAddress", 'String'>
    readonly isPrimary: FieldRef<"CustomerAddress", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerAddress", 'DateTime'>
    readonly deletedAt: FieldRef<"CustomerAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerAddress findUnique
   */
  export type CustomerAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findUniqueOrThrow
   */
  export type CustomerAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findFirst
   */
  export type CustomerAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findFirstOrThrow
   */
  export type CustomerAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findMany
   */
  export type CustomerAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddresses to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress create
   */
  export type CustomerAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerAddress.
     */
    data: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
  }

  /**
   * CustomerAddress createMany
   */
  export type CustomerAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerAddress createManyAndReturn
   */
  export type CustomerAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress update
   */
  export type CustomerAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerAddress.
     */
    data: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
    /**
     * Choose, which CustomerAddress to update.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress updateMany
   */
  export type CustomerAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
  }

  /**
   * CustomerAddress updateManyAndReturn
   */
  export type CustomerAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress upsert
   */
  export type CustomerAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerAddress to update in case it exists.
     */
    where: CustomerAddressWhereUniqueInput
    /**
     * In case the CustomerAddress found by the `where` argument doesn't exist, create a new CustomerAddress with this data.
     */
    create: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
    /**
     * In case the CustomerAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
  }

  /**
   * CustomerAddress delete
   */
  export type CustomerAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter which CustomerAddress to delete.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress deleteMany
   */
  export type CustomerAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddresses to delete
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to delete.
     */
    limit?: number
  }

  /**
   * CustomerAddress without action
   */
  export type CustomerAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: ServiceCategoryOrderByWithAggregationInput | ServiceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ServiceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["serviceCategory"]>
  export type ServiceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCategory"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCategoryFindUniqueArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCategoryFindFirstArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCategoryFindManyArgs>(args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends ServiceCategoryCreateArgs>(args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCategories.
     * @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCategoryCreateManyArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCategories and returns the data saved in the database.
     * @param {ServiceCategoryCreateManyAndReturnArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends ServiceCategoryDeleteArgs>(args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCategoryUpdateArgs>(args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCategoryDeleteManyArgs>(args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCategoryUpdateManyArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories and returns the data updated in the database.
     * @param {ServiceCategoryUpdateManyAndReturnArgs} args - Arguments to update many ServiceCategories.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCategoryUpsertArgs>(args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCategory model
   */
  readonly fields: ServiceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServiceCategory$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCategory model
   */
  interface ServiceCategoryFieldRefs {
    readonly id: FieldRef<"ServiceCategory", 'String'>
    readonly name: FieldRef<"ServiceCategory", 'String'>
    readonly createdAt: FieldRef<"ServiceCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceCategory", 'DateTime'>
    readonly deletedAt: FieldRef<"ServiceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCategory findUnique
   */
  export type ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findFirst
   */
  export type ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }

  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory createManyAndReturn
   */
  export type ServiceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory updateManyAndReturn
   */
  export type ServiceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }

  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to delete.
     */
    limit?: number
  }

  /**
   * ServiceCategory.services
   */
  export type ServiceCategory$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    basePrice: number | null
    minQty: number | null
    estHours: number | null
  }

  export type ServiceSumAggregateOutputType = {
    basePrice: number | null
    minQty: number | null
    estHours: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    serviceCategoryId: string | null
    unit: string | null
    basePrice: number | null
    minQty: number | null
    estHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    serviceCategoryId: string | null
    unit: string | null
    basePrice: number | null
    minQty: number | null
    estHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    serviceCategoryId: number
    unit: number
    basePrice: number
    minQty: number
    estHours: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    basePrice?: true
    minQty?: true
    estHours?: true
  }

  export type ServiceSumAggregateInputType = {
    basePrice?: true
    minQty?: true
    estHours?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    serviceCategoryId?: true
    unit?: true
    basePrice?: true
    minQty?: true
    estHours?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    serviceCategoryId?: true
    unit?: true
    basePrice?: true
    minQty?: true
    estHours?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    serviceCategoryId?: true
    unit?: true
    basePrice?: true
    minQty?: true
    estHours?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    serviceCategoryId: string
    unit: string
    basePrice: number
    minQty: number
    estHours: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serviceCategoryId?: boolean
    unit?: boolean
    basePrice?: boolean
    minQty?: boolean
    estHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    orderItems?: boolean | Service$orderItemsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serviceCategoryId?: boolean
    unit?: boolean
    basePrice?: boolean
    minQty?: boolean
    estHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serviceCategoryId?: boolean
    unit?: boolean
    basePrice?: boolean
    minQty?: boolean
    estHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    serviceCategoryId?: boolean
    unit?: boolean
    basePrice?: boolean
    minQty?: boolean
    estHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "serviceCategoryId" | "unit" | "basePrice" | "minQty" | "estHours" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    orderItems?: boolean | Service$orderItemsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      category: Prisma.$ServiceCategoryPayload<ExtArgs>
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      serviceCategoryId: string
      unit: string
      basePrice: number
      minQty: number
      estHours: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ServiceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryDefaultArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItems<T extends Service$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Service$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly serviceCategoryId: FieldRef<"Service", 'String'>
    readonly unit: FieldRef<"Service", 'String'>
    readonly basePrice: FieldRef<"Service", 'Int'>
    readonly minQty: FieldRef<"Service", 'Float'>
    readonly estHours: FieldRef<"Service", 'Int'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
    readonly deletedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.orderItems
   */
  export type Service$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Outlet
   */

  export type AggregateOutlet = {
    _count: OutletCountAggregateOutputType | null
    _avg: OutletAvgAggregateOutputType | null
    _sum: OutletSumAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  export type OutletAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type OutletSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type OutletMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phoneNumber: string | null
    city: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    coverageArea: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OutletMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phoneNumber: string | null
    city: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    coverageArea: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OutletCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phoneNumber: number
    city: number
    postalCode: number
    latitude: number
    longitude: number
    coverageArea: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OutletAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type OutletSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type OutletMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phoneNumber?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    coverageArea?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OutletMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phoneNumber?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    coverageArea?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OutletCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phoneNumber?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    coverageArea?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OutletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outlet to aggregate.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Outlets
    **/
    _count?: true | OutletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutletMaxAggregateInputType
  }

  export type GetOutletAggregateType<T extends OutletAggregateArgs> = {
        [P in keyof T & keyof AggregateOutlet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutlet[P]>
      : GetScalarType<T[P], AggregateOutlet[P]>
  }




  export type OutletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutletWhereInput
    orderBy?: OutletOrderByWithAggregationInput | OutletOrderByWithAggregationInput[]
    by: OutletScalarFieldEnum[] | OutletScalarFieldEnum
    having?: OutletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutletCountAggregateInputType | true
    _avg?: OutletAvgAggregateInputType
    _sum?: OutletSumAggregateInputType
    _min?: OutletMinAggregateInputType
    _max?: OutletMaxAggregateInputType
  }

  export type OutletGroupByOutputType = {
    id: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OutletCountAggregateOutputType | null
    _avg: OutletAvgAggregateOutputType | null
    _sum: OutletSumAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  type GetOutletGroupByPayload<T extends OutletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutletGroupByOutputType[P]>
            : GetScalarType<T[P], OutletGroupByOutputType[P]>
        }
      >
    >


  export type OutletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    coverageArea?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    schedules?: boolean | Outlet$schedulesArgs<ExtArgs>
    employees?: boolean | Outlet$employeesArgs<ExtArgs>
    orders?: boolean | Outlet$ordersArgs<ExtArgs>
    attendances?: boolean | Outlet$attendancesArgs<ExtArgs>
    leaves?: boolean | Outlet$leavesArgs<ExtArgs>
    tasks?: boolean | Outlet$tasksArgs<ExtArgs>
    _count?: boolean | OutletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outlet"]>

  export type OutletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    coverageArea?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["outlet"]>

  export type OutletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    coverageArea?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["outlet"]>

  export type OutletSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    coverageArea?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OutletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phoneNumber" | "city" | "postalCode" | "latitude" | "longitude" | "coverageArea" | "isActive" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["outlet"]>
  export type OutletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | Outlet$schedulesArgs<ExtArgs>
    employees?: boolean | Outlet$employeesArgs<ExtArgs>
    orders?: boolean | Outlet$ordersArgs<ExtArgs>
    attendances?: boolean | Outlet$attendancesArgs<ExtArgs>
    leaves?: boolean | Outlet$leavesArgs<ExtArgs>
    tasks?: boolean | Outlet$tasksArgs<ExtArgs>
    _count?: boolean | OutletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OutletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OutletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OutletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Outlet"
    objects: {
      schedules: Prisma.$OutletSchedulePayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      orders: Prisma.$OrderHeaderPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      leaves: Prisma.$LeaveRequestPayload<ExtArgs>[]
      tasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phoneNumber: string
      city: string
      postalCode: string
      latitude: number
      longitude: number
      coverageArea: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["outlet"]>
    composites: {}
  }

  type OutletGetPayload<S extends boolean | null | undefined | OutletDefaultArgs> = $Result.GetResult<Prisma.$OutletPayload, S>

  type OutletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutletCountAggregateInputType | true
    }

  export interface OutletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Outlet'], meta: { name: 'Outlet' } }
    /**
     * Find zero or one Outlet that matches the filter.
     * @param {OutletFindUniqueArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutletFindUniqueArgs>(args: SelectSubset<T, OutletFindUniqueArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Outlet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutletFindUniqueOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutletFindUniqueOrThrowArgs>(args: SelectSubset<T, OutletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outlet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletFindFirstArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutletFindFirstArgs>(args?: SelectSubset<T, OutletFindFirstArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outlet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletFindFirstOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutletFindFirstOrThrowArgs>(args?: SelectSubset<T, OutletFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Outlets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Outlets
     * const outlets = await prisma.outlet.findMany()
     * 
     * // Get first 10 Outlets
     * const outlets = await prisma.outlet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outletWithIdOnly = await prisma.outlet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutletFindManyArgs>(args?: SelectSubset<T, OutletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Outlet.
     * @param {OutletCreateArgs} args - Arguments to create a Outlet.
     * @example
     * // Create one Outlet
     * const Outlet = await prisma.outlet.create({
     *   data: {
     *     // ... data to create a Outlet
     *   }
     * })
     * 
     */
    create<T extends OutletCreateArgs>(args: SelectSubset<T, OutletCreateArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Outlets.
     * @param {OutletCreateManyArgs} args - Arguments to create many Outlets.
     * @example
     * // Create many Outlets
     * const outlet = await prisma.outlet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutletCreateManyArgs>(args?: SelectSubset<T, OutletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Outlets and returns the data saved in the database.
     * @param {OutletCreateManyAndReturnArgs} args - Arguments to create many Outlets.
     * @example
     * // Create many Outlets
     * const outlet = await prisma.outlet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Outlets and only return the `id`
     * const outletWithIdOnly = await prisma.outlet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutletCreateManyAndReturnArgs>(args?: SelectSubset<T, OutletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Outlet.
     * @param {OutletDeleteArgs} args - Arguments to delete one Outlet.
     * @example
     * // Delete one Outlet
     * const Outlet = await prisma.outlet.delete({
     *   where: {
     *     // ... filter to delete one Outlet
     *   }
     * })
     * 
     */
    delete<T extends OutletDeleteArgs>(args: SelectSubset<T, OutletDeleteArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Outlet.
     * @param {OutletUpdateArgs} args - Arguments to update one Outlet.
     * @example
     * // Update one Outlet
     * const outlet = await prisma.outlet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutletUpdateArgs>(args: SelectSubset<T, OutletUpdateArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Outlets.
     * @param {OutletDeleteManyArgs} args - Arguments to filter Outlets to delete.
     * @example
     * // Delete a few Outlets
     * const { count } = await prisma.outlet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutletDeleteManyArgs>(args?: SelectSubset<T, OutletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Outlets
     * const outlet = await prisma.outlet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutletUpdateManyArgs>(args: SelectSubset<T, OutletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outlets and returns the data updated in the database.
     * @param {OutletUpdateManyAndReturnArgs} args - Arguments to update many Outlets.
     * @example
     * // Update many Outlets
     * const outlet = await prisma.outlet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Outlets and only return the `id`
     * const outletWithIdOnly = await prisma.outlet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutletUpdateManyAndReturnArgs>(args: SelectSubset<T, OutletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Outlet.
     * @param {OutletUpsertArgs} args - Arguments to update or create a Outlet.
     * @example
     * // Update or create a Outlet
     * const outlet = await prisma.outlet.upsert({
     *   create: {
     *     // ... data to create a Outlet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Outlet we want to update
     *   }
     * })
     */
    upsert<T extends OutletUpsertArgs>(args: SelectSubset<T, OutletUpsertArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletCountArgs} args - Arguments to filter Outlets to count.
     * @example
     * // Count the number of Outlets
     * const count = await prisma.outlet.count({
     *   where: {
     *     // ... the filter for the Outlets we want to count
     *   }
     * })
    **/
    count<T extends OutletCountArgs>(
      args?: Subset<T, OutletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutletAggregateArgs>(args: Subset<T, OutletAggregateArgs>): Prisma.PrismaPromise<GetOutletAggregateType<T>>

    /**
     * Group by Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutletGroupByArgs['orderBy'] }
        : { orderBy?: OutletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Outlet model
   */
  readonly fields: OutletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Outlet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedules<T extends Outlet$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Outlet$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Outlet$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Outlet$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaves<T extends Outlet$leavesArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Outlet$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Outlet model
   */
  interface OutletFieldRefs {
    readonly id: FieldRef<"Outlet", 'String'>
    readonly name: FieldRef<"Outlet", 'String'>
    readonly address: FieldRef<"Outlet", 'String'>
    readonly phoneNumber: FieldRef<"Outlet", 'String'>
    readonly city: FieldRef<"Outlet", 'String'>
    readonly postalCode: FieldRef<"Outlet", 'String'>
    readonly latitude: FieldRef<"Outlet", 'Float'>
    readonly longitude: FieldRef<"Outlet", 'Float'>
    readonly coverageArea: FieldRef<"Outlet", 'String'>
    readonly isActive: FieldRef<"Outlet", 'Boolean'>
    readonly createdAt: FieldRef<"Outlet", 'DateTime'>
    readonly updatedAt: FieldRef<"Outlet", 'DateTime'>
    readonly deletedAt: FieldRef<"Outlet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Outlet findUnique
   */
  export type OutletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet findUniqueOrThrow
   */
  export type OutletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet findFirst
   */
  export type OutletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outlets.
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outlets.
     */
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Outlet findFirstOrThrow
   */
  export type OutletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outlets.
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outlets.
     */
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Outlet findMany
   */
  export type OutletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlets to fetch.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Outlets.
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Outlet create
   */
  export type OutletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * The data needed to create a Outlet.
     */
    data: XOR<OutletCreateInput, OutletUncheckedCreateInput>
  }

  /**
   * Outlet createMany
   */
  export type OutletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Outlets.
     */
    data: OutletCreateManyInput | OutletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Outlet createManyAndReturn
   */
  export type OutletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * The data used to create many Outlets.
     */
    data: OutletCreateManyInput | OutletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Outlet update
   */
  export type OutletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * The data needed to update a Outlet.
     */
    data: XOR<OutletUpdateInput, OutletUncheckedUpdateInput>
    /**
     * Choose, which Outlet to update.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet updateMany
   */
  export type OutletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Outlets.
     */
    data: XOR<OutletUpdateManyMutationInput, OutletUncheckedUpdateManyInput>
    /**
     * Filter which Outlets to update
     */
    where?: OutletWhereInput
    /**
     * Limit how many Outlets to update.
     */
    limit?: number
  }

  /**
   * Outlet updateManyAndReturn
   */
  export type OutletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * The data used to update Outlets.
     */
    data: XOR<OutletUpdateManyMutationInput, OutletUncheckedUpdateManyInput>
    /**
     * Filter which Outlets to update
     */
    where?: OutletWhereInput
    /**
     * Limit how many Outlets to update.
     */
    limit?: number
  }

  /**
   * Outlet upsert
   */
  export type OutletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * The filter to search for the Outlet to update in case it exists.
     */
    where: OutletWhereUniqueInput
    /**
     * In case the Outlet found by the `where` argument doesn't exist, create a new Outlet with this data.
     */
    create: XOR<OutletCreateInput, OutletUncheckedCreateInput>
    /**
     * In case the Outlet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutletUpdateInput, OutletUncheckedUpdateInput>
  }

  /**
   * Outlet delete
   */
  export type OutletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter which Outlet to delete.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet deleteMany
   */
  export type OutletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outlets to delete
     */
    where?: OutletWhereInput
    /**
     * Limit how many Outlets to delete.
     */
    limit?: number
  }

  /**
   * Outlet.schedules
   */
  export type Outlet$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    where?: OutletScheduleWhereInput
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    cursor?: OutletScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutletScheduleScalarFieldEnum | OutletScheduleScalarFieldEnum[]
  }

  /**
   * Outlet.employees
   */
  export type Outlet$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Outlet.orders
   */
  export type Outlet$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    where?: OrderHeaderWhereInput
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    cursor?: OrderHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * Outlet.attendances
   */
  export type Outlet$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Outlet.leaves
   */
  export type Outlet$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Outlet.tasks
   */
  export type Outlet$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * Outlet without action
   */
  export type OutletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
  }


  /**
   * Model OutletSchedule
   */

  export type AggregateOutletSchedule = {
    _count: OutletScheduleCountAggregateOutputType | null
    _min: OutletScheduleMinAggregateOutputType | null
    _max: OutletScheduleMaxAggregateOutputType | null
  }

  export type OutletScheduleMinAggregateOutputType = {
    id: string | null
    outletId: string | null
    detailDays: string | null
    openHour: Date | null
    closeHour: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OutletScheduleMaxAggregateOutputType = {
    id: string | null
    outletId: string | null
    detailDays: string | null
    openHour: Date | null
    closeHour: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OutletScheduleCountAggregateOutputType = {
    id: number
    outletId: number
    detailDays: number
    openHour: number
    closeHour: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OutletScheduleMinAggregateInputType = {
    id?: true
    outletId?: true
    detailDays?: true
    openHour?: true
    closeHour?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OutletScheduleMaxAggregateInputType = {
    id?: true
    outletId?: true
    detailDays?: true
    openHour?: true
    closeHour?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OutletScheduleCountAggregateInputType = {
    id?: true
    outletId?: true
    detailDays?: true
    openHour?: true
    closeHour?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OutletScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutletSchedule to aggregate.
     */
    where?: OutletScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutletSchedules to fetch.
     */
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutletScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutletSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutletSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutletSchedules
    **/
    _count?: true | OutletScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutletScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutletScheduleMaxAggregateInputType
  }

  export type GetOutletScheduleAggregateType<T extends OutletScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateOutletSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutletSchedule[P]>
      : GetScalarType<T[P], AggregateOutletSchedule[P]>
  }




  export type OutletScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutletScheduleWhereInput
    orderBy?: OutletScheduleOrderByWithAggregationInput | OutletScheduleOrderByWithAggregationInput[]
    by: OutletScheduleScalarFieldEnum[] | OutletScheduleScalarFieldEnum
    having?: OutletScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutletScheduleCountAggregateInputType | true
    _min?: OutletScheduleMinAggregateInputType
    _max?: OutletScheduleMaxAggregateInputType
  }

  export type OutletScheduleGroupByOutputType = {
    id: string
    outletId: string
    detailDays: string
    openHour: Date
    closeHour: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OutletScheduleCountAggregateOutputType | null
    _min: OutletScheduleMinAggregateOutputType | null
    _max: OutletScheduleMaxAggregateOutputType | null
  }

  type GetOutletScheduleGroupByPayload<T extends OutletScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutletScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutletScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutletScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], OutletScheduleGroupByOutputType[P]>
        }
      >
    >


  export type OutletScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    detailDays?: boolean
    openHour?: boolean
    closeHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outletSchedule"]>

  export type OutletScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    detailDays?: boolean
    openHour?: boolean
    closeHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outletSchedule"]>

  export type OutletScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    detailDays?: boolean
    openHour?: boolean
    closeHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outletSchedule"]>

  export type OutletScheduleSelectScalar = {
    id?: boolean
    outletId?: boolean
    detailDays?: boolean
    openHour?: boolean
    closeHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OutletScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "outletId" | "detailDays" | "openHour" | "closeHour" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["outletSchedule"]>
  export type OutletScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }
  export type OutletScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }
  export type OutletScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }

  export type $OutletSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutletSchedule"
    objects: {
      outlet: Prisma.$OutletPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      outletId: string
      detailDays: string
      openHour: Date
      closeHour: Date
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["outletSchedule"]>
    composites: {}
  }

  type OutletScheduleGetPayload<S extends boolean | null | undefined | OutletScheduleDefaultArgs> = $Result.GetResult<Prisma.$OutletSchedulePayload, S>

  type OutletScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutletScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutletScheduleCountAggregateInputType | true
    }

  export interface OutletScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutletSchedule'], meta: { name: 'OutletSchedule' } }
    /**
     * Find zero or one OutletSchedule that matches the filter.
     * @param {OutletScheduleFindUniqueArgs} args - Arguments to find a OutletSchedule
     * @example
     * // Get one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutletScheduleFindUniqueArgs>(args: SelectSubset<T, OutletScheduleFindUniqueArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OutletSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutletScheduleFindUniqueOrThrowArgs} args - Arguments to find a OutletSchedule
     * @example
     * // Get one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutletScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, OutletScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutletSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleFindFirstArgs} args - Arguments to find a OutletSchedule
     * @example
     * // Get one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutletScheduleFindFirstArgs>(args?: SelectSubset<T, OutletScheduleFindFirstArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutletSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleFindFirstOrThrowArgs} args - Arguments to find a OutletSchedule
     * @example
     * // Get one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutletScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, OutletScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutletSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutletSchedules
     * const outletSchedules = await prisma.outletSchedule.findMany()
     * 
     * // Get first 10 OutletSchedules
     * const outletSchedules = await prisma.outletSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outletScheduleWithIdOnly = await prisma.outletSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutletScheduleFindManyArgs>(args?: SelectSubset<T, OutletScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OutletSchedule.
     * @param {OutletScheduleCreateArgs} args - Arguments to create a OutletSchedule.
     * @example
     * // Create one OutletSchedule
     * const OutletSchedule = await prisma.outletSchedule.create({
     *   data: {
     *     // ... data to create a OutletSchedule
     *   }
     * })
     * 
     */
    create<T extends OutletScheduleCreateArgs>(args: SelectSubset<T, OutletScheduleCreateArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OutletSchedules.
     * @param {OutletScheduleCreateManyArgs} args - Arguments to create many OutletSchedules.
     * @example
     * // Create many OutletSchedules
     * const outletSchedule = await prisma.outletSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutletScheduleCreateManyArgs>(args?: SelectSubset<T, OutletScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutletSchedules and returns the data saved in the database.
     * @param {OutletScheduleCreateManyAndReturnArgs} args - Arguments to create many OutletSchedules.
     * @example
     * // Create many OutletSchedules
     * const outletSchedule = await prisma.outletSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutletSchedules and only return the `id`
     * const outletScheduleWithIdOnly = await prisma.outletSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutletScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, OutletScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OutletSchedule.
     * @param {OutletScheduleDeleteArgs} args - Arguments to delete one OutletSchedule.
     * @example
     * // Delete one OutletSchedule
     * const OutletSchedule = await prisma.outletSchedule.delete({
     *   where: {
     *     // ... filter to delete one OutletSchedule
     *   }
     * })
     * 
     */
    delete<T extends OutletScheduleDeleteArgs>(args: SelectSubset<T, OutletScheduleDeleteArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OutletSchedule.
     * @param {OutletScheduleUpdateArgs} args - Arguments to update one OutletSchedule.
     * @example
     * // Update one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutletScheduleUpdateArgs>(args: SelectSubset<T, OutletScheduleUpdateArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OutletSchedules.
     * @param {OutletScheduleDeleteManyArgs} args - Arguments to filter OutletSchedules to delete.
     * @example
     * // Delete a few OutletSchedules
     * const { count } = await prisma.outletSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutletScheduleDeleteManyArgs>(args?: SelectSubset<T, OutletScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutletSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutletSchedules
     * const outletSchedule = await prisma.outletSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutletScheduleUpdateManyArgs>(args: SelectSubset<T, OutletScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutletSchedules and returns the data updated in the database.
     * @param {OutletScheduleUpdateManyAndReturnArgs} args - Arguments to update many OutletSchedules.
     * @example
     * // Update many OutletSchedules
     * const outletSchedule = await prisma.outletSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OutletSchedules and only return the `id`
     * const outletScheduleWithIdOnly = await prisma.outletSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutletScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, OutletScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OutletSchedule.
     * @param {OutletScheduleUpsertArgs} args - Arguments to update or create a OutletSchedule.
     * @example
     * // Update or create a OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.upsert({
     *   create: {
     *     // ... data to create a OutletSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutletSchedule we want to update
     *   }
     * })
     */
    upsert<T extends OutletScheduleUpsertArgs>(args: SelectSubset<T, OutletScheduleUpsertArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OutletSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleCountArgs} args - Arguments to filter OutletSchedules to count.
     * @example
     * // Count the number of OutletSchedules
     * const count = await prisma.outletSchedule.count({
     *   where: {
     *     // ... the filter for the OutletSchedules we want to count
     *   }
     * })
    **/
    count<T extends OutletScheduleCountArgs>(
      args?: Subset<T, OutletScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutletScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutletSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutletScheduleAggregateArgs>(args: Subset<T, OutletScheduleAggregateArgs>): Prisma.PrismaPromise<GetOutletScheduleAggregateType<T>>

    /**
     * Group by OutletSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutletScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutletScheduleGroupByArgs['orderBy'] }
        : { orderBy?: OutletScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutletScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutletScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutletSchedule model
   */
  readonly fields: OutletScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutletSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutletScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutletSchedule model
   */
  interface OutletScheduleFieldRefs {
    readonly id: FieldRef<"OutletSchedule", 'String'>
    readonly outletId: FieldRef<"OutletSchedule", 'String'>
    readonly detailDays: FieldRef<"OutletSchedule", 'String'>
    readonly openHour: FieldRef<"OutletSchedule", 'DateTime'>
    readonly closeHour: FieldRef<"OutletSchedule", 'DateTime'>
    readonly createdAt: FieldRef<"OutletSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"OutletSchedule", 'DateTime'>
    readonly deletedAt: FieldRef<"OutletSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutletSchedule findUnique
   */
  export type OutletScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedule to fetch.
     */
    where: OutletScheduleWhereUniqueInput
  }

  /**
   * OutletSchedule findUniqueOrThrow
   */
  export type OutletScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedule to fetch.
     */
    where: OutletScheduleWhereUniqueInput
  }

  /**
   * OutletSchedule findFirst
   */
  export type OutletScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedule to fetch.
     */
    where?: OutletScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutletSchedules to fetch.
     */
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutletSchedules.
     */
    cursor?: OutletScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutletSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutletSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutletSchedules.
     */
    distinct?: OutletScheduleScalarFieldEnum | OutletScheduleScalarFieldEnum[]
  }

  /**
   * OutletSchedule findFirstOrThrow
   */
  export type OutletScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedule to fetch.
     */
    where?: OutletScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutletSchedules to fetch.
     */
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutletSchedules.
     */
    cursor?: OutletScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutletSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutletSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutletSchedules.
     */
    distinct?: OutletScheduleScalarFieldEnum | OutletScheduleScalarFieldEnum[]
  }

  /**
   * OutletSchedule findMany
   */
  export type OutletScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedules to fetch.
     */
    where?: OutletScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutletSchedules to fetch.
     */
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutletSchedules.
     */
    cursor?: OutletScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutletSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutletSchedules.
     */
    skip?: number
    distinct?: OutletScheduleScalarFieldEnum | OutletScheduleScalarFieldEnum[]
  }

  /**
   * OutletSchedule create
   */
  export type OutletScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a OutletSchedule.
     */
    data: XOR<OutletScheduleCreateInput, OutletScheduleUncheckedCreateInput>
  }

  /**
   * OutletSchedule createMany
   */
  export type OutletScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutletSchedules.
     */
    data: OutletScheduleCreateManyInput | OutletScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutletSchedule createManyAndReturn
   */
  export type OutletScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many OutletSchedules.
     */
    data: OutletScheduleCreateManyInput | OutletScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutletSchedule update
   */
  export type OutletScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a OutletSchedule.
     */
    data: XOR<OutletScheduleUpdateInput, OutletScheduleUncheckedUpdateInput>
    /**
     * Choose, which OutletSchedule to update.
     */
    where: OutletScheduleWhereUniqueInput
  }

  /**
   * OutletSchedule updateMany
   */
  export type OutletScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutletSchedules.
     */
    data: XOR<OutletScheduleUpdateManyMutationInput, OutletScheduleUncheckedUpdateManyInput>
    /**
     * Filter which OutletSchedules to update
     */
    where?: OutletScheduleWhereInput
    /**
     * Limit how many OutletSchedules to update.
     */
    limit?: number
  }

  /**
   * OutletSchedule updateManyAndReturn
   */
  export type OutletScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * The data used to update OutletSchedules.
     */
    data: XOR<OutletScheduleUpdateManyMutationInput, OutletScheduleUncheckedUpdateManyInput>
    /**
     * Filter which OutletSchedules to update
     */
    where?: OutletScheduleWhereInput
    /**
     * Limit how many OutletSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutletSchedule upsert
   */
  export type OutletScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the OutletSchedule to update in case it exists.
     */
    where: OutletScheduleWhereUniqueInput
    /**
     * In case the OutletSchedule found by the `where` argument doesn't exist, create a new OutletSchedule with this data.
     */
    create: XOR<OutletScheduleCreateInput, OutletScheduleUncheckedCreateInput>
    /**
     * In case the OutletSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutletScheduleUpdateInput, OutletScheduleUncheckedUpdateInput>
  }

  /**
   * OutletSchedule delete
   */
  export type OutletScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter which OutletSchedule to delete.
     */
    where: OutletScheduleWhereUniqueInput
  }

  /**
   * OutletSchedule deleteMany
   */
  export type OutletScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutletSchedules to delete
     */
    where?: OutletScheduleWhereInput
    /**
     * Limit how many OutletSchedules to delete.
     */
    limit?: number
  }

  /**
   * OutletSchedule without action
   */
  export type OutletScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    outletId: string | null
    shiftId: string | null
    role: $Enums.EmployeeRole | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    address: string | null
    isActive: boolean | null
    resetPasswordToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    outletId: string | null
    shiftId: string | null
    role: $Enums.EmployeeRole | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    address: string | null
    isActive: boolean | null
    resetPasswordToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    outletId: number
    shiftId: number
    role: number
    name: number
    email: number
    password: number
    phoneNumber: number
    address: number
    isActive: number
    resetPasswordToken: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    outletId?: true
    shiftId?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    address?: true
    isActive?: true
    resetPasswordToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    outletId?: true
    shiftId?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    address?: true
    isActive?: true
    resetPasswordToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    outletId?: true
    shiftId?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    address?: true
    isActive?: true
    resetPasswordToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive: boolean
    resetPasswordToken: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    shiftId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    address?: boolean
    isActive?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    attendances?: boolean | Employee$attendancesArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    leavesApproved?: boolean | Employee$leavesApprovedArgs<ExtArgs>
    workerTasks?: boolean | Employee$workerTasksArgs<ExtArgs>
    workerTasksAssigned?: boolean | Employee$workerTasksAssignedArgs<ExtArgs>
    ordersHandled?: boolean | Employee$ordersHandledArgs<ExtArgs>
    approvedBy?: boolean | Employee$approvedByArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    shiftId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    address?: boolean
    isActive?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    shiftId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    address?: boolean
    isActive?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    outletId?: boolean
    shiftId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    address?: boolean
    isActive?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "outletId" | "shiftId" | "role" | "name" | "email" | "password" | "phoneNumber" | "address" | "isActive" | "resetPasswordToken" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    attendances?: boolean | Employee$attendancesArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    leavesApproved?: boolean | Employee$leavesApprovedArgs<ExtArgs>
    workerTasks?: boolean | Employee$workerTasksArgs<ExtArgs>
    workerTasksAssigned?: boolean | Employee$workerTasksAssignedArgs<ExtArgs>
    ordersHandled?: boolean | Employee$ordersHandledArgs<ExtArgs>
    approvedBy?: boolean | Employee$approvedByArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      outlet: Prisma.$OutletPayload<ExtArgs>
      shift: Prisma.$ShiftPayload<ExtArgs>
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      leaves: Prisma.$LeaveRequestPayload<ExtArgs>[]
      leavesApproved: Prisma.$LeaveRequestPayload<ExtArgs>[]
      workerTasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
      workerTasksAssigned: Prisma.$EmployeeTaskPayload<ExtArgs>[]
      ordersHandled: Prisma.$OrderHeaderPayload<ExtArgs>[]
      approvedBy: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      outletId: string
      shiftId: string
      role: $Enums.EmployeeRole
      name: string
      email: string
      password: string
      phoneNumber: string
      address: string
      isActive: boolean
      resetPasswordToken: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shift<T extends ShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftDefaultArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendances<T extends Employee$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaves<T extends Employee$leavesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leavesApproved<T extends Employee$leavesApprovedArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leavesApprovedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerTasks<T extends Employee$workerTasksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$workerTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerTasksAssigned<T extends Employee$workerTasksAssignedArgs<ExtArgs> = {}>(args?: Subset<T, Employee$workerTasksAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordersHandled<T extends Employee$ordersHandledArgs<ExtArgs> = {}>(args?: Subset<T, Employee$ordersHandledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedBy<T extends Employee$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Employee$approvedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly outletId: FieldRef<"Employee", 'String'>
    readonly shiftId: FieldRef<"Employee", 'String'>
    readonly role: FieldRef<"Employee", 'EmployeeRole'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly password: FieldRef<"Employee", 'String'>
    readonly phoneNumber: FieldRef<"Employee", 'String'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly isActive: FieldRef<"Employee", 'Boolean'>
    readonly resetPasswordToken: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
    readonly deletedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.attendances
   */
  export type Employee$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Employee.leaves
   */
  export type Employee$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Employee.leavesApproved
   */
  export type Employee$leavesApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Employee.workerTasks
   */
  export type Employee$workerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * Employee.workerTasksAssigned
   */
  export type Employee$workerTasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * Employee.ordersHandled
   */
  export type Employee$ordersHandledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    where?: OrderHeaderWhereInput
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    cursor?: OrderHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * Employee.approvedBy
   */
  export type Employee$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ShiftMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    name: string
    startTime: Date
    endTime: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ShiftCountAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employees?: boolean | Shift$employeesArgs<ExtArgs>
    attendances?: boolean | Shift$attendancesArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startTime" | "endTime" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["shift"]>
  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Shift$employeesArgs<ExtArgs>
    attendances?: boolean | Shift$attendancesArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startTime: Date
      endTime: Date
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts and returns the data updated in the database.
     * @param {ShiftUpdateManyAndReturnArgs} args - Arguments to update many Shifts.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Shift$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Shift$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Shift$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Shift$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly name: FieldRef<"Shift", 'String'>
    readonly startTime: FieldRef<"Shift", 'DateTime'>
    readonly endTime: FieldRef<"Shift", 'DateTime'>
    readonly createdAt: FieldRef<"Shift", 'DateTime'>
    readonly updatedAt: FieldRef<"Shift", 'DateTime'>
    readonly deletedAt: FieldRef<"Shift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift updateManyAndReturn
   */
  export type ShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to delete.
     */
    limit?: number
  }

  /**
   * Shift.employees
   */
  export type Shift$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Shift.attendances
   */
  export type Shift$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    shiftId: string | null
    outletId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    clockInAt: Date | null
    clockOutAt: Date | null
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
    notes: string | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    shiftId: string | null
    outletId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    clockInAt: Date | null
    clockOutAt: Date | null
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
    notes: string | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    employeeId: number
    shiftId: number
    outletId: number
    date: number
    status: number
    clockInAt: number
    clockOutAt: number
    workMinutes: number
    lateMinutes: number
    earlyLeaveMin: number
    notes: number
    approvedById: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
  }

  export type AttendanceSumAggregateInputType = {
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    outletId?: true
    date?: true
    status?: true
    clockInAt?: true
    clockOutAt?: true
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
    notes?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    outletId?: true
    date?: true
    status?: true
    clockInAt?: true
    clockOutAt?: true
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
    notes?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    outletId?: true
    date?: true
    status?: true
    clockInAt?: true
    clockOutAt?: true
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
    notes?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date
    status: $Enums.AttendanceStatus
    clockInAt: Date | null
    clockOutAt: Date | null
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
    notes: string | null
    approvedById: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    outletId?: boolean
    date?: boolean
    status?: boolean
    clockInAt?: boolean
    clockOutAt?: boolean
    workMinutes?: boolean
    lateMinutes?: boolean
    earlyLeaveMin?: boolean
    notes?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    outletId?: boolean
    date?: boolean
    status?: boolean
    clockInAt?: boolean
    clockOutAt?: boolean
    workMinutes?: boolean
    lateMinutes?: boolean
    earlyLeaveMin?: boolean
    notes?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    outletId?: boolean
    date?: boolean
    status?: boolean
    clockInAt?: boolean
    clockOutAt?: boolean
    workMinutes?: boolean
    lateMinutes?: boolean
    earlyLeaveMin?: boolean
    notes?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    outletId?: boolean
    date?: boolean
    status?: boolean
    clockInAt?: boolean
    clockOutAt?: boolean
    workMinutes?: boolean
    lateMinutes?: boolean
    earlyLeaveMin?: boolean
    notes?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "shiftId" | "outletId" | "date" | "status" | "clockInAt" | "clockOutAt" | "workMinutes" | "lateMinutes" | "earlyLeaveMin" | "notes" | "approvedById" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      shift: Prisma.$ShiftPayload<ExtArgs>
      outlet: Prisma.$OutletPayload<ExtArgs>
      approvedBy: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      shiftId: string
      outletId: string
      date: Date
      status: $Enums.AttendanceStatus
      clockInAt: Date | null
      clockOutAt: Date | null
      workMinutes: number | null
      lateMinutes: number | null
      earlyLeaveMin: number | null
      notes: string | null
      approvedById: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shift<T extends ShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftDefaultArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Attendance$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$approvedByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly employeeId: FieldRef<"Attendance", 'String'>
    readonly shiftId: FieldRef<"Attendance", 'String'>
    readonly outletId: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly clockInAt: FieldRef<"Attendance", 'DateTime'>
    readonly clockOutAt: FieldRef<"Attendance", 'DateTime'>
    readonly workMinutes: FieldRef<"Attendance", 'Int'>
    readonly lateMinutes: FieldRef<"Attendance", 'Int'>
    readonly earlyLeaveMin: FieldRef<"Attendance", 'Int'>
    readonly notes: FieldRef<"Attendance", 'String'>
    readonly approvedById: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
    readonly deletedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance.approvedBy
   */
  export type Attendance$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    outletId: string | null
    type: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.LeaveReqStat | null
    approvedById: string | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    outletId: string | null
    type: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.LeaveReqStat | null
    approvedById: string | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    employeeId: number
    outletId: number
    type: number
    startDate: number
    endDate: number
    status: number
    approvedById: number
    approvedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LeaveRequestMinAggregateInputType = {
    id?: true
    employeeId?: true
    outletId?: true
    type?: true
    startDate?: true
    endDate?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    employeeId?: true
    outletId?: true
    type?: true
    startDate?: true
    endDate?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    employeeId?: true
    outletId?: true
    type?: true
    startDate?: true
    endDate?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: string
    employeeId: string
    outletId: string
    type: $Enums.LeaveType
    startDate: Date
    endDate: Date
    status: $Enums.LeaveReqStat
    approvedById: string | null
    approvedAt: Date | null
    notes: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: LeaveRequestCountAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    outletId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    outletId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    outletId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectScalar = {
    id?: boolean
    employeeId?: boolean
    outletId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LeaveRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "outletId" | "type" | "startDate" | "endDate" | "status" | "approvedById" | "approvedAt" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["leaveRequest"]>
  export type LeaveRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }
  export type LeaveRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }
  export type LeaveRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | LeaveRequest$approvedByArgs<ExtArgs>
  }

  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      outlet: Prisma.$OutletPayload<ExtArgs>
      approvedBy: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      outletId: string
      type: $Enums.LeaveType
      startDate: Date
      endDate: Date
      status: $Enums.LeaveReqStat
      approvedById: string | null
      approvedAt: Date | null
      notes: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }

  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveRequestFindUniqueArgs>(args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveRequestFindFirstArgs>(args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveRequestFindManyArgs>(args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
     */
    create<T extends LeaveRequestCreateArgs>(args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveRequests.
     * @param {LeaveRequestCreateManyArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveRequestCreateManyArgs>(args?: SelectSubset<T, LeaveRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveRequests and returns the data saved in the database.
     * @param {LeaveRequestCreateManyAndReturnArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
     */
    delete<T extends LeaveRequestDeleteArgs>(args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveRequestUpdateArgs>(args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveRequestDeleteManyArgs>(args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveRequestUpdateManyArgs>(args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests and returns the data updated in the database.
     * @param {LeaveRequestUpdateManyAndReturnArgs} args - Arguments to update many LeaveRequests.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
     */
    upsert<T extends LeaveRequestUpsertArgs>(args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends LeaveRequest$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$approvedByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveRequest model
   */
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'String'>
    readonly employeeId: FieldRef<"LeaveRequest", 'String'>
    readonly outletId: FieldRef<"LeaveRequest", 'String'>
    readonly type: FieldRef<"LeaveRequest", 'LeaveType'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly status: FieldRef<"LeaveRequest", 'LeaveReqStat'>
    readonly approvedById: FieldRef<"LeaveRequest", 'String'>
    readonly approvedAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly notes: FieldRef<"LeaveRequest", 'String'>
    readonly createdAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly deletedAt: FieldRef<"LeaveRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }

  /**
   * LeaveRequest createMany
   */
  export type LeaveRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest createManyAndReturn
   */
  export type LeaveRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to update.
     */
    limit?: number
  }

  /**
   * LeaveRequest updateManyAndReturn
   */
  export type LeaveRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }

  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to delete.
     */
    limit?: number
  }

  /**
   * LeaveRequest.approvedBy
   */
  export type LeaveRequest$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
  }


  /**
   * Model OrderHeader
   */

  export type AggregateOrderHeader = {
    _count: OrderHeaderCountAggregateOutputType | null
    _min: OrderHeaderMinAggregateOutputType | null
    _max: OrderHeaderMaxAggregateOutputType | null
  }

  export type OrderHeaderMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    outletId: string | null
    handledById: string | null
    status: $Enums.OrderStatus | null
    notes: string | null
    pickupAt: Date | null
    deliveryAt: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderHeaderMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    outletId: string | null
    handledById: string | null
    status: $Enums.OrderStatus | null
    notes: string | null
    pickupAt: Date | null
    deliveryAt: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderHeaderCountAggregateOutputType = {
    id: number
    customerId: number
    outletId: number
    handledById: number
    status: number
    notes: number
    pickupAt: number
    deliveryAt: number
    paymentMethod: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OrderHeaderMinAggregateInputType = {
    id?: true
    customerId?: true
    outletId?: true
    handledById?: true
    status?: true
    notes?: true
    pickupAt?: true
    deliveryAt?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderHeaderMaxAggregateInputType = {
    id?: true
    customerId?: true
    outletId?: true
    handledById?: true
    status?: true
    notes?: true
    pickupAt?: true
    deliveryAt?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderHeaderCountAggregateInputType = {
    id?: true
    customerId?: true
    outletId?: true
    handledById?: true
    status?: true
    notes?: true
    pickupAt?: true
    deliveryAt?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OrderHeaderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderHeader to aggregate.
     */
    where?: OrderHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHeaders to fetch.
     */
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderHeaders
    **/
    _count?: true | OrderHeaderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderHeaderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderHeaderMaxAggregateInputType
  }

  export type GetOrderHeaderAggregateType<T extends OrderHeaderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderHeader]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderHeader[P]>
      : GetScalarType<T[P], AggregateOrderHeader[P]>
  }




  export type OrderHeaderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHeaderWhereInput
    orderBy?: OrderHeaderOrderByWithAggregationInput | OrderHeaderOrderByWithAggregationInput[]
    by: OrderHeaderScalarFieldEnum[] | OrderHeaderScalarFieldEnum
    having?: OrderHeaderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderHeaderCountAggregateInputType | true
    _min?: OrderHeaderMinAggregateInputType
    _max?: OrderHeaderMaxAggregateInputType
  }

  export type OrderHeaderGroupByOutputType = {
    id: string
    customerId: string
    outletId: string
    handledById: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt: Date | null
    deliveryAt: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OrderHeaderCountAggregateOutputType | null
    _min: OrderHeaderMinAggregateOutputType | null
    _max: OrderHeaderMaxAggregateOutputType | null
  }

  type GetOrderHeaderGroupByPayload<T extends OrderHeaderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderHeaderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderHeaderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderHeaderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderHeaderGroupByOutputType[P]>
        }
      >
    >


  export type OrderHeaderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    outletId?: boolean
    handledById?: boolean
    status?: boolean
    notes?: boolean
    pickupAt?: boolean
    deliveryAt?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    handledBy?: boolean | OrderHeader$handledByArgs<ExtArgs>
    items?: boolean | OrderHeader$itemsArgs<ExtArgs>
    tasks?: boolean | OrderHeader$tasksArgs<ExtArgs>
    _count?: boolean | OrderHeaderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderHeader"]>

  export type OrderHeaderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    outletId?: boolean
    handledById?: boolean
    status?: boolean
    notes?: boolean
    pickupAt?: boolean
    deliveryAt?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    handledBy?: boolean | OrderHeader$handledByArgs<ExtArgs>
  }, ExtArgs["result"]["orderHeader"]>

  export type OrderHeaderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    outletId?: boolean
    handledById?: boolean
    status?: boolean
    notes?: boolean
    pickupAt?: boolean
    deliveryAt?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    handledBy?: boolean | OrderHeader$handledByArgs<ExtArgs>
  }, ExtArgs["result"]["orderHeader"]>

  export type OrderHeaderSelectScalar = {
    id?: boolean
    customerId?: boolean
    outletId?: boolean
    handledById?: boolean
    status?: boolean
    notes?: boolean
    pickupAt?: boolean
    deliveryAt?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OrderHeaderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "outletId" | "handledById" | "status" | "notes" | "pickupAt" | "deliveryAt" | "paymentMethod" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["orderHeader"]>
  export type OrderHeaderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    handledBy?: boolean | OrderHeader$handledByArgs<ExtArgs>
    items?: boolean | OrderHeader$itemsArgs<ExtArgs>
    tasks?: boolean | OrderHeader$tasksArgs<ExtArgs>
    _count?: boolean | OrderHeaderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderHeaderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    handledBy?: boolean | OrderHeader$handledByArgs<ExtArgs>
  }
  export type OrderHeaderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    handledBy?: boolean | OrderHeader$handledByArgs<ExtArgs>
  }

  export type $OrderHeaderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderHeader"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      outlet: Prisma.$OutletPayload<ExtArgs>
      handledBy: Prisma.$EmployeePayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      tasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      outletId: string
      handledById: string
      status: $Enums.OrderStatus
      notes: string
      pickupAt: Date | null
      deliveryAt: Date | null
      paymentMethod: $Enums.PaymentMethod | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["orderHeader"]>
    composites: {}
  }

  type OrderHeaderGetPayload<S extends boolean | null | undefined | OrderHeaderDefaultArgs> = $Result.GetResult<Prisma.$OrderHeaderPayload, S>

  type OrderHeaderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderHeaderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderHeaderCountAggregateInputType | true
    }

  export interface OrderHeaderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderHeader'], meta: { name: 'OrderHeader' } }
    /**
     * Find zero or one OrderHeader that matches the filter.
     * @param {OrderHeaderFindUniqueArgs} args - Arguments to find a OrderHeader
     * @example
     * // Get one OrderHeader
     * const orderHeader = await prisma.orderHeader.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderHeaderFindUniqueArgs>(args: SelectSubset<T, OrderHeaderFindUniqueArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderHeader that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderHeaderFindUniqueOrThrowArgs} args - Arguments to find a OrderHeader
     * @example
     * // Get one OrderHeader
     * const orderHeader = await prisma.orderHeader.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderHeaderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderHeaderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderHeader that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderFindFirstArgs} args - Arguments to find a OrderHeader
     * @example
     * // Get one OrderHeader
     * const orderHeader = await prisma.orderHeader.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderHeaderFindFirstArgs>(args?: SelectSubset<T, OrderHeaderFindFirstArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderHeader that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderFindFirstOrThrowArgs} args - Arguments to find a OrderHeader
     * @example
     * // Get one OrderHeader
     * const orderHeader = await prisma.orderHeader.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderHeaderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderHeaderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderHeaders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderHeaders
     * const orderHeaders = await prisma.orderHeader.findMany()
     * 
     * // Get first 10 OrderHeaders
     * const orderHeaders = await prisma.orderHeader.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderHeaderWithIdOnly = await prisma.orderHeader.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderHeaderFindManyArgs>(args?: SelectSubset<T, OrderHeaderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderHeader.
     * @param {OrderHeaderCreateArgs} args - Arguments to create a OrderHeader.
     * @example
     * // Create one OrderHeader
     * const OrderHeader = await prisma.orderHeader.create({
     *   data: {
     *     // ... data to create a OrderHeader
     *   }
     * })
     * 
     */
    create<T extends OrderHeaderCreateArgs>(args: SelectSubset<T, OrderHeaderCreateArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderHeaders.
     * @param {OrderHeaderCreateManyArgs} args - Arguments to create many OrderHeaders.
     * @example
     * // Create many OrderHeaders
     * const orderHeader = await prisma.orderHeader.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderHeaderCreateManyArgs>(args?: SelectSubset<T, OrderHeaderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderHeaders and returns the data saved in the database.
     * @param {OrderHeaderCreateManyAndReturnArgs} args - Arguments to create many OrderHeaders.
     * @example
     * // Create many OrderHeaders
     * const orderHeader = await prisma.orderHeader.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderHeaders and only return the `id`
     * const orderHeaderWithIdOnly = await prisma.orderHeader.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderHeaderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderHeaderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderHeader.
     * @param {OrderHeaderDeleteArgs} args - Arguments to delete one OrderHeader.
     * @example
     * // Delete one OrderHeader
     * const OrderHeader = await prisma.orderHeader.delete({
     *   where: {
     *     // ... filter to delete one OrderHeader
     *   }
     * })
     * 
     */
    delete<T extends OrderHeaderDeleteArgs>(args: SelectSubset<T, OrderHeaderDeleteArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderHeader.
     * @param {OrderHeaderUpdateArgs} args - Arguments to update one OrderHeader.
     * @example
     * // Update one OrderHeader
     * const orderHeader = await prisma.orderHeader.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderHeaderUpdateArgs>(args: SelectSubset<T, OrderHeaderUpdateArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderHeaders.
     * @param {OrderHeaderDeleteManyArgs} args - Arguments to filter OrderHeaders to delete.
     * @example
     * // Delete a few OrderHeaders
     * const { count } = await prisma.orderHeader.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderHeaderDeleteManyArgs>(args?: SelectSubset<T, OrderHeaderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderHeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderHeaders
     * const orderHeader = await prisma.orderHeader.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderHeaderUpdateManyArgs>(args: SelectSubset<T, OrderHeaderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderHeaders and returns the data updated in the database.
     * @param {OrderHeaderUpdateManyAndReturnArgs} args - Arguments to update many OrderHeaders.
     * @example
     * // Update many OrderHeaders
     * const orderHeader = await prisma.orderHeader.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderHeaders and only return the `id`
     * const orderHeaderWithIdOnly = await prisma.orderHeader.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderHeaderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderHeaderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderHeader.
     * @param {OrderHeaderUpsertArgs} args - Arguments to update or create a OrderHeader.
     * @example
     * // Update or create a OrderHeader
     * const orderHeader = await prisma.orderHeader.upsert({
     *   create: {
     *     // ... data to create a OrderHeader
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderHeader we want to update
     *   }
     * })
     */
    upsert<T extends OrderHeaderUpsertArgs>(args: SelectSubset<T, OrderHeaderUpsertArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderHeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderCountArgs} args - Arguments to filter OrderHeaders to count.
     * @example
     * // Count the number of OrderHeaders
     * const count = await prisma.orderHeader.count({
     *   where: {
     *     // ... the filter for the OrderHeaders we want to count
     *   }
     * })
    **/
    count<T extends OrderHeaderCountArgs>(
      args?: Subset<T, OrderHeaderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderHeaderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderHeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderHeaderAggregateArgs>(args: Subset<T, OrderHeaderAggregateArgs>): Prisma.PrismaPromise<GetOrderHeaderAggregateType<T>>

    /**
     * Group by OrderHeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderHeaderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderHeaderGroupByArgs['orderBy'] }
        : { orderBy?: OrderHeaderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderHeaderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderHeaderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderHeader model
   */
  readonly fields: OrderHeaderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderHeader.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderHeaderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    handledBy<T extends OrderHeader$handledByArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeader$handledByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends OrderHeader$itemsArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeader$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends OrderHeader$tasksArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeader$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderHeader model
   */
  interface OrderHeaderFieldRefs {
    readonly id: FieldRef<"OrderHeader", 'String'>
    readonly customerId: FieldRef<"OrderHeader", 'String'>
    readonly outletId: FieldRef<"OrderHeader", 'String'>
    readonly handledById: FieldRef<"OrderHeader", 'String'>
    readonly status: FieldRef<"OrderHeader", 'OrderStatus'>
    readonly notes: FieldRef<"OrderHeader", 'String'>
    readonly pickupAt: FieldRef<"OrderHeader", 'DateTime'>
    readonly deliveryAt: FieldRef<"OrderHeader", 'DateTime'>
    readonly paymentMethod: FieldRef<"OrderHeader", 'PaymentMethod'>
    readonly createdAt: FieldRef<"OrderHeader", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderHeader", 'DateTime'>
    readonly deletedAt: FieldRef<"OrderHeader", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderHeader findUnique
   */
  export type OrderHeaderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeader to fetch.
     */
    where: OrderHeaderWhereUniqueInput
  }

  /**
   * OrderHeader findUniqueOrThrow
   */
  export type OrderHeaderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeader to fetch.
     */
    where: OrderHeaderWhereUniqueInput
  }

  /**
   * OrderHeader findFirst
   */
  export type OrderHeaderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeader to fetch.
     */
    where?: OrderHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHeaders to fetch.
     */
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderHeaders.
     */
    cursor?: OrderHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderHeaders.
     */
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * OrderHeader findFirstOrThrow
   */
  export type OrderHeaderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeader to fetch.
     */
    where?: OrderHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHeaders to fetch.
     */
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderHeaders.
     */
    cursor?: OrderHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderHeaders.
     */
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * OrderHeader findMany
   */
  export type OrderHeaderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeaders to fetch.
     */
    where?: OrderHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHeaders to fetch.
     */
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderHeaders.
     */
    cursor?: OrderHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHeaders.
     */
    skip?: number
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * OrderHeader create
   */
  export type OrderHeaderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderHeader.
     */
    data: XOR<OrderHeaderCreateInput, OrderHeaderUncheckedCreateInput>
  }

  /**
   * OrderHeader createMany
   */
  export type OrderHeaderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderHeaders.
     */
    data: OrderHeaderCreateManyInput | OrderHeaderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderHeader createManyAndReturn
   */
  export type OrderHeaderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * The data used to create many OrderHeaders.
     */
    data: OrderHeaderCreateManyInput | OrderHeaderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderHeader update
   */
  export type OrderHeaderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderHeader.
     */
    data: XOR<OrderHeaderUpdateInput, OrderHeaderUncheckedUpdateInput>
    /**
     * Choose, which OrderHeader to update.
     */
    where: OrderHeaderWhereUniqueInput
  }

  /**
   * OrderHeader updateMany
   */
  export type OrderHeaderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderHeaders.
     */
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyInput>
    /**
     * Filter which OrderHeaders to update
     */
    where?: OrderHeaderWhereInput
    /**
     * Limit how many OrderHeaders to update.
     */
    limit?: number
  }

  /**
   * OrderHeader updateManyAndReturn
   */
  export type OrderHeaderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * The data used to update OrderHeaders.
     */
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyInput>
    /**
     * Filter which OrderHeaders to update
     */
    where?: OrderHeaderWhereInput
    /**
     * Limit how many OrderHeaders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderHeader upsert
   */
  export type OrderHeaderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderHeader to update in case it exists.
     */
    where: OrderHeaderWhereUniqueInput
    /**
     * In case the OrderHeader found by the `where` argument doesn't exist, create a new OrderHeader with this data.
     */
    create: XOR<OrderHeaderCreateInput, OrderHeaderUncheckedCreateInput>
    /**
     * In case the OrderHeader was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderHeaderUpdateInput, OrderHeaderUncheckedUpdateInput>
  }

  /**
   * OrderHeader delete
   */
  export type OrderHeaderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter which OrderHeader to delete.
     */
    where: OrderHeaderWhereUniqueInput
  }

  /**
   * OrderHeader deleteMany
   */
  export type OrderHeaderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderHeaders to delete
     */
    where?: OrderHeaderWhereInput
    /**
     * Limit how many OrderHeaders to delete.
     */
    limit?: number
  }

  /**
   * OrderHeader.handledBy
   */
  export type OrderHeader$handledByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * OrderHeader.items
   */
  export type OrderHeader$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderHeader.tasks
   */
  export type OrderHeader$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * OrderHeader without action
   */
  export type OrderHeaderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    qty: number | null
    unitPrice: number | null
    subTotal: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    qty: number | null
    unitPrice: number | null
    subTotal: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    serviceId: string | null
    qty: number | null
    note: string | null
    unitPrice: number | null
    subTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    serviceId: string | null
    qty: number | null
    note: string | null
    unitPrice: number | null
    subTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    serviceId: number
    qty: number
    note: number
    unitPrice: number
    subTotal: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    subTotal?: true
  }

  export type OrderItemSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    subTotal?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    serviceId?: true
    qty?: true
    note?: true
    unitPrice?: true
    subTotal?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    serviceId?: true
    qty?: true
    note?: true
    unitPrice?: true
    subTotal?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    serviceId?: true
    qty?: true
    note?: true
    unitPrice?: true
    subTotal?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    serviceId: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    qty?: boolean
    note?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    order?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    qty?: boolean
    note?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    order?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    qty?: boolean
    note?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    order?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    qty?: boolean
    note?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "serviceId" | "qty" | "note" | "unitPrice" | "subTotal" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderHeaderPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      serviceId: string
      qty: number
      note: string
      unitPrice: number
      subTotal: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderHeaderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeaderDefaultArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly serviceId: FieldRef<"OrderItem", 'String'>
    readonly qty: FieldRef<"OrderItem", 'Float'>
    readonly note: FieldRef<"OrderItem", 'String'>
    readonly unitPrice: FieldRef<"OrderItem", 'Int'>
    readonly subTotal: FieldRef<"OrderItem", 'Int'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly deletedAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model WorkerStation
   */

  export type AggregateWorkerStation = {
    _count: WorkerStationCountAggregateOutputType | null
    _min: WorkerStationMinAggregateOutputType | null
    _max: WorkerStationMaxAggregateOutputType | null
  }

  export type WorkerStationMinAggregateOutputType = {
    id: string | null
    station: $Enums.Station | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkerStationMaxAggregateOutputType = {
    id: string | null
    station: $Enums.Station | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkerStationCountAggregateOutputType = {
    id: number
    station: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WorkerStationMinAggregateInputType = {
    id?: true
    station?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkerStationMaxAggregateInputType = {
    id?: true
    station?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkerStationCountAggregateInputType = {
    id?: true
    station?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WorkerStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerStation to aggregate.
     */
    where?: WorkerStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerStations to fetch.
     */
    orderBy?: WorkerStationOrderByWithRelationInput | WorkerStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkerStations
    **/
    _count?: true | WorkerStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerStationMaxAggregateInputType
  }

  export type GetWorkerStationAggregateType<T extends WorkerStationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerStation[P]>
      : GetScalarType<T[P], AggregateWorkerStation[P]>
  }




  export type WorkerStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerStationWhereInput
    orderBy?: WorkerStationOrderByWithAggregationInput | WorkerStationOrderByWithAggregationInput[]
    by: WorkerStationScalarFieldEnum[] | WorkerStationScalarFieldEnum
    having?: WorkerStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerStationCountAggregateInputType | true
    _min?: WorkerStationMinAggregateInputType
    _max?: WorkerStationMaxAggregateInputType
  }

  export type WorkerStationGroupByOutputType = {
    id: string
    station: $Enums.Station
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WorkerStationCountAggregateOutputType | null
    _min: WorkerStationMinAggregateOutputType | null
    _max: WorkerStationMaxAggregateOutputType | null
  }

  type GetWorkerStationGroupByPayload<T extends WorkerStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerStationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerStationGroupByOutputType[P]>
        }
      >
    >


  export type WorkerStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    station?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tasks?: boolean | WorkerStation$tasksArgs<ExtArgs>
    _count?: boolean | WorkerStationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerStation"]>

  export type WorkerStationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    station?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["workerStation"]>

  export type WorkerStationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    station?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["workerStation"]>

  export type WorkerStationSelectScalar = {
    id?: boolean
    station?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WorkerStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "station" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["workerStation"]>
  export type WorkerStationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | WorkerStation$tasksArgs<ExtArgs>
    _count?: boolean | WorkerStationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerStationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WorkerStationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkerStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkerStation"
    objects: {
      tasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      station: $Enums.Station
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["workerStation"]>
    composites: {}
  }

  type WorkerStationGetPayload<S extends boolean | null | undefined | WorkerStationDefaultArgs> = $Result.GetResult<Prisma.$WorkerStationPayload, S>

  type WorkerStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkerStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkerStationCountAggregateInputType | true
    }

  export interface WorkerStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkerStation'], meta: { name: 'WorkerStation' } }
    /**
     * Find zero or one WorkerStation that matches the filter.
     * @param {WorkerStationFindUniqueArgs} args - Arguments to find a WorkerStation
     * @example
     * // Get one WorkerStation
     * const workerStation = await prisma.workerStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerStationFindUniqueArgs>(args: SelectSubset<T, WorkerStationFindUniqueArgs<ExtArgs>>): Prisma__WorkerStationClient<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkerStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkerStationFindUniqueOrThrowArgs} args - Arguments to find a WorkerStation
     * @example
     * // Get one WorkerStation
     * const workerStation = await prisma.workerStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerStationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerStationClient<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerStationFindFirstArgs} args - Arguments to find a WorkerStation
     * @example
     * // Get one WorkerStation
     * const workerStation = await prisma.workerStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerStationFindFirstArgs>(args?: SelectSubset<T, WorkerStationFindFirstArgs<ExtArgs>>): Prisma__WorkerStationClient<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerStationFindFirstOrThrowArgs} args - Arguments to find a WorkerStation
     * @example
     * // Get one WorkerStation
     * const workerStation = await prisma.workerStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerStationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerStationClient<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkerStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkerStations
     * const workerStations = await prisma.workerStation.findMany()
     * 
     * // Get first 10 WorkerStations
     * const workerStations = await prisma.workerStation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerStationWithIdOnly = await prisma.workerStation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerStationFindManyArgs>(args?: SelectSubset<T, WorkerStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkerStation.
     * @param {WorkerStationCreateArgs} args - Arguments to create a WorkerStation.
     * @example
     * // Create one WorkerStation
     * const WorkerStation = await prisma.workerStation.create({
     *   data: {
     *     // ... data to create a WorkerStation
     *   }
     * })
     * 
     */
    create<T extends WorkerStationCreateArgs>(args: SelectSubset<T, WorkerStationCreateArgs<ExtArgs>>): Prisma__WorkerStationClient<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkerStations.
     * @param {WorkerStationCreateManyArgs} args - Arguments to create many WorkerStations.
     * @example
     * // Create many WorkerStations
     * const workerStation = await prisma.workerStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerStationCreateManyArgs>(args?: SelectSubset<T, WorkerStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkerStations and returns the data saved in the database.
     * @param {WorkerStationCreateManyAndReturnArgs} args - Arguments to create many WorkerStations.
     * @example
     * // Create many WorkerStations
     * const workerStation = await prisma.workerStation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkerStations and only return the `id`
     * const workerStationWithIdOnly = await prisma.workerStation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerStationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerStationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkerStation.
     * @param {WorkerStationDeleteArgs} args - Arguments to delete one WorkerStation.
     * @example
     * // Delete one WorkerStation
     * const WorkerStation = await prisma.workerStation.delete({
     *   where: {
     *     // ... filter to delete one WorkerStation
     *   }
     * })
     * 
     */
    delete<T extends WorkerStationDeleteArgs>(args: SelectSubset<T, WorkerStationDeleteArgs<ExtArgs>>): Prisma__WorkerStationClient<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkerStation.
     * @param {WorkerStationUpdateArgs} args - Arguments to update one WorkerStation.
     * @example
     * // Update one WorkerStation
     * const workerStation = await prisma.workerStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerStationUpdateArgs>(args: SelectSubset<T, WorkerStationUpdateArgs<ExtArgs>>): Prisma__WorkerStationClient<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkerStations.
     * @param {WorkerStationDeleteManyArgs} args - Arguments to filter WorkerStations to delete.
     * @example
     * // Delete a few WorkerStations
     * const { count } = await prisma.workerStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerStationDeleteManyArgs>(args?: SelectSubset<T, WorkerStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkerStations
     * const workerStation = await prisma.workerStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerStationUpdateManyArgs>(args: SelectSubset<T, WorkerStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerStations and returns the data updated in the database.
     * @param {WorkerStationUpdateManyAndReturnArgs} args - Arguments to update many WorkerStations.
     * @example
     * // Update many WorkerStations
     * const workerStation = await prisma.workerStation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkerStations and only return the `id`
     * const workerStationWithIdOnly = await prisma.workerStation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkerStationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkerStationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkerStation.
     * @param {WorkerStationUpsertArgs} args - Arguments to update or create a WorkerStation.
     * @example
     * // Update or create a WorkerStation
     * const workerStation = await prisma.workerStation.upsert({
     *   create: {
     *     // ... data to create a WorkerStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkerStation we want to update
     *   }
     * })
     */
    upsert<T extends WorkerStationUpsertArgs>(args: SelectSubset<T, WorkerStationUpsertArgs<ExtArgs>>): Prisma__WorkerStationClient<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkerStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerStationCountArgs} args - Arguments to filter WorkerStations to count.
     * @example
     * // Count the number of WorkerStations
     * const count = await prisma.workerStation.count({
     *   where: {
     *     // ... the filter for the WorkerStations we want to count
     *   }
     * })
    **/
    count<T extends WorkerStationCountArgs>(
      args?: Subset<T, WorkerStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkerStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerStationAggregateArgs>(args: Subset<T, WorkerStationAggregateArgs>): Prisma.PrismaPromise<GetWorkerStationAggregateType<T>>

    /**
     * Group by WorkerStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerStationGroupByArgs['orderBy'] }
        : { orderBy?: WorkerStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkerStation model
   */
  readonly fields: WorkerStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkerStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends WorkerStation$tasksArgs<ExtArgs> = {}>(args?: Subset<T, WorkerStation$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkerStation model
   */
  interface WorkerStationFieldRefs {
    readonly id: FieldRef<"WorkerStation", 'String'>
    readonly station: FieldRef<"WorkerStation", 'Station'>
    readonly createdAt: FieldRef<"WorkerStation", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkerStation", 'DateTime'>
    readonly deletedAt: FieldRef<"WorkerStation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkerStation findUnique
   */
  export type WorkerStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerStation to fetch.
     */
    where: WorkerStationWhereUniqueInput
  }

  /**
   * WorkerStation findUniqueOrThrow
   */
  export type WorkerStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerStation to fetch.
     */
    where: WorkerStationWhereUniqueInput
  }

  /**
   * WorkerStation findFirst
   */
  export type WorkerStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerStation to fetch.
     */
    where?: WorkerStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerStations to fetch.
     */
    orderBy?: WorkerStationOrderByWithRelationInput | WorkerStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerStations.
     */
    cursor?: WorkerStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerStations.
     */
    distinct?: WorkerStationScalarFieldEnum | WorkerStationScalarFieldEnum[]
  }

  /**
   * WorkerStation findFirstOrThrow
   */
  export type WorkerStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerStation to fetch.
     */
    where?: WorkerStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerStations to fetch.
     */
    orderBy?: WorkerStationOrderByWithRelationInput | WorkerStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerStations.
     */
    cursor?: WorkerStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerStations.
     */
    distinct?: WorkerStationScalarFieldEnum | WorkerStationScalarFieldEnum[]
  }

  /**
   * WorkerStation findMany
   */
  export type WorkerStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerStations to fetch.
     */
    where?: WorkerStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerStations to fetch.
     */
    orderBy?: WorkerStationOrderByWithRelationInput | WorkerStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkerStations.
     */
    cursor?: WorkerStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerStations.
     */
    skip?: number
    distinct?: WorkerStationScalarFieldEnum | WorkerStationScalarFieldEnum[]
  }

  /**
   * WorkerStation create
   */
  export type WorkerStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkerStation.
     */
    data: XOR<WorkerStationCreateInput, WorkerStationUncheckedCreateInput>
  }

  /**
   * WorkerStation createMany
   */
  export type WorkerStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkerStations.
     */
    data: WorkerStationCreateManyInput | WorkerStationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkerStation createManyAndReturn
   */
  export type WorkerStationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkerStations.
     */
    data: WorkerStationCreateManyInput | WorkerStationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkerStation update
   */
  export type WorkerStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkerStation.
     */
    data: XOR<WorkerStationUpdateInput, WorkerStationUncheckedUpdateInput>
    /**
     * Choose, which WorkerStation to update.
     */
    where: WorkerStationWhereUniqueInput
  }

  /**
   * WorkerStation updateMany
   */
  export type WorkerStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkerStations.
     */
    data: XOR<WorkerStationUpdateManyMutationInput, WorkerStationUncheckedUpdateManyInput>
    /**
     * Filter which WorkerStations to update
     */
    where?: WorkerStationWhereInput
    /**
     * Limit how many WorkerStations to update.
     */
    limit?: number
  }

  /**
   * WorkerStation updateManyAndReturn
   */
  export type WorkerStationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * The data used to update WorkerStations.
     */
    data: XOR<WorkerStationUpdateManyMutationInput, WorkerStationUncheckedUpdateManyInput>
    /**
     * Filter which WorkerStations to update
     */
    where?: WorkerStationWhereInput
    /**
     * Limit how many WorkerStations to update.
     */
    limit?: number
  }

  /**
   * WorkerStation upsert
   */
  export type WorkerStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkerStation to update in case it exists.
     */
    where: WorkerStationWhereUniqueInput
    /**
     * In case the WorkerStation found by the `where` argument doesn't exist, create a new WorkerStation with this data.
     */
    create: XOR<WorkerStationCreateInput, WorkerStationUncheckedCreateInput>
    /**
     * In case the WorkerStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerStationUpdateInput, WorkerStationUncheckedUpdateInput>
  }

  /**
   * WorkerStation delete
   */
  export type WorkerStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    /**
     * Filter which WorkerStation to delete.
     */
    where: WorkerStationWhereUniqueInput
  }

  /**
   * WorkerStation deleteMany
   */
  export type WorkerStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerStations to delete
     */
    where?: WorkerStationWhereInput
    /**
     * Limit how many WorkerStations to delete.
     */
    limit?: number
  }

  /**
   * WorkerStation.tasks
   */
  export type WorkerStation$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * WorkerStation without action
   */
  export type WorkerStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeTask
   */

  export type AggregateEmployeeTask = {
    _count: EmployeeTaskCountAggregateOutputType | null
    _avg: EmployeeTaskAvgAggregateOutputType | null
    _sum: EmployeeTaskSumAggregateOutputType | null
    _min: EmployeeTaskMinAggregateOutputType | null
    _max: EmployeeTaskMaxAggregateOutputType | null
  }

  export type EmployeeTaskAvgAggregateOutputType = {
    qty: number | null
  }

  export type EmployeeTaskSumAggregateOutputType = {
    qty: number | null
  }

  export type EmployeeTaskMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    assignedById: string | null
    orderId: string | null
    outletId: string | null
    workStationId: string | null
    type: $Enums.Station | null
    status: $Enums.TaskStatus | null
    startAt: Date | null
    finishedAt: Date | null
    qty: number | null
    isApproved: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeTaskMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    assignedById: string | null
    orderId: string | null
    outletId: string | null
    workStationId: string | null
    type: $Enums.Station | null
    status: $Enums.TaskStatus | null
    startAt: Date | null
    finishedAt: Date | null
    qty: number | null
    isApproved: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeTaskCountAggregateOutputType = {
    id: number
    employeeId: number
    assignedById: number
    orderId: number
    outletId: number
    workStationId: number
    type: number
    status: number
    startAt: number
    finishedAt: number
    qty: number
    isApproved: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EmployeeTaskAvgAggregateInputType = {
    qty?: true
  }

  export type EmployeeTaskSumAggregateInputType = {
    qty?: true
  }

  export type EmployeeTaskMinAggregateInputType = {
    id?: true
    employeeId?: true
    assignedById?: true
    orderId?: true
    outletId?: true
    workStationId?: true
    type?: true
    status?: true
    startAt?: true
    finishedAt?: true
    qty?: true
    isApproved?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeTaskMaxAggregateInputType = {
    id?: true
    employeeId?: true
    assignedById?: true
    orderId?: true
    outletId?: true
    workStationId?: true
    type?: true
    status?: true
    startAt?: true
    finishedAt?: true
    qty?: true
    isApproved?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeTaskCountAggregateInputType = {
    id?: true
    employeeId?: true
    assignedById?: true
    orderId?: true
    outletId?: true
    workStationId?: true
    type?: true
    status?: true
    startAt?: true
    finishedAt?: true
    qty?: true
    isApproved?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EmployeeTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeTask to aggregate.
     */
    where?: EmployeeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTasks to fetch.
     */
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeTasks
    **/
    _count?: true | EmployeeTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeTaskMaxAggregateInputType
  }

  export type GetEmployeeTaskAggregateType<T extends EmployeeTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeTask[P]>
      : GetScalarType<T[P], AggregateEmployeeTask[P]>
  }




  export type EmployeeTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithAggregationInput | EmployeeTaskOrderByWithAggregationInput[]
    by: EmployeeTaskScalarFieldEnum[] | EmployeeTaskScalarFieldEnum
    having?: EmployeeTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeTaskCountAggregateInputType | true
    _avg?: EmployeeTaskAvgAggregateInputType
    _sum?: EmployeeTaskSumAggregateInputType
    _min?: EmployeeTaskMinAggregateInputType
    _max?: EmployeeTaskMaxAggregateInputType
  }

  export type EmployeeTaskGroupByOutputType = {
    id: string
    employeeId: string
    assignedById: string | null
    orderId: string | null
    outletId: string
    workStationId: string | null
    type: $Enums.Station
    status: $Enums.TaskStatus
    startAt: Date | null
    finishedAt: Date | null
    qty: number | null
    isApproved: boolean | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EmployeeTaskCountAggregateOutputType | null
    _avg: EmployeeTaskAvgAggregateOutputType | null
    _sum: EmployeeTaskSumAggregateOutputType | null
    _min: EmployeeTaskMinAggregateOutputType | null
    _max: EmployeeTaskMaxAggregateOutputType | null
  }

  type GetEmployeeTaskGroupByPayload<T extends EmployeeTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeTaskGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeTaskGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    assignedById?: boolean
    orderId?: boolean
    outletId?: boolean
    workStationId?: boolean
    type?: boolean
    status?: boolean
    startAt?: boolean
    finishedAt?: boolean
    qty?: boolean
    isApproved?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    assignee?: boolean | EmployeeTask$assigneeArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    order?: boolean | EmployeeTask$orderArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    station?: boolean | EmployeeTask$stationArgs<ExtArgs>
  }, ExtArgs["result"]["employeeTask"]>

  export type EmployeeTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    assignedById?: boolean
    orderId?: boolean
    outletId?: boolean
    workStationId?: boolean
    type?: boolean
    status?: boolean
    startAt?: boolean
    finishedAt?: boolean
    qty?: boolean
    isApproved?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    assignee?: boolean | EmployeeTask$assigneeArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    order?: boolean | EmployeeTask$orderArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    station?: boolean | EmployeeTask$stationArgs<ExtArgs>
  }, ExtArgs["result"]["employeeTask"]>

  export type EmployeeTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    assignedById?: boolean
    orderId?: boolean
    outletId?: boolean
    workStationId?: boolean
    type?: boolean
    status?: boolean
    startAt?: boolean
    finishedAt?: boolean
    qty?: boolean
    isApproved?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    assignee?: boolean | EmployeeTask$assigneeArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    order?: boolean | EmployeeTask$orderArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    station?: boolean | EmployeeTask$stationArgs<ExtArgs>
  }, ExtArgs["result"]["employeeTask"]>

  export type EmployeeTaskSelectScalar = {
    id?: boolean
    employeeId?: boolean
    assignedById?: boolean
    orderId?: boolean
    outletId?: boolean
    workStationId?: boolean
    type?: boolean
    status?: boolean
    startAt?: boolean
    finishedAt?: boolean
    qty?: boolean
    isApproved?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EmployeeTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "assignedById" | "orderId" | "outletId" | "workStationId" | "type" | "status" | "startAt" | "finishedAt" | "qty" | "isApproved" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["employeeTask"]>
  export type EmployeeTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignee?: boolean | EmployeeTask$assigneeArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    order?: boolean | EmployeeTask$orderArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    station?: boolean | EmployeeTask$stationArgs<ExtArgs>
  }
  export type EmployeeTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignee?: boolean | EmployeeTask$assigneeArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    order?: boolean | EmployeeTask$orderArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    station?: boolean | EmployeeTask$stationArgs<ExtArgs>
  }
  export type EmployeeTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignee?: boolean | EmployeeTask$assigneeArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    order?: boolean | EmployeeTask$orderArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    station?: boolean | EmployeeTask$stationArgs<ExtArgs>
  }

  export type $EmployeeTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeTask"
    objects: {
      assignee: Prisma.$EmployeePayload<ExtArgs> | null
      assignedBy: Prisma.$EmployeePayload<ExtArgs> | null
      order: Prisma.$OrderHeaderPayload<ExtArgs> | null
      outlet: Prisma.$OutletPayload<ExtArgs>
      station: Prisma.$WorkerStationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      assignedById: string | null
      orderId: string | null
      outletId: string
      workStationId: string | null
      type: $Enums.Station
      status: $Enums.TaskStatus
      startAt: Date | null
      finishedAt: Date | null
      qty: number | null
      isApproved: boolean | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["employeeTask"]>
    composites: {}
  }

  type EmployeeTaskGetPayload<S extends boolean | null | undefined | EmployeeTaskDefaultArgs> = $Result.GetResult<Prisma.$EmployeeTaskPayload, S>

  type EmployeeTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeTaskCountAggregateInputType | true
    }

  export interface EmployeeTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeTask'], meta: { name: 'EmployeeTask' } }
    /**
     * Find zero or one EmployeeTask that matches the filter.
     * @param {EmployeeTaskFindUniqueArgs} args - Arguments to find a EmployeeTask
     * @example
     * // Get one EmployeeTask
     * const employeeTask = await prisma.employeeTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeTaskFindUniqueArgs>(args: SelectSubset<T, EmployeeTaskFindUniqueArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeTaskFindUniqueOrThrowArgs} args - Arguments to find a EmployeeTask
     * @example
     * // Get one EmployeeTask
     * const employeeTask = await prisma.employeeTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskFindFirstArgs} args - Arguments to find a EmployeeTask
     * @example
     * // Get one EmployeeTask
     * const employeeTask = await prisma.employeeTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeTaskFindFirstArgs>(args?: SelectSubset<T, EmployeeTaskFindFirstArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskFindFirstOrThrowArgs} args - Arguments to find a EmployeeTask
     * @example
     * // Get one EmployeeTask
     * const employeeTask = await prisma.employeeTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeTasks
     * const employeeTasks = await prisma.employeeTask.findMany()
     * 
     * // Get first 10 EmployeeTasks
     * const employeeTasks = await prisma.employeeTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeTaskWithIdOnly = await prisma.employeeTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeTaskFindManyArgs>(args?: SelectSubset<T, EmployeeTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeTask.
     * @param {EmployeeTaskCreateArgs} args - Arguments to create a EmployeeTask.
     * @example
     * // Create one EmployeeTask
     * const EmployeeTask = await prisma.employeeTask.create({
     *   data: {
     *     // ... data to create a EmployeeTask
     *   }
     * })
     * 
     */
    create<T extends EmployeeTaskCreateArgs>(args: SelectSubset<T, EmployeeTaskCreateArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeTasks.
     * @param {EmployeeTaskCreateManyArgs} args - Arguments to create many EmployeeTasks.
     * @example
     * // Create many EmployeeTasks
     * const employeeTask = await prisma.employeeTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeTaskCreateManyArgs>(args?: SelectSubset<T, EmployeeTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeTasks and returns the data saved in the database.
     * @param {EmployeeTaskCreateManyAndReturnArgs} args - Arguments to create many EmployeeTasks.
     * @example
     * // Create many EmployeeTasks
     * const employeeTask = await prisma.employeeTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeTasks and only return the `id`
     * const employeeTaskWithIdOnly = await prisma.employeeTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeTask.
     * @param {EmployeeTaskDeleteArgs} args - Arguments to delete one EmployeeTask.
     * @example
     * // Delete one EmployeeTask
     * const EmployeeTask = await prisma.employeeTask.delete({
     *   where: {
     *     // ... filter to delete one EmployeeTask
     *   }
     * })
     * 
     */
    delete<T extends EmployeeTaskDeleteArgs>(args: SelectSubset<T, EmployeeTaskDeleteArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeTask.
     * @param {EmployeeTaskUpdateArgs} args - Arguments to update one EmployeeTask.
     * @example
     * // Update one EmployeeTask
     * const employeeTask = await prisma.employeeTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeTaskUpdateArgs>(args: SelectSubset<T, EmployeeTaskUpdateArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeTasks.
     * @param {EmployeeTaskDeleteManyArgs} args - Arguments to filter EmployeeTasks to delete.
     * @example
     * // Delete a few EmployeeTasks
     * const { count } = await prisma.employeeTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeTaskDeleteManyArgs>(args?: SelectSubset<T, EmployeeTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeTasks
     * const employeeTask = await prisma.employeeTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeTaskUpdateManyArgs>(args: SelectSubset<T, EmployeeTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeTasks and returns the data updated in the database.
     * @param {EmployeeTaskUpdateManyAndReturnArgs} args - Arguments to update many EmployeeTasks.
     * @example
     * // Update many EmployeeTasks
     * const employeeTask = await prisma.employeeTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeTasks and only return the `id`
     * const employeeTaskWithIdOnly = await prisma.employeeTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeTask.
     * @param {EmployeeTaskUpsertArgs} args - Arguments to update or create a EmployeeTask.
     * @example
     * // Update or create a EmployeeTask
     * const employeeTask = await prisma.employeeTask.upsert({
     *   create: {
     *     // ... data to create a EmployeeTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeTask we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeTaskUpsertArgs>(args: SelectSubset<T, EmployeeTaskUpsertArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskCountArgs} args - Arguments to filter EmployeeTasks to count.
     * @example
     * // Count the number of EmployeeTasks
     * const count = await prisma.employeeTask.count({
     *   where: {
     *     // ... the filter for the EmployeeTasks we want to count
     *   }
     * })
    **/
    count<T extends EmployeeTaskCountArgs>(
      args?: Subset<T, EmployeeTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeTaskAggregateArgs>(args: Subset<T, EmployeeTaskAggregateArgs>): Prisma.PrismaPromise<GetEmployeeTaskAggregateType<T>>

    /**
     * Group by EmployeeTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeTaskGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeTask model
   */
  readonly fields: EmployeeTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignee<T extends EmployeeTask$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTask$assigneeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedBy<T extends EmployeeTask$assignedByArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTask$assignedByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends EmployeeTask$orderArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTask$orderArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    station<T extends EmployeeTask$stationArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTask$stationArgs<ExtArgs>>): Prisma__WorkerStationClient<$Result.GetResult<Prisma.$WorkerStationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeTask model
   */
  interface EmployeeTaskFieldRefs {
    readonly id: FieldRef<"EmployeeTask", 'String'>
    readonly employeeId: FieldRef<"EmployeeTask", 'String'>
    readonly assignedById: FieldRef<"EmployeeTask", 'String'>
    readonly orderId: FieldRef<"EmployeeTask", 'String'>
    readonly outletId: FieldRef<"EmployeeTask", 'String'>
    readonly workStationId: FieldRef<"EmployeeTask", 'String'>
    readonly type: FieldRef<"EmployeeTask", 'Station'>
    readonly status: FieldRef<"EmployeeTask", 'TaskStatus'>
    readonly startAt: FieldRef<"EmployeeTask", 'DateTime'>
    readonly finishedAt: FieldRef<"EmployeeTask", 'DateTime'>
    readonly qty: FieldRef<"EmployeeTask", 'Float'>
    readonly isApproved: FieldRef<"EmployeeTask", 'Boolean'>
    readonly notes: FieldRef<"EmployeeTask", 'String'>
    readonly createdAt: FieldRef<"EmployeeTask", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeTask", 'DateTime'>
    readonly deletedAt: FieldRef<"EmployeeTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeTask findUnique
   */
  export type EmployeeTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTask to fetch.
     */
    where: EmployeeTaskWhereUniqueInput
  }

  /**
   * EmployeeTask findUniqueOrThrow
   */
  export type EmployeeTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTask to fetch.
     */
    where: EmployeeTaskWhereUniqueInput
  }

  /**
   * EmployeeTask findFirst
   */
  export type EmployeeTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTask to fetch.
     */
    where?: EmployeeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTasks to fetch.
     */
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeTasks.
     */
    cursor?: EmployeeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeTasks.
     */
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * EmployeeTask findFirstOrThrow
   */
  export type EmployeeTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTask to fetch.
     */
    where?: EmployeeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTasks to fetch.
     */
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeTasks.
     */
    cursor?: EmployeeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeTasks.
     */
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * EmployeeTask findMany
   */
  export type EmployeeTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTasks to fetch.
     */
    where?: EmployeeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTasks to fetch.
     */
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeTasks.
     */
    cursor?: EmployeeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTasks.
     */
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * EmployeeTask create
   */
  export type EmployeeTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeTask.
     */
    data: XOR<EmployeeTaskCreateInput, EmployeeTaskUncheckedCreateInput>
  }

  /**
   * EmployeeTask createMany
   */
  export type EmployeeTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeTasks.
     */
    data: EmployeeTaskCreateManyInput | EmployeeTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeTask createManyAndReturn
   */
  export type EmployeeTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeTasks.
     */
    data: EmployeeTaskCreateManyInput | EmployeeTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeTask update
   */
  export type EmployeeTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeTask.
     */
    data: XOR<EmployeeTaskUpdateInput, EmployeeTaskUncheckedUpdateInput>
    /**
     * Choose, which EmployeeTask to update.
     */
    where: EmployeeTaskWhereUniqueInput
  }

  /**
   * EmployeeTask updateMany
   */
  export type EmployeeTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeTasks.
     */
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeTasks to update
     */
    where?: EmployeeTaskWhereInput
    /**
     * Limit how many EmployeeTasks to update.
     */
    limit?: number
  }

  /**
   * EmployeeTask updateManyAndReturn
   */
  export type EmployeeTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeTasks.
     */
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeTasks to update
     */
    where?: EmployeeTaskWhereInput
    /**
     * Limit how many EmployeeTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeTask upsert
   */
  export type EmployeeTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeTask to update in case it exists.
     */
    where: EmployeeTaskWhereUniqueInput
    /**
     * In case the EmployeeTask found by the `where` argument doesn't exist, create a new EmployeeTask with this data.
     */
    create: XOR<EmployeeTaskCreateInput, EmployeeTaskUncheckedCreateInput>
    /**
     * In case the EmployeeTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeTaskUpdateInput, EmployeeTaskUncheckedUpdateInput>
  }

  /**
   * EmployeeTask delete
   */
  export type EmployeeTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter which EmployeeTask to delete.
     */
    where: EmployeeTaskWhereUniqueInput
  }

  /**
   * EmployeeTask deleteMany
   */
  export type EmployeeTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeTasks to delete
     */
    where?: EmployeeTaskWhereInput
    /**
     * Limit how many EmployeeTasks to delete.
     */
    limit?: number
  }

  /**
   * EmployeeTask.assignee
   */
  export type EmployeeTask$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * EmployeeTask.assignedBy
   */
  export type EmployeeTask$assignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * EmployeeTask.order
   */
  export type EmployeeTask$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    where?: OrderHeaderWhereInput
  }

  /**
   * EmployeeTask.station
   */
  export type EmployeeTask$stationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerStation
     */
    select?: WorkerStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerStation
     */
    omit?: WorkerStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerStationInclude<ExtArgs> | null
    where?: WorkerStationWhereInput
  }

  /**
   * EmployeeTask without action
   */
  export type EmployeeTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    role: 'role',
    name: 'name',
    email: 'email',
    password: 'password',
    phoneNumber: 'phoneNumber',
    isVerified: 'isVerified',
    resetPasswordToken: 'resetPasswordToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerAddressScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    label: 'label',
    address: 'address',
    city: 'city',
    postalCode: 'postalCode',
    latitude: 'latitude',
    longitude: 'longitude',
    notes: 'notes',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CustomerAddressScalarFieldEnum = (typeof CustomerAddressScalarFieldEnum)[keyof typeof CustomerAddressScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    serviceCategoryId: 'serviceCategoryId',
    unit: 'unit',
    basePrice: 'basePrice',
    minQty: 'minQty',
    estHours: 'estHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const OutletScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phoneNumber: 'phoneNumber',
    city: 'city',
    postalCode: 'postalCode',
    latitude: 'latitude',
    longitude: 'longitude',
    coverageArea: 'coverageArea',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OutletScalarFieldEnum = (typeof OutletScalarFieldEnum)[keyof typeof OutletScalarFieldEnum]


  export const OutletScheduleScalarFieldEnum: {
    id: 'id',
    outletId: 'outletId',
    detailDays: 'detailDays',
    openHour: 'openHour',
    closeHour: 'closeHour',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OutletScheduleScalarFieldEnum = (typeof OutletScheduleScalarFieldEnum)[keyof typeof OutletScheduleScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    outletId: 'outletId',
    shiftId: 'shiftId',
    role: 'role',
    name: 'name',
    email: 'email',
    password: 'password',
    phoneNumber: 'phoneNumber',
    address: 'address',
    isActive: 'isActive',
    resetPasswordToken: 'resetPasswordToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    shiftId: 'shiftId',
    outletId: 'outletId',
    date: 'date',
    status: 'status',
    clockInAt: 'clockInAt',
    clockOutAt: 'clockOutAt',
    workMinutes: 'workMinutes',
    lateMinutes: 'lateMinutes',
    earlyLeaveMin: 'earlyLeaveMin',
    notes: 'notes',
    approvedById: 'approvedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    outletId: 'outletId',
    type: 'type',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    approvedById: 'approvedById',
    approvedAt: 'approvedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const OrderHeaderScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    outletId: 'outletId',
    handledById: 'handledById',
    status: 'status',
    notes: 'notes',
    pickupAt: 'pickupAt',
    deliveryAt: 'deliveryAt',
    paymentMethod: 'paymentMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OrderHeaderScalarFieldEnum = (typeof OrderHeaderScalarFieldEnum)[keyof typeof OrderHeaderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    serviceId: 'serviceId',
    qty: 'qty',
    note: 'note',
    unitPrice: 'unitPrice',
    subTotal: 'subTotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const WorkerStationScalarFieldEnum: {
    id: 'id',
    station: 'station',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WorkerStationScalarFieldEnum = (typeof WorkerStationScalarFieldEnum)[keyof typeof WorkerStationScalarFieldEnum]


  export const EmployeeTaskScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    assignedById: 'assignedById',
    orderId: 'orderId',
    outletId: 'outletId',
    workStationId: 'workStationId',
    type: 'type',
    status: 'status',
    startAt: 'startAt',
    finishedAt: 'finishedAt',
    qty: 'qty',
    isApproved: 'isApproved',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EmployeeTaskScalarFieldEnum = (typeof EmployeeTaskScalarFieldEnum)[keyof typeof EmployeeTaskScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Label'
   */
  export type EnumLabelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Label'>
    


  /**
   * Reference to a field of type 'Label[]'
   */
  export type ListEnumLabelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Label[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'EmployeeRole'
   */
  export type EnumEmployeeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeRole'>
    


  /**
   * Reference to a field of type 'EmployeeRole[]'
   */
  export type ListEnumEmployeeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeRole[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'LeaveType'
   */
  export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


  /**
   * Reference to a field of type 'LeaveType[]'
   */
  export type ListEnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType[]'>
    


  /**
   * Reference to a field of type 'LeaveReqStat'
   */
  export type EnumLeaveReqStatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveReqStat'>
    


  /**
   * Reference to a field of type 'LeaveReqStat[]'
   */
  export type ListEnumLeaveReqStatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveReqStat[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Station'
   */
  export type EnumStationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Station'>
    


  /**
   * Reference to a field of type 'Station[]'
   */
  export type ListEnumStationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Station[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    role?: StringFilter<"Customer"> | string
    name?: StringNullableFilter<"Customer"> | string | null
    email?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    isVerified?: BoolFilter<"Customer"> | boolean
    resetPasswordToken?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    addresses?: CustomerAddressListRelationFilter
    orders?: OrderHeaderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    addresses?: CustomerAddressOrderByRelationAggregateInput
    orders?: OrderHeaderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    role?: StringFilter<"Customer"> | string
    name?: StringNullableFilter<"Customer"> | string | null
    password?: StringFilter<"Customer"> | string
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    isVerified?: BoolFilter<"Customer"> | boolean
    resetPasswordToken?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    addresses?: CustomerAddressListRelationFilter
    orders?: OrderHeaderListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    role?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringWithAggregatesFilter<"Customer"> | string
    password?: StringWithAggregatesFilter<"Customer"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Customer"> | boolean
    resetPasswordToken?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
  }

  export type CustomerAddressWhereInput = {
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    label?: EnumLabelFilter<"CustomerAddress"> | $Enums.Label
    address?: StringFilter<"CustomerAddress"> | string
    city?: StringFilter<"CustomerAddress"> | string
    postalCode?: StringFilter<"CustomerAddress"> | string
    latitude?: FloatFilter<"CustomerAddress"> | number
    longitude?: FloatFilter<"CustomerAddress"> | number
    notes?: StringNullableFilter<"CustomerAddress"> | string | null
    isPrimary?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CustomerAddress"> | Date | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerAddressOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    customerId?: StringFilter<"CustomerAddress"> | string
    label?: EnumLabelFilter<"CustomerAddress"> | $Enums.Label
    address?: StringFilter<"CustomerAddress"> | string
    city?: StringFilter<"CustomerAddress"> | string
    postalCode?: StringFilter<"CustomerAddress"> | string
    latitude?: FloatFilter<"CustomerAddress"> | number
    longitude?: FloatFilter<"CustomerAddress"> | number
    notes?: StringNullableFilter<"CustomerAddress"> | string | null
    isPrimary?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CustomerAddress"> | Date | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerAddressOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CustomerAddressCountOrderByAggregateInput
    _avg?: CustomerAddressAvgOrderByAggregateInput
    _max?: CustomerAddressMaxOrderByAggregateInput
    _min?: CustomerAddressMinOrderByAggregateInput
    _sum?: CustomerAddressSumOrderByAggregateInput
  }

  export type CustomerAddressScalarWhereWithAggregatesInput = {
    AND?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    OR?: CustomerAddressScalarWhereWithAggregatesInput[]
    NOT?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerAddress"> | string
    customerId?: StringWithAggregatesFilter<"CustomerAddress"> | string
    label?: EnumLabelWithAggregatesFilter<"CustomerAddress"> | $Enums.Label
    address?: StringWithAggregatesFilter<"CustomerAddress"> | string
    city?: StringWithAggregatesFilter<"CustomerAddress"> | string
    postalCode?: StringWithAggregatesFilter<"CustomerAddress"> | string
    latitude?: FloatWithAggregatesFilter<"CustomerAddress"> | number
    longitude?: FloatWithAggregatesFilter<"CustomerAddress"> | number
    notes?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"CustomerAddress"> | Date | string | null
  }

  export type ServiceCategoryWhereInput = {
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    id?: StringFilter<"ServiceCategory"> | string
    name?: StringFilter<"ServiceCategory"> | string
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ServiceCategory"> | Date | string | null
    services?: ServiceListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type ServiceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ServiceCategory"> | Date | string | null
    services?: ServiceListRelationFilter
  }, "id" | "name">

  export type ServiceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    OR?: ServiceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCategory"> | string
    name?: StringWithAggregatesFilter<"ServiceCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ServiceCategory"> | Date | string | null
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    serviceCategoryId?: StringFilter<"Service"> | string
    unit?: StringFilter<"Service"> | string
    basePrice?: IntFilter<"Service"> | number
    minQty?: FloatFilter<"Service"> | number
    estHours?: IntFilter<"Service"> | number
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    orderItems?: OrderItemListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceCategoryId?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    category?: ServiceCategoryOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    serviceCategoryId?: StringFilter<"Service"> | string
    unit?: StringFilter<"Service"> | string
    basePrice?: IntFilter<"Service"> | number
    minQty?: FloatFilter<"Service"> | number
    estHours?: IntFilter<"Service"> | number
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    orderItems?: OrderItemListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceCategoryId?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    serviceCategoryId?: StringWithAggregatesFilter<"Service"> | string
    unit?: StringWithAggregatesFilter<"Service"> | string
    basePrice?: IntWithAggregatesFilter<"Service"> | number
    minQty?: FloatWithAggregatesFilter<"Service"> | number
    estHours?: IntWithAggregatesFilter<"Service"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
  }

  export type OutletWhereInput = {
    AND?: OutletWhereInput | OutletWhereInput[]
    OR?: OutletWhereInput[]
    NOT?: OutletWhereInput | OutletWhereInput[]
    id?: StringFilter<"Outlet"> | string
    name?: StringFilter<"Outlet"> | string
    address?: StringFilter<"Outlet"> | string
    phoneNumber?: StringFilter<"Outlet"> | string
    city?: StringFilter<"Outlet"> | string
    postalCode?: StringFilter<"Outlet"> | string
    latitude?: FloatFilter<"Outlet"> | number
    longitude?: FloatFilter<"Outlet"> | number
    coverageArea?: StringNullableFilter<"Outlet"> | string | null
    isActive?: BoolFilter<"Outlet"> | boolean
    createdAt?: DateTimeFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeFilter<"Outlet"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Outlet"> | Date | string | null
    schedules?: OutletScheduleListRelationFilter
    employees?: EmployeeListRelationFilter
    orders?: OrderHeaderListRelationFilter
    attendances?: AttendanceListRelationFilter
    leaves?: LeaveRequestListRelationFilter
    tasks?: EmployeeTaskListRelationFilter
  }

  export type OutletOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    schedules?: OutletScheduleOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    orders?: OrderHeaderOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    leaves?: LeaveRequestOrderByRelationAggregateInput
    tasks?: EmployeeTaskOrderByRelationAggregateInput
  }

  export type OutletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutletWhereInput | OutletWhereInput[]
    OR?: OutletWhereInput[]
    NOT?: OutletWhereInput | OutletWhereInput[]
    name?: StringFilter<"Outlet"> | string
    address?: StringFilter<"Outlet"> | string
    phoneNumber?: StringFilter<"Outlet"> | string
    city?: StringFilter<"Outlet"> | string
    postalCode?: StringFilter<"Outlet"> | string
    latitude?: FloatFilter<"Outlet"> | number
    longitude?: FloatFilter<"Outlet"> | number
    coverageArea?: StringNullableFilter<"Outlet"> | string | null
    isActive?: BoolFilter<"Outlet"> | boolean
    createdAt?: DateTimeFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeFilter<"Outlet"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Outlet"> | Date | string | null
    schedules?: OutletScheduleListRelationFilter
    employees?: EmployeeListRelationFilter
    orders?: OrderHeaderListRelationFilter
    attendances?: AttendanceListRelationFilter
    leaves?: LeaveRequestListRelationFilter
    tasks?: EmployeeTaskListRelationFilter
  }, "id">

  export type OutletOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OutletCountOrderByAggregateInput
    _avg?: OutletAvgOrderByAggregateInput
    _max?: OutletMaxOrderByAggregateInput
    _min?: OutletMinOrderByAggregateInput
    _sum?: OutletSumOrderByAggregateInput
  }

  export type OutletScalarWhereWithAggregatesInput = {
    AND?: OutletScalarWhereWithAggregatesInput | OutletScalarWhereWithAggregatesInput[]
    OR?: OutletScalarWhereWithAggregatesInput[]
    NOT?: OutletScalarWhereWithAggregatesInput | OutletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Outlet"> | string
    name?: StringWithAggregatesFilter<"Outlet"> | string
    address?: StringWithAggregatesFilter<"Outlet"> | string
    phoneNumber?: StringWithAggregatesFilter<"Outlet"> | string
    city?: StringWithAggregatesFilter<"Outlet"> | string
    postalCode?: StringWithAggregatesFilter<"Outlet"> | string
    latitude?: FloatWithAggregatesFilter<"Outlet"> | number
    longitude?: FloatWithAggregatesFilter<"Outlet"> | number
    coverageArea?: StringNullableWithAggregatesFilter<"Outlet"> | string | null
    isActive?: BoolWithAggregatesFilter<"Outlet"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Outlet"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Outlet"> | Date | string | null
  }

  export type OutletScheduleWhereInput = {
    AND?: OutletScheduleWhereInput | OutletScheduleWhereInput[]
    OR?: OutletScheduleWhereInput[]
    NOT?: OutletScheduleWhereInput | OutletScheduleWhereInput[]
    id?: StringFilter<"OutletSchedule"> | string
    outletId?: StringFilter<"OutletSchedule"> | string
    detailDays?: StringFilter<"OutletSchedule"> | string
    openHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    closeHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    createdAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OutletSchedule"> | Date | string | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
  }

  export type OutletScheduleOrderByWithRelationInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    outlet?: OutletOrderByWithRelationInput
  }

  export type OutletScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutletScheduleWhereInput | OutletScheduleWhereInput[]
    OR?: OutletScheduleWhereInput[]
    NOT?: OutletScheduleWhereInput | OutletScheduleWhereInput[]
    outletId?: StringFilter<"OutletSchedule"> | string
    detailDays?: StringFilter<"OutletSchedule"> | string
    openHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    closeHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    createdAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OutletSchedule"> | Date | string | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
  }, "id">

  export type OutletScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OutletScheduleCountOrderByAggregateInput
    _max?: OutletScheduleMaxOrderByAggregateInput
    _min?: OutletScheduleMinOrderByAggregateInput
  }

  export type OutletScheduleScalarWhereWithAggregatesInput = {
    AND?: OutletScheduleScalarWhereWithAggregatesInput | OutletScheduleScalarWhereWithAggregatesInput[]
    OR?: OutletScheduleScalarWhereWithAggregatesInput[]
    NOT?: OutletScheduleScalarWhereWithAggregatesInput | OutletScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutletSchedule"> | string
    outletId?: StringWithAggregatesFilter<"OutletSchedule"> | string
    detailDays?: StringWithAggregatesFilter<"OutletSchedule"> | string
    openHour?: DateTimeWithAggregatesFilter<"OutletSchedule"> | Date | string
    closeHour?: DateTimeWithAggregatesFilter<"OutletSchedule"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OutletSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutletSchedule"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"OutletSchedule"> | Date | string | null
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    outletId?: StringFilter<"Employee"> | string
    shiftId?: StringFilter<"Employee"> | string
    role?: EnumEmployeeRoleFilter<"Employee"> | $Enums.EmployeeRole
    name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    password?: StringFilter<"Employee"> | string
    phoneNumber?: StringFilter<"Employee"> | string
    address?: StringFilter<"Employee"> | string
    isActive?: BoolFilter<"Employee"> | boolean
    resetPasswordToken?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
    attendances?: AttendanceListRelationFilter
    leaves?: LeaveRequestListRelationFilter
    leavesApproved?: LeaveRequestListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
    workerTasksAssigned?: EmployeeTaskListRelationFilter
    ordersHandled?: OrderHeaderListRelationFilter
    approvedBy?: AttendanceListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    outlet?: OutletOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
    attendances?: AttendanceOrderByRelationAggregateInput
    leaves?: LeaveRequestOrderByRelationAggregateInput
    leavesApproved?: LeaveRequestOrderByRelationAggregateInput
    workerTasks?: EmployeeTaskOrderByRelationAggregateInput
    workerTasksAssigned?: EmployeeTaskOrderByRelationAggregateInput
    ordersHandled?: OrderHeaderOrderByRelationAggregateInput
    approvedBy?: AttendanceOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    outletId?: StringFilter<"Employee"> | string
    shiftId?: StringFilter<"Employee"> | string
    role?: EnumEmployeeRoleFilter<"Employee"> | $Enums.EmployeeRole
    name?: StringFilter<"Employee"> | string
    password?: StringFilter<"Employee"> | string
    phoneNumber?: StringFilter<"Employee"> | string
    address?: StringFilter<"Employee"> | string
    isActive?: BoolFilter<"Employee"> | boolean
    resetPasswordToken?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
    attendances?: AttendanceListRelationFilter
    leaves?: LeaveRequestListRelationFilter
    leavesApproved?: LeaveRequestListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
    workerTasksAssigned?: EmployeeTaskListRelationFilter
    ordersHandled?: OrderHeaderListRelationFilter
    approvedBy?: AttendanceListRelationFilter
  }, "id" | "email">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    outletId?: StringWithAggregatesFilter<"Employee"> | string
    shiftId?: StringWithAggregatesFilter<"Employee"> | string
    role?: EnumEmployeeRoleWithAggregatesFilter<"Employee"> | $Enums.EmployeeRole
    name?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringWithAggregatesFilter<"Employee"> | string
    password?: StringWithAggregatesFilter<"Employee"> | string
    phoneNumber?: StringWithAggregatesFilter<"Employee"> | string
    address?: StringWithAggregatesFilter<"Employee"> | string
    isActive?: BoolWithAggregatesFilter<"Employee"> | boolean
    resetPasswordToken?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    name?: StringFilter<"Shift"> | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    employees?: EmployeeListRelationFilter
    attendances?: AttendanceListRelationFilter
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    employees?: EmployeeListRelationFilter
    attendances?: AttendanceListRelationFilter
  }, "id" | "name">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    name?: StringWithAggregatesFilter<"Shift"> | string
    startTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Shift"> | Date | string | null
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    employeeId?: StringFilter<"Attendance"> | string
    shiftId?: StringFilter<"Attendance"> | string
    outletId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    clockInAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    clockOutAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    workMinutes?: IntNullableFilter<"Attendance"> | number | null
    lateMinutes?: IntNullableFilter<"Attendance"> | number | null
    earlyLeaveMin?: IntNullableFilter<"Attendance"> | number | null
    notes?: StringNullableFilter<"Attendance"> | string | null
    approvedById?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    approvedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrderInput | SortOrder
    clockOutAt?: SortOrderInput | SortOrder
    workMinutes?: SortOrderInput | SortOrder
    lateMinutes?: SortOrderInput | SortOrder
    earlyLeaveMin?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
    outlet?: OutletOrderByWithRelationInput
    approvedBy?: EmployeeOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    employeeId?: StringFilter<"Attendance"> | string
    shiftId?: StringFilter<"Attendance"> | string
    outletId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    clockInAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    clockOutAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    workMinutes?: IntNullableFilter<"Attendance"> | number | null
    lateMinutes?: IntNullableFilter<"Attendance"> | number | null
    earlyLeaveMin?: IntNullableFilter<"Attendance"> | number | null
    notes?: StringNullableFilter<"Attendance"> | string | null
    approvedById?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    approvedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrderInput | SortOrder
    clockOutAt?: SortOrderInput | SortOrder
    workMinutes?: SortOrderInput | SortOrder
    lateMinutes?: SortOrderInput | SortOrder
    earlyLeaveMin?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    employeeId?: StringWithAggregatesFilter<"Attendance"> | string
    shiftId?: StringWithAggregatesFilter<"Attendance"> | string
    outletId?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    clockInAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    clockOutAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    workMinutes?: IntNullableWithAggregatesFilter<"Attendance"> | number | null
    lateMinutes?: IntNullableWithAggregatesFilter<"Attendance"> | number | null
    earlyLeaveMin?: IntNullableWithAggregatesFilter<"Attendance"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    outletId?: StringFilter<"LeaveRequest"> | string
    type?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    status?: EnumLeaveReqStatFilter<"LeaveRequest"> | $Enums.LeaveReqStat
    approvedById?: StringNullableFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    notes?: StringFilter<"LeaveRequest"> | string
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    deletedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    approvedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    outletId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    outlet?: OutletOrderByWithRelationInput
    approvedBy?: EmployeeOrderByWithRelationInput
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    employeeId?: StringFilter<"LeaveRequest"> | string
    outletId?: StringFilter<"LeaveRequest"> | string
    type?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    status?: EnumLeaveReqStatFilter<"LeaveRequest"> | $Enums.LeaveReqStat
    approvedById?: StringNullableFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    notes?: StringFilter<"LeaveRequest"> | string
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    deletedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    approvedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    outletId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveRequest"> | string
    employeeId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    outletId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    type?: EnumLeaveTypeWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    status?: EnumLeaveReqStatWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveReqStat
    approvedById?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"LeaveRequest"> | Date | string | null
    notes?: StringWithAggregatesFilter<"LeaveRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"LeaveRequest"> | Date | string | null
  }

  export type OrderHeaderWhereInput = {
    AND?: OrderHeaderWhereInput | OrderHeaderWhereInput[]
    OR?: OrderHeaderWhereInput[]
    NOT?: OrderHeaderWhereInput | OrderHeaderWhereInput[]
    id?: StringFilter<"OrderHeader"> | string
    customerId?: StringFilter<"OrderHeader"> | string
    outletId?: StringFilter<"OrderHeader"> | string
    handledById?: StringFilter<"OrderHeader"> | string
    status?: EnumOrderStatusFilter<"OrderHeader"> | $Enums.OrderStatus
    notes?: StringFilter<"OrderHeader"> | string
    pickupAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    deliveryAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    paymentMethod?: EnumPaymentMethodNullableFilter<"OrderHeader"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"OrderHeader"> | Date | string
    updatedAt?: DateTimeFilter<"OrderHeader"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    handledBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    items?: OrderItemListRelationFilter
    tasks?: EmployeeTaskListRelationFilter
  }

  export type OrderHeaderOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    outletId?: SortOrder
    handledById?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrderInput | SortOrder
    deliveryAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    outlet?: OutletOrderByWithRelationInput
    handledBy?: EmployeeOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    tasks?: EmployeeTaskOrderByRelationAggregateInput
  }

  export type OrderHeaderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderHeaderWhereInput | OrderHeaderWhereInput[]
    OR?: OrderHeaderWhereInput[]
    NOT?: OrderHeaderWhereInput | OrderHeaderWhereInput[]
    customerId?: StringFilter<"OrderHeader"> | string
    outletId?: StringFilter<"OrderHeader"> | string
    handledById?: StringFilter<"OrderHeader"> | string
    status?: EnumOrderStatusFilter<"OrderHeader"> | $Enums.OrderStatus
    notes?: StringFilter<"OrderHeader"> | string
    pickupAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    deliveryAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    paymentMethod?: EnumPaymentMethodNullableFilter<"OrderHeader"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"OrderHeader"> | Date | string
    updatedAt?: DateTimeFilter<"OrderHeader"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    handledBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    items?: OrderItemListRelationFilter
    tasks?: EmployeeTaskListRelationFilter
  }, "id">

  export type OrderHeaderOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    outletId?: SortOrder
    handledById?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrderInput | SortOrder
    deliveryAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OrderHeaderCountOrderByAggregateInput
    _max?: OrderHeaderMaxOrderByAggregateInput
    _min?: OrderHeaderMinOrderByAggregateInput
  }

  export type OrderHeaderScalarWhereWithAggregatesInput = {
    AND?: OrderHeaderScalarWhereWithAggregatesInput | OrderHeaderScalarWhereWithAggregatesInput[]
    OR?: OrderHeaderScalarWhereWithAggregatesInput[]
    NOT?: OrderHeaderScalarWhereWithAggregatesInput | OrderHeaderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderHeader"> | string
    customerId?: StringWithAggregatesFilter<"OrderHeader"> | string
    outletId?: StringWithAggregatesFilter<"OrderHeader"> | string
    handledById?: StringWithAggregatesFilter<"OrderHeader"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"OrderHeader"> | $Enums.OrderStatus
    notes?: StringWithAggregatesFilter<"OrderHeader"> | string
    pickupAt?: DateTimeNullableWithAggregatesFilter<"OrderHeader"> | Date | string | null
    deliveryAt?: DateTimeNullableWithAggregatesFilter<"OrderHeader"> | Date | string | null
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"OrderHeader"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderHeader"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderHeader"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"OrderHeader"> | Date | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    serviceId?: StringFilter<"OrderItem"> | string
    qty?: FloatFilter<"OrderItem"> | number
    note?: StringFilter<"OrderItem"> | string
    unitPrice?: IntFilter<"OrderItem"> | number
    subTotal?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    order?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    note?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    order?: OrderHeaderOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    serviceId?: StringFilter<"OrderItem"> | string
    qty?: FloatFilter<"OrderItem"> | number
    note?: StringFilter<"OrderItem"> | string
    unitPrice?: IntFilter<"OrderItem"> | number
    subTotal?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    order?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    note?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    serviceId?: StringWithAggregatesFilter<"OrderItem"> | string
    qty?: FloatWithAggregatesFilter<"OrderItem"> | number
    note?: StringWithAggregatesFilter<"OrderItem"> | string
    unitPrice?: IntWithAggregatesFilter<"OrderItem"> | number
    subTotal?: IntWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
  }

  export type WorkerStationWhereInput = {
    AND?: WorkerStationWhereInput | WorkerStationWhereInput[]
    OR?: WorkerStationWhereInput[]
    NOT?: WorkerStationWhereInput | WorkerStationWhereInput[]
    id?: StringFilter<"WorkerStation"> | string
    station?: EnumStationFilter<"WorkerStation"> | $Enums.Station
    createdAt?: DateTimeFilter<"WorkerStation"> | Date | string
    updatedAt?: DateTimeFilter<"WorkerStation"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkerStation"> | Date | string | null
    tasks?: EmployeeTaskListRelationFilter
  }

  export type WorkerStationOrderByWithRelationInput = {
    id?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tasks?: EmployeeTaskOrderByRelationAggregateInput
  }

  export type WorkerStationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkerStationWhereInput | WorkerStationWhereInput[]
    OR?: WorkerStationWhereInput[]
    NOT?: WorkerStationWhereInput | WorkerStationWhereInput[]
    station?: EnumStationFilter<"WorkerStation"> | $Enums.Station
    createdAt?: DateTimeFilter<"WorkerStation"> | Date | string
    updatedAt?: DateTimeFilter<"WorkerStation"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkerStation"> | Date | string | null
    tasks?: EmployeeTaskListRelationFilter
  }, "id">

  export type WorkerStationOrderByWithAggregationInput = {
    id?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WorkerStationCountOrderByAggregateInput
    _max?: WorkerStationMaxOrderByAggregateInput
    _min?: WorkerStationMinOrderByAggregateInput
  }

  export type WorkerStationScalarWhereWithAggregatesInput = {
    AND?: WorkerStationScalarWhereWithAggregatesInput | WorkerStationScalarWhereWithAggregatesInput[]
    OR?: WorkerStationScalarWhereWithAggregatesInput[]
    NOT?: WorkerStationScalarWhereWithAggregatesInput | WorkerStationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkerStation"> | string
    station?: EnumStationWithAggregatesFilter<"WorkerStation"> | $Enums.Station
    createdAt?: DateTimeWithAggregatesFilter<"WorkerStation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkerStation"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"WorkerStation"> | Date | string | null
  }

  export type EmployeeTaskWhereInput = {
    AND?: EmployeeTaskWhereInput | EmployeeTaskWhereInput[]
    OR?: EmployeeTaskWhereInput[]
    NOT?: EmployeeTaskWhereInput | EmployeeTaskWhereInput[]
    id?: StringFilter<"EmployeeTask"> | string
    employeeId?: StringFilter<"EmployeeTask"> | string
    assignedById?: StringNullableFilter<"EmployeeTask"> | string | null
    orderId?: StringNullableFilter<"EmployeeTask"> | string | null
    outletId?: StringFilter<"EmployeeTask"> | string
    workStationId?: StringNullableFilter<"EmployeeTask"> | string | null
    type?: EnumStationFilter<"EmployeeTask"> | $Enums.Station
    status?: EnumTaskStatusFilter<"EmployeeTask"> | $Enums.TaskStatus
    startAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    qty?: FloatNullableFilter<"EmployeeTask"> | number | null
    isApproved?: BoolNullableFilter<"EmployeeTask"> | boolean | null
    notes?: StringNullableFilter<"EmployeeTask"> | string | null
    createdAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    assignee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    assignedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    order?: XOR<OrderHeaderNullableScalarRelationFilter, OrderHeaderWhereInput> | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    station?: XOR<WorkerStationNullableScalarRelationFilter, WorkerStationWhereInput> | null
  }

  export type EmployeeTaskOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    outletId?: SortOrder
    workStationId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    startAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    isApproved?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    assignee?: EmployeeOrderByWithRelationInput
    assignedBy?: EmployeeOrderByWithRelationInput
    order?: OrderHeaderOrderByWithRelationInput
    outlet?: OutletOrderByWithRelationInput
    station?: WorkerStationOrderByWithRelationInput
  }

  export type EmployeeTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeTaskWhereInput | EmployeeTaskWhereInput[]
    OR?: EmployeeTaskWhereInput[]
    NOT?: EmployeeTaskWhereInput | EmployeeTaskWhereInput[]
    employeeId?: StringFilter<"EmployeeTask"> | string
    assignedById?: StringNullableFilter<"EmployeeTask"> | string | null
    orderId?: StringNullableFilter<"EmployeeTask"> | string | null
    outletId?: StringFilter<"EmployeeTask"> | string
    workStationId?: StringNullableFilter<"EmployeeTask"> | string | null
    type?: EnumStationFilter<"EmployeeTask"> | $Enums.Station
    status?: EnumTaskStatusFilter<"EmployeeTask"> | $Enums.TaskStatus
    startAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    qty?: FloatNullableFilter<"EmployeeTask"> | number | null
    isApproved?: BoolNullableFilter<"EmployeeTask"> | boolean | null
    notes?: StringNullableFilter<"EmployeeTask"> | string | null
    createdAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    assignee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    assignedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    order?: XOR<OrderHeaderNullableScalarRelationFilter, OrderHeaderWhereInput> | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    station?: XOR<WorkerStationNullableScalarRelationFilter, WorkerStationWhereInput> | null
  }, "id">

  export type EmployeeTaskOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    outletId?: SortOrder
    workStationId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    startAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    isApproved?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EmployeeTaskCountOrderByAggregateInput
    _avg?: EmployeeTaskAvgOrderByAggregateInput
    _max?: EmployeeTaskMaxOrderByAggregateInput
    _min?: EmployeeTaskMinOrderByAggregateInput
    _sum?: EmployeeTaskSumOrderByAggregateInput
  }

  export type EmployeeTaskScalarWhereWithAggregatesInput = {
    AND?: EmployeeTaskScalarWhereWithAggregatesInput | EmployeeTaskScalarWhereWithAggregatesInput[]
    OR?: EmployeeTaskScalarWhereWithAggregatesInput[]
    NOT?: EmployeeTaskScalarWhereWithAggregatesInput | EmployeeTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeTask"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeTask"> | string
    assignedById?: StringNullableWithAggregatesFilter<"EmployeeTask"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"EmployeeTask"> | string | null
    outletId?: StringWithAggregatesFilter<"EmployeeTask"> | string
    workStationId?: StringNullableWithAggregatesFilter<"EmployeeTask"> | string | null
    type?: EnumStationWithAggregatesFilter<"EmployeeTask"> | $Enums.Station
    status?: EnumTaskStatusWithAggregatesFilter<"EmployeeTask"> | $Enums.TaskStatus
    startAt?: DateTimeNullableWithAggregatesFilter<"EmployeeTask"> | Date | string | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeTask"> | Date | string | null
    qty?: FloatNullableWithAggregatesFilter<"EmployeeTask"> | number | null
    isApproved?: BoolNullableWithAggregatesFilter<"EmployeeTask"> | boolean | null
    notes?: StringNullableWithAggregatesFilter<"EmployeeTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeTask"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeTask"> | Date | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    role?: string
    name?: string | null
    email: string
    password: string
    phoneNumber?: string | null
    isVerified?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    orders?: OrderHeaderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    role?: string
    name?: string | null
    email: string
    password: string
    phoneNumber?: string | null
    isVerified?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderHeaderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    orders?: OrderHeaderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderHeaderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    role?: string
    name?: string | null
    email: string
    password: string
    phoneNumber?: string | null
    isVerified?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerAddressCreateInput = {
    id?: string
    label?: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutAddressesInput
  }

  export type CustomerAddressUncheckedCreateInput = {
    id?: string
    customerId: string
    label?: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type CustomerAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerAddressCreateManyInput = {
    id?: string
    customerId: string
    label?: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    services?: ServiceCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    orderItems?: OrderItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    serviceCategoryId: string
    unit: string
    basePrice: number
    minQty: number
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: FloatFieldUpdateOperationsInput | number
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    orderItems?: OrderItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: FloatFieldUpdateOperationsInput | number
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    serviceCategoryId: string
    unit: string
    basePrice: number
    minQty: number
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: FloatFieldUpdateOperationsInput | number
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: FloatFieldUpdateOperationsInput | number
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletCreateInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleCreateNestedManyWithoutOutletInput
    employees?: EmployeeCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderCreateNestedManyWithoutOutletInput
    attendances?: AttendanceCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderUncheckedCreateNestedManyWithoutOutletInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUncheckedUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type OutletCreateManyInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleCreateInput = {
    id?: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutSchedulesInput
  }

  export type OutletScheduleUncheckedCreateInput = {
    id?: string
    outletId: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type OutletScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleCreateManyInput = {
    id?: string
    outletId: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutEmployeesInput
    shift: ShiftCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutEmployeesNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShiftCreateInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeCreateNestedManyWithoutShiftInput
    attendances?: AttendanceCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutShiftInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateManyWithoutShiftNestedInput
    attendances?: AttendanceUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutShiftNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftCreateManyInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutAttendancesInput
    shift: ShiftCreateNestedOneWithoutAttendancesInput
    outlet: OutletCreateNestedOneWithoutAttendancesInput
    approvedBy?: EmployeeCreateNestedOneWithoutApprovedByInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAttendancesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutAttendancesNestedInput
    outlet?: OutletUpdateOneRequiredWithoutAttendancesNestedInput
    approvedBy?: EmployeeUpdateOneWithoutApprovedByNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateManyInput = {
    id?: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestCreateInput = {
    id?: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutLeavesInput
    outlet: OutletCreateNestedOneWithoutLeavesInput
    approvedBy?: EmployeeCreateNestedOneWithoutLeavesApprovedInput
  }

  export type LeaveRequestUncheckedCreateInput = {
    id?: string
    employeeId: string
    outletId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedById?: string | null
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
    outlet?: OutletUpdateOneRequiredWithoutLeavesNestedInput
    approvedBy?: EmployeeUpdateOneWithoutLeavesApprovedNestedInput
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestCreateManyInput = {
    id?: string
    employeeId: string
    outletId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedById?: string | null
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderCreateInput = {
    id?: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    outlet: OutletCreateNestedOneWithoutOrdersInput
    handledBy?: EmployeeCreateNestedOneWithoutOrdersHandledInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderUncheckedCreateInput = {
    id?: string
    customerId: string
    outletId: string
    handledById: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    outlet?: OutletUpdateOneRequiredWithoutOrdersNestedInput
    handledBy?: EmployeeUpdateOneWithoutOrdersHandledNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    handledById?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderCreateManyInput = {
    id?: string
    customerId: string
    outletId: string
    handledById: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderHeaderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    handledById?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    order: OrderHeaderCreateNestedOneWithoutItemsInput
    service: ServiceCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    serviceId: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderHeaderUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    serviceId: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerStationCreateInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tasks?: EmployeeTaskCreateNestedManyWithoutStationInput
  }

  export type WorkerStationUncheckedCreateInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutStationInput
  }

  export type WorkerStationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: EmployeeTaskUpdateManyWithoutStationNestedInput
  }

  export type WorkerStationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutStationNestedInput
  }

  export type WorkerStationCreateManyInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkerStationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerStationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskCreateInput = {
    id?: string
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignee?: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutWorkerTasksAssignedInput
    order?: OrderHeaderCreateNestedOneWithoutTasksInput
    outlet: OutletCreateNestedOneWithoutTasksInput
    station?: WorkerStationCreateNestedOneWithoutTasksInput
  }

  export type EmployeeTaskUncheckedCreateInput = {
    id?: string
    employeeId: string
    assignedById?: string | null
    orderId?: string | null
    outletId: string
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignee?: EmployeeUpdateOneWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutWorkerTasksAssignedNestedInput
    order?: OrderHeaderUpdateOneWithoutTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutTasksNestedInput
    station?: WorkerStationUpdateOneWithoutTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskCreateManyInput = {
    id?: string
    employeeId: string
    assignedById?: string | null
    orderId?: string | null
    outletId: string
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CustomerAddressListRelationFilter = {
    every?: CustomerAddressWhereInput
    some?: CustomerAddressWhereInput
    none?: CustomerAddressWhereInput
  }

  export type OrderHeaderListRelationFilter = {
    every?: OrderHeaderWhereInput
    some?: OrderHeaderWhereInput
    none?: OrderHeaderWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CustomerAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderHeaderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isVerified?: SortOrder
    resetPasswordToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isVerified?: SortOrder
    resetPasswordToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isVerified?: SortOrder
    resetPasswordToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumLabelFilter<$PrismaModel = never> = {
    equals?: $Enums.Label | EnumLabelFieldRefInput<$PrismaModel>
    in?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelFilter<$PrismaModel> | $Enums.Label
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerAddressCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerAddressAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type CustomerAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerAddressMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerAddressSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumLabelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Label | EnumLabelFieldRefInput<$PrismaModel>
    in?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelWithAggregatesFilter<$PrismaModel> | $Enums.Label
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabelFilter<$PrismaModel>
    _max?: NestedEnumLabelFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ServiceCategoryScalarRelationFilter = {
    is?: ServiceCategoryWhereInput
    isNot?: ServiceCategoryWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceCategoryId?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    minQty?: SortOrder
    estHours?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceCategoryId?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceCategoryId?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    basePrice?: SortOrder
    minQty?: SortOrder
    estHours?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type OutletScheduleListRelationFilter = {
    every?: OutletScheduleWhereInput
    some?: OutletScheduleWhereInput
    none?: OutletScheduleWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type LeaveRequestListRelationFilter = {
    every?: LeaveRequestWhereInput
    some?: LeaveRequestWhereInput
    none?: LeaveRequestWhereInput
  }

  export type EmployeeTaskListRelationFilter = {
    every?: EmployeeTaskWhereInput
    some?: EmployeeTaskWhereInput
    none?: EmployeeTaskWhereInput
  }

  export type OutletScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutletCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type OutletMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type OutletScalarRelationFilter = {
    is?: OutletWhereInput
    isNot?: OutletWhereInput
  }

  export type OutletScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumEmployeeRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeRole | EnumEmployeeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeRoleFilter<$PrismaModel> | $Enums.EmployeeRole
  }

  export type ShiftScalarRelationFilter = {
    is?: ShiftWhereInput
    isNot?: ShiftWhereInput
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumEmployeeRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeRole | EnumEmployeeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeRoleWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeRoleFilter<$PrismaModel>
    _max?: NestedEnumEmployeeRoleFilter<$PrismaModel>
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrder
    clockOutAt?: SortOrder
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
    notes?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrder
    clockOutAt?: SortOrder
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
    notes?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrder
    clockOutAt?: SortOrder
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
    notes?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type EnumLeaveReqStatFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveReqStat | EnumLeaveReqStatFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveReqStat[] | ListEnumLeaveReqStatFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveReqStat[] | ListEnumLeaveReqStatFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveReqStatFilter<$PrismaModel> | $Enums.LeaveReqStat
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    outletId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    outletId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    outletId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type EnumLeaveReqStatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveReqStat | EnumLeaveReqStatFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveReqStat[] | ListEnumLeaveReqStatFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveReqStat[] | ListEnumLeaveReqStatFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveReqStatWithAggregatesFilter<$PrismaModel> | $Enums.LeaveReqStat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveReqStatFilter<$PrismaModel>
    _max?: NestedEnumLeaveReqStatFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type OrderHeaderCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    outletId?: SortOrder
    handledById?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrder
    deliveryAt?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderHeaderMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    outletId?: SortOrder
    handledById?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrder
    deliveryAt?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderHeaderMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    outletId?: SortOrder
    handledById?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrder
    deliveryAt?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type OrderHeaderScalarRelationFilter = {
    is?: OrderHeaderWhereInput
    isNot?: OrderHeaderWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    note?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    note?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    note?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
  }

  export type EnumStationFilter<$PrismaModel = never> = {
    equals?: $Enums.Station | EnumStationFieldRefInput<$PrismaModel>
    in?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    not?: NestedEnumStationFilter<$PrismaModel> | $Enums.Station
  }

  export type WorkerStationCountOrderByAggregateInput = {
    id?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkerStationMaxOrderByAggregateInput = {
    id?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkerStationMinOrderByAggregateInput = {
    id?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumStationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Station | EnumStationFieldRefInput<$PrismaModel>
    in?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    not?: NestedEnumStationWithAggregatesFilter<$PrismaModel> | $Enums.Station
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStationFilter<$PrismaModel>
    _max?: NestedEnumStationFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type OrderHeaderNullableScalarRelationFilter = {
    is?: OrderHeaderWhereInput | null
    isNot?: OrderHeaderWhereInput | null
  }

  export type WorkerStationNullableScalarRelationFilter = {
    is?: WorkerStationWhereInput | null
    isNot?: WorkerStationWhereInput | null
  }

  export type EmployeeTaskCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedById?: SortOrder
    orderId?: SortOrder
    outletId?: SortOrder
    workStationId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startAt?: SortOrder
    finishedAt?: SortOrder
    qty?: SortOrder
    isApproved?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeTaskAvgOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type EmployeeTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedById?: SortOrder
    orderId?: SortOrder
    outletId?: SortOrder
    workStationId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startAt?: SortOrder
    finishedAt?: SortOrder
    qty?: SortOrder
    isApproved?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeTaskMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedById?: SortOrder
    orderId?: SortOrder
    outletId?: SortOrder
    workStationId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startAt?: SortOrder
    finishedAt?: SortOrder
    qty?: SortOrder
    isApproved?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeTaskSumOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type CustomerAddressCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type OrderHeaderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderHeaderCreateWithoutCustomerInput, OrderHeaderUncheckedCreateWithoutCustomerInput> | OrderHeaderCreateWithoutCustomerInput[] | OrderHeaderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutCustomerInput | OrderHeaderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderHeaderCreateManyCustomerInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type OrderHeaderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderHeaderCreateWithoutCustomerInput, OrderHeaderUncheckedCreateWithoutCustomerInput> | OrderHeaderCreateWithoutCustomerInput[] | OrderHeaderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutCustomerInput | OrderHeaderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderHeaderCreateManyCustomerInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerAddressUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type OrderHeaderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutCustomerInput, OrderHeaderUncheckedCreateWithoutCustomerInput> | OrderHeaderCreateWithoutCustomerInput[] | OrderHeaderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutCustomerInput | OrderHeaderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutCustomerInput | OrderHeaderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderHeaderCreateManyCustomerInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutCustomerInput | OrderHeaderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutCustomerInput | OrderHeaderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type OrderHeaderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutCustomerInput, OrderHeaderUncheckedCreateWithoutCustomerInput> | OrderHeaderCreateWithoutCustomerInput[] | OrderHeaderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutCustomerInput | OrderHeaderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutCustomerInput | OrderHeaderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderHeaderCreateManyCustomerInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutCustomerInput | OrderHeaderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutCustomerInput | OrderHeaderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumLabelFieldUpdateOperationsInput = {
    set?: $Enums.Label
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    upsert?: CustomerUpsertWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAddressesInput, CustomerUpdateWithoutAddressesInput>, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type ServiceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCategoryCreateNestedOneWithoutServicesInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    upsert?: ServiceCategoryUpsertWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutServicesInput, ServiceCategoryUpdateWithoutServicesInput>, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type OrderItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutServiceInput | OrderItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutServiceInput | OrderItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutServiceInput | OrderItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutServiceInput | OrderItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutServiceInput | OrderItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutServiceInput | OrderItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OutletScheduleCreateNestedManyWithoutOutletInput = {
    create?: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput> | OutletScheduleCreateWithoutOutletInput[] | OutletScheduleUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OutletScheduleCreateOrConnectWithoutOutletInput | OutletScheduleCreateOrConnectWithoutOutletInput[]
    createMany?: OutletScheduleCreateManyOutletInputEnvelope
    connect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutOutletInput = {
    create?: XOR<EmployeeCreateWithoutOutletInput, EmployeeUncheckedCreateWithoutOutletInput> | EmployeeCreateWithoutOutletInput[] | EmployeeUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutOutletInput | EmployeeCreateOrConnectWithoutOutletInput[]
    createMany?: EmployeeCreateManyOutletInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type OrderHeaderCreateNestedManyWithoutOutletInput = {
    create?: XOR<OrderHeaderCreateWithoutOutletInput, OrderHeaderUncheckedCreateWithoutOutletInput> | OrderHeaderCreateWithoutOutletInput[] | OrderHeaderUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOutletInput | OrderHeaderCreateOrConnectWithoutOutletInput[]
    createMany?: OrderHeaderCreateManyOutletInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutOutletInput = {
    create?: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput> | AttendanceCreateWithoutOutletInput[] | AttendanceUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOutletInput | AttendanceCreateOrConnectWithoutOutletInput[]
    createMany?: AttendanceCreateManyOutletInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutOutletInput = {
    create?: XOR<LeaveRequestCreateWithoutOutletInput, LeaveRequestUncheckedCreateWithoutOutletInput> | LeaveRequestCreateWithoutOutletInput[] | LeaveRequestUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutOutletInput | LeaveRequestCreateOrConnectWithoutOutletInput[]
    createMany?: LeaveRequestCreateManyOutletInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type EmployeeTaskCreateNestedManyWithoutOutletInput = {
    create?: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput> | EmployeeTaskCreateWithoutOutletInput[] | EmployeeTaskUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOutletInput | EmployeeTaskCreateOrConnectWithoutOutletInput[]
    createMany?: EmployeeTaskCreateManyOutletInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type OutletScheduleUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput> | OutletScheduleCreateWithoutOutletInput[] | OutletScheduleUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OutletScheduleCreateOrConnectWithoutOutletInput | OutletScheduleCreateOrConnectWithoutOutletInput[]
    createMany?: OutletScheduleCreateManyOutletInputEnvelope
    connect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<EmployeeCreateWithoutOutletInput, EmployeeUncheckedCreateWithoutOutletInput> | EmployeeCreateWithoutOutletInput[] | EmployeeUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutOutletInput | EmployeeCreateOrConnectWithoutOutletInput[]
    createMany?: EmployeeCreateManyOutletInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type OrderHeaderUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<OrderHeaderCreateWithoutOutletInput, OrderHeaderUncheckedCreateWithoutOutletInput> | OrderHeaderCreateWithoutOutletInput[] | OrderHeaderUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOutletInput | OrderHeaderCreateOrConnectWithoutOutletInput[]
    createMany?: OrderHeaderCreateManyOutletInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput> | AttendanceCreateWithoutOutletInput[] | AttendanceUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOutletInput | AttendanceCreateOrConnectWithoutOutletInput[]
    createMany?: AttendanceCreateManyOutletInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<LeaveRequestCreateWithoutOutletInput, LeaveRequestUncheckedCreateWithoutOutletInput> | LeaveRequestCreateWithoutOutletInput[] | LeaveRequestUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutOutletInput | LeaveRequestCreateOrConnectWithoutOutletInput[]
    createMany?: LeaveRequestCreateManyOutletInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput> | EmployeeTaskCreateWithoutOutletInput[] | EmployeeTaskUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOutletInput | EmployeeTaskCreateOrConnectWithoutOutletInput[]
    createMany?: EmployeeTaskCreateManyOutletInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type OutletScheduleUpdateManyWithoutOutletNestedInput = {
    create?: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput> | OutletScheduleCreateWithoutOutletInput[] | OutletScheduleUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OutletScheduleCreateOrConnectWithoutOutletInput | OutletScheduleCreateOrConnectWithoutOutletInput[]
    upsert?: OutletScheduleUpsertWithWhereUniqueWithoutOutletInput | OutletScheduleUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: OutletScheduleCreateManyOutletInputEnvelope
    set?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    disconnect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    delete?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    connect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    update?: OutletScheduleUpdateWithWhereUniqueWithoutOutletInput | OutletScheduleUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: OutletScheduleUpdateManyWithWhereWithoutOutletInput | OutletScheduleUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: OutletScheduleScalarWhereInput | OutletScheduleScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutOutletNestedInput = {
    create?: XOR<EmployeeCreateWithoutOutletInput, EmployeeUncheckedCreateWithoutOutletInput> | EmployeeCreateWithoutOutletInput[] | EmployeeUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutOutletInput | EmployeeCreateOrConnectWithoutOutletInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutOutletInput | EmployeeUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: EmployeeCreateManyOutletInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutOutletInput | EmployeeUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutOutletInput | EmployeeUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type OrderHeaderUpdateManyWithoutOutletNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutOutletInput, OrderHeaderUncheckedCreateWithoutOutletInput> | OrderHeaderCreateWithoutOutletInput[] | OrderHeaderUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOutletInput | OrderHeaderCreateOrConnectWithoutOutletInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutOutletInput | OrderHeaderUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: OrderHeaderCreateManyOutletInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutOutletInput | OrderHeaderUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutOutletInput | OrderHeaderUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutOutletNestedInput = {
    create?: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput> | AttendanceCreateWithoutOutletInput[] | AttendanceUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOutletInput | AttendanceCreateOrConnectWithoutOutletInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutOutletInput | AttendanceUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: AttendanceCreateManyOutletInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutOutletInput | AttendanceUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutOutletInput | AttendanceUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutOutletNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutOutletInput, LeaveRequestUncheckedCreateWithoutOutletInput> | LeaveRequestCreateWithoutOutletInput[] | LeaveRequestUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutOutletInput | LeaveRequestCreateOrConnectWithoutOutletInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutOutletInput | LeaveRequestUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: LeaveRequestCreateManyOutletInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutOutletInput | LeaveRequestUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutOutletInput | LeaveRequestUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type EmployeeTaskUpdateManyWithoutOutletNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput> | EmployeeTaskCreateWithoutOutletInput[] | EmployeeTaskUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOutletInput | EmployeeTaskCreateOrConnectWithoutOutletInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput | EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: EmployeeTaskCreateManyOutletInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput | EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOutletInput | EmployeeTaskUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput> | OutletScheduleCreateWithoutOutletInput[] | OutletScheduleUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OutletScheduleCreateOrConnectWithoutOutletInput | OutletScheduleCreateOrConnectWithoutOutletInput[]
    upsert?: OutletScheduleUpsertWithWhereUniqueWithoutOutletInput | OutletScheduleUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: OutletScheduleCreateManyOutletInputEnvelope
    set?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    disconnect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    delete?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    connect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    update?: OutletScheduleUpdateWithWhereUniqueWithoutOutletInput | OutletScheduleUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: OutletScheduleUpdateManyWithWhereWithoutOutletInput | OutletScheduleUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: OutletScheduleScalarWhereInput | OutletScheduleScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<EmployeeCreateWithoutOutletInput, EmployeeUncheckedCreateWithoutOutletInput> | EmployeeCreateWithoutOutletInput[] | EmployeeUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutOutletInput | EmployeeCreateOrConnectWithoutOutletInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutOutletInput | EmployeeUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: EmployeeCreateManyOutletInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutOutletInput | EmployeeUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutOutletInput | EmployeeUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type OrderHeaderUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutOutletInput, OrderHeaderUncheckedCreateWithoutOutletInput> | OrderHeaderCreateWithoutOutletInput[] | OrderHeaderUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOutletInput | OrderHeaderCreateOrConnectWithoutOutletInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutOutletInput | OrderHeaderUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: OrderHeaderCreateManyOutletInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutOutletInput | OrderHeaderUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutOutletInput | OrderHeaderUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput> | AttendanceCreateWithoutOutletInput[] | AttendanceUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOutletInput | AttendanceCreateOrConnectWithoutOutletInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutOutletInput | AttendanceUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: AttendanceCreateManyOutletInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutOutletInput | AttendanceUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutOutletInput | AttendanceUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutOutletInput, LeaveRequestUncheckedCreateWithoutOutletInput> | LeaveRequestCreateWithoutOutletInput[] | LeaveRequestUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutOutletInput | LeaveRequestCreateOrConnectWithoutOutletInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutOutletInput | LeaveRequestUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: LeaveRequestCreateManyOutletInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutOutletInput | LeaveRequestUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutOutletInput | LeaveRequestUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput> | EmployeeTaskCreateWithoutOutletInput[] | EmployeeTaskUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOutletInput | EmployeeTaskCreateOrConnectWithoutOutletInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput | EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: EmployeeTaskCreateManyOutletInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput | EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOutletInput | EmployeeTaskUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type OutletCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<OutletCreateWithoutSchedulesInput, OutletUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: OutletCreateOrConnectWithoutSchedulesInput
    connect?: OutletWhereUniqueInput
  }

  export type OutletUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<OutletCreateWithoutSchedulesInput, OutletUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: OutletCreateOrConnectWithoutSchedulesInput
    upsert?: OutletUpsertWithoutSchedulesInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutSchedulesInput, OutletUpdateWithoutSchedulesInput>, OutletUncheckedUpdateWithoutSchedulesInput>
  }

  export type OutletCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<OutletCreateWithoutEmployeesInput, OutletUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: OutletCreateOrConnectWithoutEmployeesInput
    connect?: OutletWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeesInput
    connect?: ShiftWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput> | LeaveRequestCreateWithoutApprovedByInput[] | LeaveRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApprovedByInput | LeaveRequestCreateOrConnectWithoutApprovedByInput[]
    createMany?: LeaveRequestCreateManyApprovedByInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type EmployeeTaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssigneeInput, EmployeeTaskUncheckedCreateWithoutAssigneeInput> | EmployeeTaskCreateWithoutAssigneeInput[] | EmployeeTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssigneeInput | EmployeeTaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: EmployeeTaskCreateManyAssigneeInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EmployeeTaskCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput> | EmployeeTaskCreateWithoutAssignedByInput[] | EmployeeTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssignedByInput | EmployeeTaskCreateOrConnectWithoutAssignedByInput[]
    createMany?: EmployeeTaskCreateManyAssignedByInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type OrderHeaderCreateNestedManyWithoutHandledByInput = {
    create?: XOR<OrderHeaderCreateWithoutHandledByInput, OrderHeaderUncheckedCreateWithoutHandledByInput> | OrderHeaderCreateWithoutHandledByInput[] | OrderHeaderUncheckedCreateWithoutHandledByInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutHandledByInput | OrderHeaderCreateOrConnectWithoutHandledByInput[]
    createMany?: OrderHeaderCreateManyHandledByInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput> | AttendanceCreateWithoutApprovedByInput[] | AttendanceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutApprovedByInput | AttendanceCreateOrConnectWithoutApprovedByInput[]
    createMany?: AttendanceCreateManyApprovedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput> | LeaveRequestCreateWithoutApprovedByInput[] | LeaveRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApprovedByInput | LeaveRequestCreateOrConnectWithoutApprovedByInput[]
    createMany?: LeaveRequestCreateManyApprovedByInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssigneeInput, EmployeeTaskUncheckedCreateWithoutAssigneeInput> | EmployeeTaskCreateWithoutAssigneeInput[] | EmployeeTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssigneeInput | EmployeeTaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: EmployeeTaskCreateManyAssigneeInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput> | EmployeeTaskCreateWithoutAssignedByInput[] | EmployeeTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssignedByInput | EmployeeTaskCreateOrConnectWithoutAssignedByInput[]
    createMany?: EmployeeTaskCreateManyAssignedByInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput = {
    create?: XOR<OrderHeaderCreateWithoutHandledByInput, OrderHeaderUncheckedCreateWithoutHandledByInput> | OrderHeaderCreateWithoutHandledByInput[] | OrderHeaderUncheckedCreateWithoutHandledByInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutHandledByInput | OrderHeaderCreateOrConnectWithoutHandledByInput[]
    createMany?: OrderHeaderCreateManyHandledByInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput> | AttendanceCreateWithoutApprovedByInput[] | AttendanceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutApprovedByInput | AttendanceCreateOrConnectWithoutApprovedByInput[]
    createMany?: AttendanceCreateManyApprovedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EnumEmployeeRoleFieldUpdateOperationsInput = {
    set?: $Enums.EmployeeRole
  }

  export type OutletUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<OutletCreateWithoutEmployeesInput, OutletUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: OutletCreateOrConnectWithoutEmployeesInput
    upsert?: OutletUpsertWithoutEmployeesInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutEmployeesInput, OutletUpdateWithoutEmployeesInput>, OutletUncheckedUpdateWithoutEmployeesInput>
  }

  export type ShiftUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeesInput
    upsert?: ShiftUpsertWithoutEmployeesInput
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutEmployeesInput, ShiftUpdateWithoutEmployeesInput>, ShiftUncheckedUpdateWithoutEmployeesInput>
  }

  export type AttendanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeeInput | AttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput> | LeaveRequestCreateWithoutApprovedByInput[] | LeaveRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApprovedByInput | LeaveRequestCreateOrConnectWithoutApprovedByInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput | LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LeaveRequestCreateManyApprovedByInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput | LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutApprovedByInput | LeaveRequestUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type EmployeeTaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssigneeInput, EmployeeTaskUncheckedCreateWithoutAssigneeInput> | EmployeeTaskCreateWithoutAssigneeInput[] | EmployeeTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssigneeInput | EmployeeTaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutAssigneeInput | EmployeeTaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: EmployeeTaskCreateManyAssigneeInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutAssigneeInput | EmployeeTaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutAssigneeInput | EmployeeTaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeTaskUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput> | EmployeeTaskCreateWithoutAssignedByInput[] | EmployeeTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssignedByInput | EmployeeTaskCreateOrConnectWithoutAssignedByInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput | EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: EmployeeTaskCreateManyAssignedByInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput | EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput | EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type OrderHeaderUpdateManyWithoutHandledByNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutHandledByInput, OrderHeaderUncheckedCreateWithoutHandledByInput> | OrderHeaderCreateWithoutHandledByInput[] | OrderHeaderUncheckedCreateWithoutHandledByInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutHandledByInput | OrderHeaderCreateOrConnectWithoutHandledByInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutHandledByInput | OrderHeaderUpsertWithWhereUniqueWithoutHandledByInput[]
    createMany?: OrderHeaderCreateManyHandledByInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutHandledByInput | OrderHeaderUpdateWithWhereUniqueWithoutHandledByInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutHandledByInput | OrderHeaderUpdateManyWithWhereWithoutHandledByInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput> | AttendanceCreateWithoutApprovedByInput[] | AttendanceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutApprovedByInput | AttendanceCreateOrConnectWithoutApprovedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutApprovedByInput | AttendanceUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: AttendanceCreateManyApprovedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutApprovedByInput | AttendanceUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutApprovedByInput | AttendanceUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeeInput | AttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput> | LeaveRequestCreateWithoutApprovedByInput[] | LeaveRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutApprovedByInput | LeaveRequestCreateOrConnectWithoutApprovedByInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput | LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LeaveRequestCreateManyApprovedByInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput | LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutApprovedByInput | LeaveRequestUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssigneeInput, EmployeeTaskUncheckedCreateWithoutAssigneeInput> | EmployeeTaskCreateWithoutAssigneeInput[] | EmployeeTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssigneeInput | EmployeeTaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutAssigneeInput | EmployeeTaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: EmployeeTaskCreateManyAssigneeInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutAssigneeInput | EmployeeTaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutAssigneeInput | EmployeeTaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput> | EmployeeTaskCreateWithoutAssignedByInput[] | EmployeeTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssignedByInput | EmployeeTaskCreateOrConnectWithoutAssignedByInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput | EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: EmployeeTaskCreateManyAssignedByInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput | EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput | EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutHandledByInput, OrderHeaderUncheckedCreateWithoutHandledByInput> | OrderHeaderCreateWithoutHandledByInput[] | OrderHeaderUncheckedCreateWithoutHandledByInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutHandledByInput | OrderHeaderCreateOrConnectWithoutHandledByInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutHandledByInput | OrderHeaderUpsertWithWhereUniqueWithoutHandledByInput[]
    createMany?: OrderHeaderCreateManyHandledByInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutHandledByInput | OrderHeaderUpdateWithWhereUniqueWithoutHandledByInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutHandledByInput | OrderHeaderUpdateManyWithWhereWithoutHandledByInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput> | AttendanceCreateWithoutApprovedByInput[] | AttendanceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutApprovedByInput | AttendanceCreateOrConnectWithoutApprovedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutApprovedByInput | AttendanceUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: AttendanceCreateManyApprovedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutApprovedByInput | AttendanceUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutApprovedByInput | AttendanceUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutShiftInput = {
    create?: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput> | AttendanceCreateWithoutShiftInput[] | AttendanceUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutShiftInput | AttendanceCreateOrConnectWithoutShiftInput[]
    createMany?: AttendanceCreateManyShiftInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput> | AttendanceCreateWithoutShiftInput[] | AttendanceUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutShiftInput | AttendanceCreateOrConnectWithoutShiftInput[]
    createMany?: AttendanceCreateManyShiftInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShiftInput | EmployeeUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShiftInput | EmployeeUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShiftInput | EmployeeUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutShiftNestedInput = {
    create?: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput> | AttendanceCreateWithoutShiftInput[] | AttendanceUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutShiftInput | AttendanceCreateOrConnectWithoutShiftInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutShiftInput | AttendanceUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: AttendanceCreateManyShiftInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutShiftInput | AttendanceUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutShiftInput | AttendanceUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShiftInput | EmployeeUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShiftInput | EmployeeUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShiftInput | EmployeeUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput> | AttendanceCreateWithoutShiftInput[] | AttendanceUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutShiftInput | AttendanceCreateOrConnectWithoutShiftInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutShiftInput | AttendanceUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: AttendanceCreateManyShiftInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutShiftInput | AttendanceUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutShiftInput | AttendanceUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendancesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<ShiftCreateWithoutAttendancesInput, ShiftUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutAttendancesInput
    connect?: ShiftWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<OutletCreateWithoutAttendancesInput, OutletUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: OutletCreateOrConnectWithoutAttendancesInput
    connect?: OutletWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutApprovedByInput = {
    create?: XOR<EmployeeCreateWithoutApprovedByInput, EmployeeUncheckedCreateWithoutApprovedByInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutApprovedByInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendancesInput
    upsert?: EmployeeUpsertWithoutAttendancesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendancesInput, EmployeeUpdateWithoutAttendancesInput>, EmployeeUncheckedUpdateWithoutAttendancesInput>
  }

  export type ShiftUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<ShiftCreateWithoutAttendancesInput, ShiftUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutAttendancesInput
    upsert?: ShiftUpsertWithoutAttendancesInput
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutAttendancesInput, ShiftUpdateWithoutAttendancesInput>, ShiftUncheckedUpdateWithoutAttendancesInput>
  }

  export type OutletUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<OutletCreateWithoutAttendancesInput, OutletUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: OutletCreateOrConnectWithoutAttendancesInput
    upsert?: OutletUpsertWithoutAttendancesInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutAttendancesInput, OutletUpdateWithoutAttendancesInput>, OutletUncheckedUpdateWithoutAttendancesInput>
  }

  export type EmployeeUpdateOneWithoutApprovedByNestedInput = {
    create?: XOR<EmployeeCreateWithoutApprovedByInput, EmployeeUncheckedCreateWithoutApprovedByInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutApprovedByInput
    upsert?: EmployeeUpsertWithoutApprovedByInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutApprovedByInput, EmployeeUpdateWithoutApprovedByInput>, EmployeeUncheckedUpdateWithoutApprovedByInput>
  }

  export type EmployeeCreateNestedOneWithoutLeavesInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutLeavesInput = {
    create?: XOR<OutletCreateWithoutLeavesInput, OutletUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: OutletCreateOrConnectWithoutLeavesInput
    connect?: OutletWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutLeavesApprovedInput = {
    create?: XOR<EmployeeCreateWithoutLeavesApprovedInput, EmployeeUncheckedCreateWithoutLeavesApprovedInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesApprovedInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumLeaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaveType
  }

  export type EnumLeaveReqStatFieldUpdateOperationsInput = {
    set?: $Enums.LeaveReqStat
  }

  export type EmployeeUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    upsert?: EmployeeUpsertWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeavesInput, EmployeeUpdateWithoutLeavesInput>, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type OutletUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<OutletCreateWithoutLeavesInput, OutletUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: OutletCreateOrConnectWithoutLeavesInput
    upsert?: OutletUpsertWithoutLeavesInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutLeavesInput, OutletUpdateWithoutLeavesInput>, OutletUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeUpdateOneWithoutLeavesApprovedNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeavesApprovedInput, EmployeeUncheckedCreateWithoutLeavesApprovedInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesApprovedInput
    upsert?: EmployeeUpsertWithoutLeavesApprovedInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeavesApprovedInput, EmployeeUpdateWithoutLeavesApprovedInput>, EmployeeUncheckedUpdateWithoutLeavesApprovedInput>
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OutletCreateWithoutOrdersInput, OutletUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OutletCreateOrConnectWithoutOrdersInput
    connect?: OutletWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutOrdersHandledInput = {
    create?: XOR<EmployeeCreateWithoutOrdersHandledInput, EmployeeUncheckedCreateWithoutOrdersHandledInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOrdersHandledInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EmployeeTaskCreateNestedManyWithoutOrderInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderInput, EmployeeTaskUncheckedCreateWithoutOrderInput> | EmployeeTaskCreateWithoutOrderInput[] | EmployeeTaskUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderInput | EmployeeTaskCreateOrConnectWithoutOrderInput[]
    createMany?: EmployeeTaskCreateManyOrderInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderInput, EmployeeTaskUncheckedCreateWithoutOrderInput> | EmployeeTaskCreateWithoutOrderInput[] | EmployeeTaskUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderInput | EmployeeTaskCreateOrConnectWithoutOrderInput[]
    createMany?: EmployeeTaskCreateManyOrderInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type OutletUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<OutletCreateWithoutOrdersInput, OutletUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OutletCreateOrConnectWithoutOrdersInput
    upsert?: OutletUpsertWithoutOrdersInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutOrdersInput, OutletUpdateWithoutOrdersInput>, OutletUncheckedUpdateWithoutOrdersInput>
  }

  export type EmployeeUpdateOneWithoutOrdersHandledNestedInput = {
    create?: XOR<EmployeeCreateWithoutOrdersHandledInput, EmployeeUncheckedCreateWithoutOrdersHandledInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOrdersHandledInput
    upsert?: EmployeeUpsertWithoutOrdersHandledInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutOrdersHandledInput, EmployeeUpdateWithoutOrdersHandledInput>, EmployeeUncheckedUpdateWithoutOrdersHandledInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type EmployeeTaskUpdateManyWithoutOrderNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderInput, EmployeeTaskUncheckedCreateWithoutOrderInput> | EmployeeTaskCreateWithoutOrderInput[] | EmployeeTaskUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderInput | EmployeeTaskCreateOrConnectWithoutOrderInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOrderInput | EmployeeTaskUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: EmployeeTaskCreateManyOrderInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOrderInput | EmployeeTaskUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOrderInput | EmployeeTaskUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderInput, EmployeeTaskUncheckedCreateWithoutOrderInput> | EmployeeTaskCreateWithoutOrderInput[] | EmployeeTaskUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderInput | EmployeeTaskCreateOrConnectWithoutOrderInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOrderInput | EmployeeTaskUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: EmployeeTaskCreateManyOrderInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOrderInput | EmployeeTaskUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOrderInput | EmployeeTaskUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type OrderHeaderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderHeaderCreateWithoutItemsInput, OrderHeaderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutItemsInput
    connect?: OrderHeaderWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ServiceCreateWithoutOrderItemsInput, ServiceUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrderItemsInput
    connect?: ServiceWhereUniqueInput
  }

  export type OrderHeaderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutItemsInput, OrderHeaderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutItemsInput
    upsert?: OrderHeaderUpsertWithoutItemsInput
    connect?: OrderHeaderWhereUniqueInput
    update?: XOR<XOR<OrderHeaderUpdateToOneWithWhereWithoutItemsInput, OrderHeaderUpdateWithoutItemsInput>, OrderHeaderUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ServiceCreateWithoutOrderItemsInput, ServiceUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrderItemsInput
    upsert?: ServiceUpsertWithoutOrderItemsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutOrderItemsInput, ServiceUpdateWithoutOrderItemsInput>, ServiceUncheckedUpdateWithoutOrderItemsInput>
  }

  export type EmployeeTaskCreateNestedManyWithoutStationInput = {
    create?: XOR<EmployeeTaskCreateWithoutStationInput, EmployeeTaskUncheckedCreateWithoutStationInput> | EmployeeTaskCreateWithoutStationInput[] | EmployeeTaskUncheckedCreateWithoutStationInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutStationInput | EmployeeTaskCreateOrConnectWithoutStationInput[]
    createMany?: EmployeeTaskCreateManyStationInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutStationInput = {
    create?: XOR<EmployeeTaskCreateWithoutStationInput, EmployeeTaskUncheckedCreateWithoutStationInput> | EmployeeTaskCreateWithoutStationInput[] | EmployeeTaskUncheckedCreateWithoutStationInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutStationInput | EmployeeTaskCreateOrConnectWithoutStationInput[]
    createMany?: EmployeeTaskCreateManyStationInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EnumStationFieldUpdateOperationsInput = {
    set?: $Enums.Station
  }

  export type EmployeeTaskUpdateManyWithoutStationNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutStationInput, EmployeeTaskUncheckedCreateWithoutStationInput> | EmployeeTaskCreateWithoutStationInput[] | EmployeeTaskUncheckedCreateWithoutStationInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutStationInput | EmployeeTaskCreateOrConnectWithoutStationInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutStationInput | EmployeeTaskUpsertWithWhereUniqueWithoutStationInput[]
    createMany?: EmployeeTaskCreateManyStationInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutStationInput | EmployeeTaskUpdateWithWhereUniqueWithoutStationInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutStationInput | EmployeeTaskUpdateManyWithWhereWithoutStationInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutStationNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutStationInput, EmployeeTaskUncheckedCreateWithoutStationInput> | EmployeeTaskCreateWithoutStationInput[] | EmployeeTaskUncheckedCreateWithoutStationInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutStationInput | EmployeeTaskCreateOrConnectWithoutStationInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutStationInput | EmployeeTaskUpsertWithWhereUniqueWithoutStationInput[]
    createMany?: EmployeeTaskCreateManyStationInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutStationInput | EmployeeTaskUpdateWithWhereUniqueWithoutStationInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutStationInput | EmployeeTaskUpdateManyWithWhereWithoutStationInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutWorkerTasksInput = {
    create?: XOR<EmployeeCreateWithoutWorkerTasksInput, EmployeeUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkerTasksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutWorkerTasksAssignedInput = {
    create?: XOR<EmployeeCreateWithoutWorkerTasksAssignedInput, EmployeeUncheckedCreateWithoutWorkerTasksAssignedInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkerTasksAssignedInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OrderHeaderCreateNestedOneWithoutTasksInput = {
    create?: XOR<OrderHeaderCreateWithoutTasksInput, OrderHeaderUncheckedCreateWithoutTasksInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutTasksInput
    connect?: OrderHeaderWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutTasksInput = {
    create?: XOR<OutletCreateWithoutTasksInput, OutletUncheckedCreateWithoutTasksInput>
    connectOrCreate?: OutletCreateOrConnectWithoutTasksInput
    connect?: OutletWhereUniqueInput
  }

  export type WorkerStationCreateNestedOneWithoutTasksInput = {
    create?: XOR<WorkerStationCreateWithoutTasksInput, WorkerStationUncheckedCreateWithoutTasksInput>
    connectOrCreate?: WorkerStationCreateOrConnectWithoutTasksInput
    connect?: WorkerStationWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EmployeeUpdateOneWithoutWorkerTasksNestedInput = {
    create?: XOR<EmployeeCreateWithoutWorkerTasksInput, EmployeeUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkerTasksInput
    upsert?: EmployeeUpsertWithoutWorkerTasksInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWorkerTasksInput, EmployeeUpdateWithoutWorkerTasksInput>, EmployeeUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type EmployeeUpdateOneWithoutWorkerTasksAssignedNestedInput = {
    create?: XOR<EmployeeCreateWithoutWorkerTasksAssignedInput, EmployeeUncheckedCreateWithoutWorkerTasksAssignedInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkerTasksAssignedInput
    upsert?: EmployeeUpsertWithoutWorkerTasksAssignedInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWorkerTasksAssignedInput, EmployeeUpdateWithoutWorkerTasksAssignedInput>, EmployeeUncheckedUpdateWithoutWorkerTasksAssignedInput>
  }

  export type OrderHeaderUpdateOneWithoutTasksNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutTasksInput, OrderHeaderUncheckedCreateWithoutTasksInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutTasksInput
    upsert?: OrderHeaderUpsertWithoutTasksInput
    disconnect?: OrderHeaderWhereInput | boolean
    delete?: OrderHeaderWhereInput | boolean
    connect?: OrderHeaderWhereUniqueInput
    update?: XOR<XOR<OrderHeaderUpdateToOneWithWhereWithoutTasksInput, OrderHeaderUpdateWithoutTasksInput>, OrderHeaderUncheckedUpdateWithoutTasksInput>
  }

  export type OutletUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<OutletCreateWithoutTasksInput, OutletUncheckedCreateWithoutTasksInput>
    connectOrCreate?: OutletCreateOrConnectWithoutTasksInput
    upsert?: OutletUpsertWithoutTasksInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutTasksInput, OutletUpdateWithoutTasksInput>, OutletUncheckedUpdateWithoutTasksInput>
  }

  export type WorkerStationUpdateOneWithoutTasksNestedInput = {
    create?: XOR<WorkerStationCreateWithoutTasksInput, WorkerStationUncheckedCreateWithoutTasksInput>
    connectOrCreate?: WorkerStationCreateOrConnectWithoutTasksInput
    upsert?: WorkerStationUpsertWithoutTasksInput
    disconnect?: WorkerStationWhereInput | boolean
    delete?: WorkerStationWhereInput | boolean
    connect?: WorkerStationWhereUniqueInput
    update?: XOR<XOR<WorkerStationUpdateToOneWithWhereWithoutTasksInput, WorkerStationUpdateWithoutTasksInput>, WorkerStationUncheckedUpdateWithoutTasksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLabelFilter<$PrismaModel = never> = {
    equals?: $Enums.Label | EnumLabelFieldRefInput<$PrismaModel>
    in?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelFilter<$PrismaModel> | $Enums.Label
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLabelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Label | EnumLabelFieldRefInput<$PrismaModel>
    in?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelWithAggregatesFilter<$PrismaModel> | $Enums.Label
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabelFilter<$PrismaModel>
    _max?: NestedEnumLabelFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumEmployeeRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeRole | EnumEmployeeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeRoleFilter<$PrismaModel> | $Enums.EmployeeRole
  }

  export type NestedEnumEmployeeRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeRole | EnumEmployeeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeRoleWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeRoleFilter<$PrismaModel>
    _max?: NestedEnumEmployeeRoleFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type NestedEnumLeaveReqStatFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveReqStat | EnumLeaveReqStatFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveReqStat[] | ListEnumLeaveReqStatFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveReqStat[] | ListEnumLeaveReqStatFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveReqStatFilter<$PrismaModel> | $Enums.LeaveReqStat
  }

  export type NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type NestedEnumLeaveReqStatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveReqStat | EnumLeaveReqStatFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveReqStat[] | ListEnumLeaveReqStatFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveReqStat[] | ListEnumLeaveReqStatFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveReqStatWithAggregatesFilter<$PrismaModel> | $Enums.LeaveReqStat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveReqStatFilter<$PrismaModel>
    _max?: NestedEnumLeaveReqStatFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumStationFilter<$PrismaModel = never> = {
    equals?: $Enums.Station | EnumStationFieldRefInput<$PrismaModel>
    in?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    not?: NestedEnumStationFilter<$PrismaModel> | $Enums.Station
  }

  export type NestedEnumStationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Station | EnumStationFieldRefInput<$PrismaModel>
    in?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    not?: NestedEnumStationWithAggregatesFilter<$PrismaModel> | $Enums.Station
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStationFilter<$PrismaModel>
    _max?: NestedEnumStationFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type CustomerAddressCreateWithoutCustomerInput = {
    id?: string
    label?: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerAddressUncheckedCreateWithoutCustomerInput = {
    id?: string
    label?: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerAddressCreateOrConnectWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressCreateManyCustomerInputEnvelope = {
    data: CustomerAddressCreateManyCustomerInput | CustomerAddressCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderHeaderCreateWithoutCustomerInput = {
    id?: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutOrdersInput
    handledBy?: EmployeeCreateNestedOneWithoutOrdersHandledInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderUncheckedCreateWithoutCustomerInput = {
    id?: string
    outletId: string
    handledById: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderCreateOrConnectWithoutCustomerInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutCustomerInput, OrderHeaderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderHeaderCreateManyCustomerInputEnvelope = {
    data: OrderHeaderCreateManyCustomerInput | OrderHeaderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    update: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    data: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerAddressScalarWhereInput
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerAddressScalarWhereInput = {
    AND?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    OR?: CustomerAddressScalarWhereInput[]
    NOT?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    label?: EnumLabelFilter<"CustomerAddress"> | $Enums.Label
    address?: StringFilter<"CustomerAddress"> | string
    city?: StringFilter<"CustomerAddress"> | string
    postalCode?: StringFilter<"CustomerAddress"> | string
    latitude?: FloatFilter<"CustomerAddress"> | number
    longitude?: FloatFilter<"CustomerAddress"> | number
    notes?: StringNullableFilter<"CustomerAddress"> | string | null
    isPrimary?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CustomerAddress"> | Date | string | null
  }

  export type OrderHeaderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderHeaderWhereUniqueInput
    update: XOR<OrderHeaderUpdateWithoutCustomerInput, OrderHeaderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderHeaderCreateWithoutCustomerInput, OrderHeaderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderHeaderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderHeaderWhereUniqueInput
    data: XOR<OrderHeaderUpdateWithoutCustomerInput, OrderHeaderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderHeaderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderHeaderScalarWhereInput
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderHeaderScalarWhereInput = {
    AND?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
    OR?: OrderHeaderScalarWhereInput[]
    NOT?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
    id?: StringFilter<"OrderHeader"> | string
    customerId?: StringFilter<"OrderHeader"> | string
    outletId?: StringFilter<"OrderHeader"> | string
    handledById?: StringFilter<"OrderHeader"> | string
    status?: EnumOrderStatusFilter<"OrderHeader"> | $Enums.OrderStatus
    notes?: StringFilter<"OrderHeader"> | string
    pickupAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    deliveryAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    paymentMethod?: EnumPaymentMethodNullableFilter<"OrderHeader"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"OrderHeader"> | Date | string
    updatedAt?: DateTimeFilter<"OrderHeader"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
  }

  export type CustomerCreateWithoutAddressesInput = {
    id?: string
    role?: string
    name?: string | null
    email: string
    password: string
    phoneNumber?: string | null
    isVerified?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderHeaderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAddressesInput = {
    id?: string
    role?: string
    name?: string | null
    email: string
    password: string
    phoneNumber?: string | null
    isVerified?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderHeaderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAddressesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
  }

  export type CustomerUpsertWithoutAddressesInput = {
    update: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type CustomerUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderHeaderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderHeaderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ServiceCreateWithoutCategoryInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderItems?: OrderItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceCreateManyCategoryInputEnvelope = {
    data: ServiceCreateManyCategoryInput | ServiceCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    serviceCategoryId?: StringFilter<"Service"> | string
    unit?: StringFilter<"Service"> | string
    basePrice?: IntFilter<"Service"> | number
    minQty?: FloatFilter<"Service"> | number
    estHours?: IntFilter<"Service"> | number
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
  }

  export type ServiceCategoryCreateWithoutServicesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceCategoryUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceCategoryCreateOrConnectWithoutServicesInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
  }

  export type OrderItemCreateWithoutServiceInput = {
    id?: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    order: OrderHeaderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutServiceInput = {
    id?: string
    orderId: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemCreateOrConnectWithoutServiceInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput>
  }

  export type OrderItemCreateManyServiceInputEnvelope = {
    data: OrderItemCreateManyServiceInput | OrderItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCategoryUpsertWithoutServicesInput = {
    update: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutServicesInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceCategoryUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCategoryUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutServiceInput, OrderItemUncheckedUpdateWithoutServiceInput>
    create: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutServiceInput, OrderItemUncheckedUpdateWithoutServiceInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutServiceInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    serviceId?: StringFilter<"OrderItem"> | string
    qty?: FloatFilter<"OrderItem"> | number
    note?: StringFilter<"OrderItem"> | string
    unitPrice?: IntFilter<"OrderItem"> | number
    subTotal?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
  }

  export type OutletScheduleCreateWithoutOutletInput = {
    id?: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleUncheckedCreateWithoutOutletInput = {
    id?: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleCreateOrConnectWithoutOutletInput = {
    where: OutletScheduleWhereUniqueInput
    create: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput>
  }

  export type OutletScheduleCreateManyOutletInputEnvelope = {
    data: OutletScheduleCreateManyOutletInput | OutletScheduleCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutOutletInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shift: ShiftCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUncheckedCreateWithoutOutletInput = {
    id?: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeCreateOrConnectWithoutOutletInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutOutletInput, EmployeeUncheckedCreateWithoutOutletInput>
  }

  export type EmployeeCreateManyOutletInputEnvelope = {
    data: EmployeeCreateManyOutletInput | EmployeeCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type OrderHeaderCreateWithoutOutletInput = {
    id?: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    handledBy?: EmployeeCreateNestedOneWithoutOrdersHandledInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderUncheckedCreateWithoutOutletInput = {
    id?: string
    customerId: string
    handledById: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderCreateOrConnectWithoutOutletInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutOutletInput, OrderHeaderUncheckedCreateWithoutOutletInput>
  }

  export type OrderHeaderCreateManyOutletInputEnvelope = {
    data: OrderHeaderCreateManyOutletInput | OrderHeaderCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutOutletInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutAttendancesInput
    shift: ShiftCreateNestedOneWithoutAttendancesInput
    approvedBy?: EmployeeCreateNestedOneWithoutApprovedByInput
  }

  export type AttendanceUncheckedCreateWithoutOutletInput = {
    id?: string
    employeeId: string
    shiftId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutOutletInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput>
  }

  export type AttendanceCreateManyOutletInputEnvelope = {
    data: AttendanceCreateManyOutletInput | AttendanceCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutOutletInput = {
    id?: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutLeavesInput
    approvedBy?: EmployeeCreateNestedOneWithoutLeavesApprovedInput
  }

  export type LeaveRequestUncheckedCreateWithoutOutletInput = {
    id?: string
    employeeId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedById?: string | null
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateOrConnectWithoutOutletInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutOutletInput, LeaveRequestUncheckedCreateWithoutOutletInput>
  }

  export type LeaveRequestCreateManyOutletInputEnvelope = {
    data: LeaveRequestCreateManyOutletInput | LeaveRequestCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskCreateWithoutOutletInput = {
    id?: string
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignee?: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutWorkerTasksAssignedInput
    order?: OrderHeaderCreateNestedOneWithoutTasksInput
    station?: WorkerStationCreateNestedOneWithoutTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutOutletInput = {
    id?: string
    employeeId: string
    assignedById?: string | null
    orderId?: string | null
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutOutletInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput>
  }

  export type EmployeeTaskCreateManyOutletInputEnvelope = {
    data: EmployeeTaskCreateManyOutletInput | EmployeeTaskCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type OutletScheduleUpsertWithWhereUniqueWithoutOutletInput = {
    where: OutletScheduleWhereUniqueInput
    update: XOR<OutletScheduleUpdateWithoutOutletInput, OutletScheduleUncheckedUpdateWithoutOutletInput>
    create: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput>
  }

  export type OutletScheduleUpdateWithWhereUniqueWithoutOutletInput = {
    where: OutletScheduleWhereUniqueInput
    data: XOR<OutletScheduleUpdateWithoutOutletInput, OutletScheduleUncheckedUpdateWithoutOutletInput>
  }

  export type OutletScheduleUpdateManyWithWhereWithoutOutletInput = {
    where: OutletScheduleScalarWhereInput
    data: XOR<OutletScheduleUpdateManyMutationInput, OutletScheduleUncheckedUpdateManyWithoutOutletInput>
  }

  export type OutletScheduleScalarWhereInput = {
    AND?: OutletScheduleScalarWhereInput | OutletScheduleScalarWhereInput[]
    OR?: OutletScheduleScalarWhereInput[]
    NOT?: OutletScheduleScalarWhereInput | OutletScheduleScalarWhereInput[]
    id?: StringFilter<"OutletSchedule"> | string
    outletId?: StringFilter<"OutletSchedule"> | string
    detailDays?: StringFilter<"OutletSchedule"> | string
    openHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    closeHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    createdAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OutletSchedule"> | Date | string | null
  }

  export type EmployeeUpsertWithWhereUniqueWithoutOutletInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutOutletInput, EmployeeUncheckedUpdateWithoutOutletInput>
    create: XOR<EmployeeCreateWithoutOutletInput, EmployeeUncheckedCreateWithoutOutletInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutOutletInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutOutletInput, EmployeeUncheckedUpdateWithoutOutletInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutOutletInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutOutletInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    outletId?: StringFilter<"Employee"> | string
    shiftId?: StringFilter<"Employee"> | string
    role?: EnumEmployeeRoleFilter<"Employee"> | $Enums.EmployeeRole
    name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    password?: StringFilter<"Employee"> | string
    phoneNumber?: StringFilter<"Employee"> | string
    address?: StringFilter<"Employee"> | string
    isActive?: BoolFilter<"Employee"> | boolean
    resetPasswordToken?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
  }

  export type OrderHeaderUpsertWithWhereUniqueWithoutOutletInput = {
    where: OrderHeaderWhereUniqueInput
    update: XOR<OrderHeaderUpdateWithoutOutletInput, OrderHeaderUncheckedUpdateWithoutOutletInput>
    create: XOR<OrderHeaderCreateWithoutOutletInput, OrderHeaderUncheckedCreateWithoutOutletInput>
  }

  export type OrderHeaderUpdateWithWhereUniqueWithoutOutletInput = {
    where: OrderHeaderWhereUniqueInput
    data: XOR<OrderHeaderUpdateWithoutOutletInput, OrderHeaderUncheckedUpdateWithoutOutletInput>
  }

  export type OrderHeaderUpdateManyWithWhereWithoutOutletInput = {
    where: OrderHeaderScalarWhereInput
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyWithoutOutletInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutOutletInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutOutletInput, AttendanceUncheckedUpdateWithoutOutletInput>
    create: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutOutletInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutOutletInput, AttendanceUncheckedUpdateWithoutOutletInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutOutletInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutOutletInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    employeeId?: StringFilter<"Attendance"> | string
    shiftId?: StringFilter<"Attendance"> | string
    outletId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    clockInAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    clockOutAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    workMinutes?: IntNullableFilter<"Attendance"> | number | null
    lateMinutes?: IntNullableFilter<"Attendance"> | number | null
    earlyLeaveMin?: IntNullableFilter<"Attendance"> | number | null
    notes?: StringNullableFilter<"Attendance"> | string | null
    approvedById?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutOutletInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutOutletInput, LeaveRequestUncheckedUpdateWithoutOutletInput>
    create: XOR<LeaveRequestCreateWithoutOutletInput, LeaveRequestUncheckedCreateWithoutOutletInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutOutletInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutOutletInput, LeaveRequestUncheckedUpdateWithoutOutletInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutOutletInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutOutletInput>
  }

  export type LeaveRequestScalarWhereInput = {
    AND?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    OR?: LeaveRequestScalarWhereInput[]
    NOT?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    outletId?: StringFilter<"LeaveRequest"> | string
    type?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    status?: EnumLeaveReqStatFilter<"LeaveRequest"> | $Enums.LeaveReqStat
    approvedById?: StringNullableFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    notes?: StringFilter<"LeaveRequest"> | string
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    deletedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutOutletInput, EmployeeTaskUncheckedUpdateWithoutOutletInput>
    create: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutOutletInput, EmployeeTaskUncheckedUpdateWithoutOutletInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutOutletInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutOutletInput>
  }

  export type EmployeeTaskScalarWhereInput = {
    AND?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
    OR?: EmployeeTaskScalarWhereInput[]
    NOT?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
    id?: StringFilter<"EmployeeTask"> | string
    employeeId?: StringFilter<"EmployeeTask"> | string
    assignedById?: StringNullableFilter<"EmployeeTask"> | string | null
    orderId?: StringNullableFilter<"EmployeeTask"> | string | null
    outletId?: StringFilter<"EmployeeTask"> | string
    workStationId?: StringNullableFilter<"EmployeeTask"> | string | null
    type?: EnumStationFilter<"EmployeeTask"> | $Enums.Station
    status?: EnumTaskStatusFilter<"EmployeeTask"> | $Enums.TaskStatus
    startAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    qty?: FloatNullableFilter<"EmployeeTask"> | number | null
    isApproved?: BoolNullableFilter<"EmployeeTask"> | boolean | null
    notes?: StringNullableFilter<"EmployeeTask"> | string | null
    createdAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
  }

  export type OutletCreateWithoutSchedulesInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderCreateNestedManyWithoutOutletInput
    attendances?: AttendanceCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateWithoutSchedulesInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderUncheckedCreateNestedManyWithoutOutletInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletCreateOrConnectWithoutSchedulesInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutSchedulesInput, OutletUncheckedCreateWithoutSchedulesInput>
  }

  export type OutletUpsertWithoutSchedulesInput = {
    update: XOR<OutletUpdateWithoutSchedulesInput, OutletUncheckedUpdateWithoutSchedulesInput>
    create: XOR<OutletCreateWithoutSchedulesInput, OutletUncheckedCreateWithoutSchedulesInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutSchedulesInput, OutletUncheckedUpdateWithoutSchedulesInput>
  }

  export type OutletUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUncheckedUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type OutletCreateWithoutEmployeesInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderCreateNestedManyWithoutOutletInput
    attendances?: AttendanceCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderUncheckedCreateNestedManyWithoutOutletInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletCreateOrConnectWithoutEmployeesInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutEmployeesInput, OutletUncheckedCreateWithoutEmployeesInput>
  }

  export type ShiftCreateWithoutEmployeesInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutEmployeesInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
  }

  export type AttendanceCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shift: ShiftCreateNestedOneWithoutAttendancesInput
    outlet: OutletCreateNestedOneWithoutAttendancesInput
    approvedBy?: EmployeeCreateNestedOneWithoutApprovedByInput
  }

  export type AttendanceUncheckedCreateWithoutEmployeeInput = {
    id?: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceCreateManyEmployeeInputEnvelope = {
    data: AttendanceCreateManyEmployeeInput | AttendanceCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutEmployeeInput = {
    id?: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutLeavesInput
    approvedBy?: EmployeeCreateNestedOneWithoutLeavesApprovedInput
  }

  export type LeaveRequestUncheckedCreateWithoutEmployeeInput = {
    id?: string
    outletId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedById?: string | null
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateOrConnectWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestCreateManyEmployeeInputEnvelope = {
    data: LeaveRequestCreateManyEmployeeInput | LeaveRequestCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutApprovedByInput = {
    id?: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutLeavesInput
    outlet: OutletCreateNestedOneWithoutLeavesInput
  }

  export type LeaveRequestUncheckedCreateWithoutApprovedByInput = {
    id?: string
    employeeId: string
    outletId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateOrConnectWithoutApprovedByInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput>
  }

  export type LeaveRequestCreateManyApprovedByInputEnvelope = {
    data: LeaveRequestCreateManyApprovedByInput | LeaveRequestCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskCreateWithoutAssigneeInput = {
    id?: string
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignedBy?: EmployeeCreateNestedOneWithoutWorkerTasksAssignedInput
    order?: OrderHeaderCreateNestedOneWithoutTasksInput
    outlet: OutletCreateNestedOneWithoutTasksInput
    station?: WorkerStationCreateNestedOneWithoutTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    assignedById?: string | null
    orderId?: string | null
    outletId: string
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutAssigneeInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutAssigneeInput, EmployeeTaskUncheckedCreateWithoutAssigneeInput>
  }

  export type EmployeeTaskCreateManyAssigneeInputEnvelope = {
    data: EmployeeTaskCreateManyAssigneeInput | EmployeeTaskCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskCreateWithoutAssignedByInput = {
    id?: string
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignee?: EmployeeCreateNestedOneWithoutWorkerTasksInput
    order?: OrderHeaderCreateNestedOneWithoutTasksInput
    outlet: OutletCreateNestedOneWithoutTasksInput
    station?: WorkerStationCreateNestedOneWithoutTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutAssignedByInput = {
    id?: string
    employeeId: string
    orderId?: string | null
    outletId: string
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutAssignedByInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput>
  }

  export type EmployeeTaskCreateManyAssignedByInputEnvelope = {
    data: EmployeeTaskCreateManyAssignedByInput | EmployeeTaskCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type OrderHeaderCreateWithoutHandledByInput = {
    id?: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    outlet: OutletCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderUncheckedCreateWithoutHandledByInput = {
    id?: string
    customerId: string
    outletId: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderCreateOrConnectWithoutHandledByInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutHandledByInput, OrderHeaderUncheckedCreateWithoutHandledByInput>
  }

  export type OrderHeaderCreateManyHandledByInputEnvelope = {
    data: OrderHeaderCreateManyHandledByInput | OrderHeaderCreateManyHandledByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutApprovedByInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutAttendancesInput
    shift: ShiftCreateNestedOneWithoutAttendancesInput
    outlet: OutletCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutApprovedByInput = {
    id?: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutApprovedByInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput>
  }

  export type AttendanceCreateManyApprovedByInputEnvelope = {
    data: AttendanceCreateManyApprovedByInput | AttendanceCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type OutletUpsertWithoutEmployeesInput = {
    update: XOR<OutletUpdateWithoutEmployeesInput, OutletUncheckedUpdateWithoutEmployeesInput>
    create: XOR<OutletCreateWithoutEmployeesInput, OutletUncheckedCreateWithoutEmployeesInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutEmployeesInput, OutletUncheckedUpdateWithoutEmployeesInput>
  }

  export type OutletUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUncheckedUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type ShiftUpsertWithoutEmployeesInput = {
    update: XOR<ShiftUpdateWithoutEmployeesInput, ShiftUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutEmployeesInput, ShiftUncheckedUpdateWithoutEmployeesInput>
  }

  export type ShiftUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutApprovedByInput, LeaveRequestUncheckedUpdateWithoutApprovedByInput>
    create: XOR<LeaveRequestCreateWithoutApprovedByInput, LeaveRequestUncheckedCreateWithoutApprovedByInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutApprovedByInput, LeaveRequestUncheckedUpdateWithoutApprovedByInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutApprovedByInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutAssigneeInput, EmployeeTaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<EmployeeTaskCreateWithoutAssigneeInput, EmployeeTaskUncheckedCreateWithoutAssigneeInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutAssigneeInput, EmployeeTaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutAssignedByInput, EmployeeTaskUncheckedUpdateWithoutAssignedByInput>
    create: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutAssignedByInput, EmployeeTaskUncheckedUpdateWithoutAssignedByInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type OrderHeaderUpsertWithWhereUniqueWithoutHandledByInput = {
    where: OrderHeaderWhereUniqueInput
    update: XOR<OrderHeaderUpdateWithoutHandledByInput, OrderHeaderUncheckedUpdateWithoutHandledByInput>
    create: XOR<OrderHeaderCreateWithoutHandledByInput, OrderHeaderUncheckedCreateWithoutHandledByInput>
  }

  export type OrderHeaderUpdateWithWhereUniqueWithoutHandledByInput = {
    where: OrderHeaderWhereUniqueInput
    data: XOR<OrderHeaderUpdateWithoutHandledByInput, OrderHeaderUncheckedUpdateWithoutHandledByInput>
  }

  export type OrderHeaderUpdateManyWithWhereWithoutHandledByInput = {
    where: OrderHeaderScalarWhereInput
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyWithoutHandledByInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutApprovedByInput, AttendanceUncheckedUpdateWithoutApprovedByInput>
    create: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutApprovedByInput, AttendanceUncheckedUpdateWithoutApprovedByInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutApprovedByInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type EmployeeCreateWithoutShiftInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUncheckedCreateWithoutShiftInput = {
    id?: string
    outletId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeCreateOrConnectWithoutShiftInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeCreateManyShiftInputEnvelope = {
    data: EmployeeCreateManyShiftInput | EmployeeCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutShiftInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutAttendancesInput
    outlet: OutletCreateNestedOneWithoutAttendancesInput
    approvedBy?: EmployeeCreateNestedOneWithoutApprovedByInput
  }

  export type AttendanceUncheckedCreateWithoutShiftInput = {
    id?: string
    employeeId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutShiftInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput>
  }

  export type AttendanceCreateManyShiftInputEnvelope = {
    data: AttendanceCreateManyShiftInput | AttendanceCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutShiftInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutShiftInput, EmployeeUncheckedUpdateWithoutShiftInput>
    create: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutShiftInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutShiftInput, EmployeeUncheckedUpdateWithoutShiftInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutShiftInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutShiftInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutShiftInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutShiftInput, AttendanceUncheckedUpdateWithoutShiftInput>
    create: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutShiftInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutShiftInput, AttendanceUncheckedUpdateWithoutShiftInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutShiftInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutShiftInput>
  }

  export type EmployeeCreateWithoutAttendancesInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutEmployeesInput
    shift: ShiftCreateNestedOneWithoutEmployeesInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUncheckedCreateWithoutAttendancesInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeCreateOrConnectWithoutAttendancesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
  }

  export type ShiftCreateWithoutAttendancesInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutAttendancesInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutAttendancesInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutAttendancesInput, ShiftUncheckedCreateWithoutAttendancesInput>
  }

  export type OutletCreateWithoutAttendancesInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleCreateNestedManyWithoutOutletInput
    employees?: EmployeeCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateWithoutAttendancesInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderUncheckedCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletCreateOrConnectWithoutAttendancesInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutAttendancesInput, OutletUncheckedCreateWithoutAttendancesInput>
  }

  export type EmployeeCreateWithoutApprovedByInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutEmployeesInput
    shift: ShiftCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderCreateNestedManyWithoutHandledByInput
  }

  export type EmployeeUncheckedCreateWithoutApprovedByInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput
  }

  export type EmployeeCreateOrConnectWithoutApprovedByInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutApprovedByInput, EmployeeUncheckedCreateWithoutApprovedByInput>
  }

  export type EmployeeUpsertWithoutAttendancesInput = {
    update: XOR<EmployeeUpdateWithoutAttendancesInput, EmployeeUncheckedUpdateWithoutAttendancesInput>
    create: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendancesInput, EmployeeUncheckedUpdateWithoutAttendancesInput>
  }

  export type EmployeeUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutEmployeesNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type ShiftUpsertWithoutAttendancesInput = {
    update: XOR<ShiftUpdateWithoutAttendancesInput, ShiftUncheckedUpdateWithoutAttendancesInput>
    create: XOR<ShiftCreateWithoutAttendancesInput, ShiftUncheckedCreateWithoutAttendancesInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutAttendancesInput, ShiftUncheckedUpdateWithoutAttendancesInput>
  }

  export type ShiftUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type OutletUpsertWithoutAttendancesInput = {
    update: XOR<OutletUpdateWithoutAttendancesInput, OutletUncheckedUpdateWithoutAttendancesInput>
    create: XOR<OutletCreateWithoutAttendancesInput, OutletUncheckedCreateWithoutAttendancesInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutAttendancesInput, OutletUncheckedUpdateWithoutAttendancesInput>
  }

  export type OutletUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUncheckedUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type EmployeeUpsertWithoutApprovedByInput = {
    update: XOR<EmployeeUpdateWithoutApprovedByInput, EmployeeUncheckedUpdateWithoutApprovedByInput>
    create: XOR<EmployeeCreateWithoutApprovedByInput, EmployeeUncheckedCreateWithoutApprovedByInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutApprovedByInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutApprovedByInput, EmployeeUncheckedUpdateWithoutApprovedByInput>
  }

  export type EmployeeUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutEmployeesNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUpdateManyWithoutHandledByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput
  }

  export type EmployeeCreateWithoutLeavesInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutEmployeesInput
    shift: ShiftCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUncheckedCreateWithoutLeavesInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeCreateOrConnectWithoutLeavesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
  }

  export type OutletCreateWithoutLeavesInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleCreateNestedManyWithoutOutletInput
    employees?: EmployeeCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderCreateNestedManyWithoutOutletInput
    attendances?: AttendanceCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateWithoutLeavesInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderUncheckedCreateNestedManyWithoutOutletInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletCreateOrConnectWithoutLeavesInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutLeavesInput, OutletUncheckedCreateWithoutLeavesInput>
  }

  export type EmployeeCreateWithoutLeavesApprovedInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutEmployeesInput
    shift: ShiftCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUncheckedCreateWithoutLeavesApprovedInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeCreateOrConnectWithoutLeavesApprovedInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeavesApprovedInput, EmployeeUncheckedCreateWithoutLeavesApprovedInput>
  }

  export type EmployeeUpsertWithoutLeavesInput = {
    update: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeavesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutEmployeesNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type OutletUpsertWithoutLeavesInput = {
    update: XOR<OutletUpdateWithoutLeavesInput, OutletUncheckedUpdateWithoutLeavesInput>
    create: XOR<OutletCreateWithoutLeavesInput, OutletUncheckedCreateWithoutLeavesInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutLeavesInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutLeavesInput, OutletUncheckedUpdateWithoutLeavesInput>
  }

  export type OutletUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUncheckedUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type EmployeeUpsertWithoutLeavesApprovedInput = {
    update: XOR<EmployeeUpdateWithoutLeavesApprovedInput, EmployeeUncheckedUpdateWithoutLeavesApprovedInput>
    create: XOR<EmployeeCreateWithoutLeavesApprovedInput, EmployeeUncheckedCreateWithoutLeavesApprovedInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeavesApprovedInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeavesApprovedInput, EmployeeUncheckedUpdateWithoutLeavesApprovedInput>
  }

  export type EmployeeUpdateWithoutLeavesApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutEmployeesNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeavesApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    role?: string
    name?: string | null
    email: string
    password: string
    phoneNumber?: string | null
    isVerified?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    role?: string
    name?: string | null
    email: string
    password: string
    phoneNumber?: string | null
    isVerified?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type OutletCreateWithoutOrdersInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleCreateNestedManyWithoutOutletInput
    employees?: EmployeeCreateNestedManyWithoutOutletInput
    attendances?: AttendanceCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutOutletInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutOutletInput
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletCreateOrConnectWithoutOrdersInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutOrdersInput, OutletUncheckedCreateWithoutOrdersInput>
  }

  export type EmployeeCreateWithoutOrdersHandledInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutEmployeesInput
    shift: ShiftCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedBy?: AttendanceCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUncheckedCreateWithoutOrdersHandledInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput
    workerTasksAssigned?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedBy?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeCreateOrConnectWithoutOrdersHandledInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutOrdersHandledInput, EmployeeUncheckedCreateWithoutOrdersHandledInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    service: ServiceCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    serviceId: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskCreateWithoutOrderInput = {
    id?: string
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignee?: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutWorkerTasksAssignedInput
    outlet: OutletCreateNestedOneWithoutTasksInput
    station?: WorkerStationCreateNestedOneWithoutTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutOrderInput = {
    id?: string
    employeeId: string
    assignedById?: string | null
    outletId: string
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutOrderInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutOrderInput, EmployeeTaskUncheckedCreateWithoutOrderInput>
  }

  export type EmployeeTaskCreateManyOrderInputEnvelope = {
    data: EmployeeTaskCreateManyOrderInput | EmployeeTaskCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OutletUpsertWithoutOrdersInput = {
    update: XOR<OutletUpdateWithoutOrdersInput, OutletUncheckedUpdateWithoutOrdersInput>
    create: XOR<OutletCreateWithoutOrdersInput, OutletUncheckedCreateWithoutOrdersInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutOrdersInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutOrdersInput, OutletUncheckedUpdateWithoutOrdersInput>
  }

  export type OutletUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutOutletNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type EmployeeUpsertWithoutOrdersHandledInput = {
    update: XOR<EmployeeUpdateWithoutOrdersHandledInput, EmployeeUncheckedUpdateWithoutOrdersHandledInput>
    create: XOR<EmployeeCreateWithoutOrdersHandledInput, EmployeeUncheckedCreateWithoutOrdersHandledInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutOrdersHandledInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutOrdersHandledInput, EmployeeUncheckedUpdateWithoutOrdersHandledInput>
  }

  export type EmployeeUpdateWithoutOrdersHandledInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutEmployeesNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedBy?: AttendanceUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutOrdersHandledInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedBy?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutOrderInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutOrderInput, EmployeeTaskUncheckedUpdateWithoutOrderInput>
    create: XOR<EmployeeTaskCreateWithoutOrderInput, EmployeeTaskUncheckedCreateWithoutOrderInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutOrderInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutOrderInput, EmployeeTaskUncheckedUpdateWithoutOrderInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutOrderInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderHeaderCreateWithoutItemsInput = {
    id?: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    outlet: OutletCreateNestedOneWithoutOrdersInput
    handledBy?: EmployeeCreateNestedOneWithoutOrdersHandledInput
    tasks?: EmployeeTaskCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderUncheckedCreateWithoutItemsInput = {
    id?: string
    customerId: string
    outletId: string
    handledById: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderCreateOrConnectWithoutItemsInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutItemsInput, OrderHeaderUncheckedCreateWithoutItemsInput>
  }

  export type ServiceCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    serviceCategoryId: string
    unit: string
    basePrice: number
    minQty: number
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceCreateOrConnectWithoutOrderItemsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutOrderItemsInput, ServiceUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderHeaderUpsertWithoutItemsInput = {
    update: XOR<OrderHeaderUpdateWithoutItemsInput, OrderHeaderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderHeaderCreateWithoutItemsInput, OrderHeaderUncheckedCreateWithoutItemsInput>
    where?: OrderHeaderWhereInput
  }

  export type OrderHeaderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderHeaderWhereInput
    data: XOR<OrderHeaderUpdateWithoutItemsInput, OrderHeaderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderHeaderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    outlet?: OutletUpdateOneRequiredWithoutOrdersNestedInput
    handledBy?: EmployeeUpdateOneWithoutOrdersHandledNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    handledById?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ServiceUpsertWithoutOrderItemsInput = {
    update: XOR<ServiceUpdateWithoutOrderItemsInput, ServiceUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ServiceCreateWithoutOrderItemsInput, ServiceUncheckedCreateWithoutOrderItemsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutOrderItemsInput, ServiceUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ServiceUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: FloatFieldUpdateOperationsInput | number
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: FloatFieldUpdateOperationsInput | number
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskCreateWithoutStationInput = {
    id?: string
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignee?: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutWorkerTasksAssignedInput
    order?: OrderHeaderCreateNestedOneWithoutTasksInput
    outlet: OutletCreateNestedOneWithoutTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutStationInput = {
    id?: string
    employeeId: string
    assignedById?: string | null
    orderId?: string | null
    outletId: string
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutStationInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutStationInput, EmployeeTaskUncheckedCreateWithoutStationInput>
  }

  export type EmployeeTaskCreateManyStationInputEnvelope = {
    data: EmployeeTaskCreateManyStationInput | EmployeeTaskCreateManyStationInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutStationInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutStationInput, EmployeeTaskUncheckedUpdateWithoutStationInput>
    create: XOR<EmployeeTaskCreateWithoutStationInput, EmployeeTaskUncheckedCreateWithoutStationInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutStationInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutStationInput, EmployeeTaskUncheckedUpdateWithoutStationInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutStationInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutStationInput>
  }

  export type EmployeeCreateWithoutWorkerTasksInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutEmployeesInput
    shift: ShiftCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    workerTasksAssigned?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUncheckedCreateWithoutWorkerTasksInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    workerTasksAssigned?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    ordersHandled?: OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeCreateOrConnectWithoutWorkerTasksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWorkerTasksInput, EmployeeUncheckedCreateWithoutWorkerTasksInput>
  }

  export type EmployeeCreateWithoutWorkerTasksAssignedInput = {
    id?: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutEmployeesInput
    shift: ShiftCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutAssigneeInput
    ordersHandled?: OrderHeaderCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeUncheckedCreateWithoutWorkerTasksAssignedInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesApproved?: LeaveRequestUncheckedCreateNestedManyWithoutApprovedByInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssigneeInput
    ordersHandled?: OrderHeaderUncheckedCreateNestedManyWithoutHandledByInput
    approvedBy?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type EmployeeCreateOrConnectWithoutWorkerTasksAssignedInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWorkerTasksAssignedInput, EmployeeUncheckedCreateWithoutWorkerTasksAssignedInput>
  }

  export type OrderHeaderCreateWithoutTasksInput = {
    id?: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    outlet: OutletCreateNestedOneWithoutOrdersInput
    handledBy?: EmployeeCreateNestedOneWithoutOrdersHandledInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderUncheckedCreateWithoutTasksInput = {
    id?: string
    customerId: string
    outletId: string
    handledById: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderHeaderCreateOrConnectWithoutTasksInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutTasksInput, OrderHeaderUncheckedCreateWithoutTasksInput>
  }

  export type OutletCreateWithoutTasksInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleCreateNestedManyWithoutOutletInput
    employees?: EmployeeCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderCreateNestedManyWithoutOutletInput
    attendances?: AttendanceCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutOutletInput
    orders?: OrderHeaderUncheckedCreateNestedManyWithoutOutletInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletCreateOrConnectWithoutTasksInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutTasksInput, OutletUncheckedCreateWithoutTasksInput>
  }

  export type WorkerStationCreateWithoutTasksInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkerStationUncheckedCreateWithoutTasksInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkerStationCreateOrConnectWithoutTasksInput = {
    where: WorkerStationWhereUniqueInput
    create: XOR<WorkerStationCreateWithoutTasksInput, WorkerStationUncheckedCreateWithoutTasksInput>
  }

  export type EmployeeUpsertWithoutWorkerTasksInput = {
    update: XOR<EmployeeUpdateWithoutWorkerTasksInput, EmployeeUncheckedUpdateWithoutWorkerTasksInput>
    create: XOR<EmployeeCreateWithoutWorkerTasksInput, EmployeeUncheckedCreateWithoutWorkerTasksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWorkerTasksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWorkerTasksInput, EmployeeUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type EmployeeUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutEmployeesNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    workerTasksAssigned?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    workerTasksAssigned?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUpsertWithoutWorkerTasksAssignedInput = {
    update: XOR<EmployeeUpdateWithoutWorkerTasksAssignedInput, EmployeeUncheckedUpdateWithoutWorkerTasksAssignedInput>
    create: XOR<EmployeeCreateWithoutWorkerTasksAssignedInput, EmployeeUncheckedCreateWithoutWorkerTasksAssignedInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWorkerTasksAssignedInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWorkerTasksAssignedInput, EmployeeUncheckedUpdateWithoutWorkerTasksAssignedInput>
  }

  export type EmployeeUpdateWithoutWorkerTasksAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutEmployeesNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutAssigneeNestedInput
    ordersHandled?: OrderHeaderUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWorkerTasksAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    ordersHandled?: OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type OrderHeaderUpsertWithoutTasksInput = {
    update: XOR<OrderHeaderUpdateWithoutTasksInput, OrderHeaderUncheckedUpdateWithoutTasksInput>
    create: XOR<OrderHeaderCreateWithoutTasksInput, OrderHeaderUncheckedCreateWithoutTasksInput>
    where?: OrderHeaderWhereInput
  }

  export type OrderHeaderUpdateToOneWithWhereWithoutTasksInput = {
    where?: OrderHeaderWhereInput
    data: XOR<OrderHeaderUpdateWithoutTasksInput, OrderHeaderUncheckedUpdateWithoutTasksInput>
  }

  export type OrderHeaderUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    outlet?: OutletUpdateOneRequiredWithoutOrdersNestedInput
    handledBy?: EmployeeUpdateOneWithoutOrdersHandledNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    handledById?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OutletUpsertWithoutTasksInput = {
    update: XOR<OutletUpdateWithoutTasksInput, OutletUncheckedUpdateWithoutTasksInput>
    create: XOR<OutletCreateWithoutTasksInput, OutletUncheckedCreateWithoutTasksInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutTasksInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutTasksInput, OutletUncheckedUpdateWithoutTasksInput>
  }

  export type OutletUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutOutletNestedInput
    orders?: OrderHeaderUncheckedUpdateManyWithoutOutletNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type WorkerStationUpsertWithoutTasksInput = {
    update: XOR<WorkerStationUpdateWithoutTasksInput, WorkerStationUncheckedUpdateWithoutTasksInput>
    create: XOR<WorkerStationCreateWithoutTasksInput, WorkerStationUncheckedCreateWithoutTasksInput>
    where?: WorkerStationWhereInput
  }

  export type WorkerStationUpdateToOneWithWhereWithoutTasksInput = {
    where?: WorkerStationWhereInput
    data: XOR<WorkerStationUpdateWithoutTasksInput, WorkerStationUncheckedUpdateWithoutTasksInput>
  }

  export type WorkerStationUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerStationUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerAddressCreateManyCustomerInput = {
    id?: string
    label?: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderHeaderCreateManyCustomerInput = {
    id?: string
    outletId: string
    handledById: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerAddressUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerAddressUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutOrdersNestedInput
    handledBy?: EmployeeUpdateOneWithoutOrdersHandledNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    handledById?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    handledById?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCreateManyCategoryInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: FloatFieldUpdateOperationsInput | number
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItems?: OrderItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: FloatFieldUpdateOperationsInput | number
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: FloatFieldUpdateOperationsInput | number
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateManyServiceInput = {
    id?: string
    orderId: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderHeaderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleCreateManyOutletInput = {
    id?: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeCreateManyOutletInput = {
    id?: string
    shiftId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderHeaderCreateManyOutletInput = {
    id?: string
    customerId: string
    handledById: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateManyOutletInput = {
    id?: string
    employeeId: string
    shiftId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateManyOutletInput = {
    id?: string
    employeeId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedById?: string | null
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateManyOutletInput = {
    id?: string
    employeeId: string
    assignedById?: string | null
    orderId?: string | null
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shift?: ShiftUpdateOneRequiredWithoutEmployeesNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    handledBy?: EmployeeUpdateOneWithoutOrdersHandledNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAttendancesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutAttendancesNestedInput
    approvedBy?: EmployeeUpdateOneWithoutApprovedByNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
    approvedBy?: EmployeeUpdateOneWithoutLeavesApprovedNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignee?: EmployeeUpdateOneWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutWorkerTasksAssignedNestedInput
    order?: OrderHeaderUpdateOneWithoutTasksNestedInput
    station?: WorkerStationUpdateOneWithoutTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateManyEmployeeInput = {
    id?: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateManyEmployeeInput = {
    id?: string
    outletId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedById?: string | null
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateManyApprovedByInput = {
    id?: string
    employeeId: string
    outletId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveReqStat
    approvedAt?: Date | string | null
    notes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateManyAssigneeInput = {
    id?: string
    assignedById?: string | null
    orderId?: string | null
    outletId: string
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateManyAssignedByInput = {
    id?: string
    employeeId: string
    orderId?: string | null
    outletId: string
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderHeaderCreateManyHandledByInput = {
    id?: string
    customerId: string
    outletId: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt?: Date | string | null
    deliveryAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateManyApprovedByInput = {
    id?: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shift?: ShiftUpdateOneRequiredWithoutAttendancesNestedInput
    outlet?: OutletUpdateOneRequiredWithoutAttendancesNestedInput
    approvedBy?: EmployeeUpdateOneWithoutApprovedByNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutLeavesNestedInput
    approvedBy?: EmployeeUpdateOneWithoutLeavesApprovedNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
    outlet?: OutletUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveReqStatFieldUpdateOperationsInput | $Enums.LeaveReqStat
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedBy?: EmployeeUpdateOneWithoutWorkerTasksAssignedNestedInput
    order?: OrderHeaderUpdateOneWithoutTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutTasksNestedInput
    station?: WorkerStationUpdateOneWithoutTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignee?: EmployeeUpdateOneWithoutWorkerTasksNestedInput
    order?: OrderHeaderUpdateOneWithoutTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutTasksNestedInput
    station?: WorkerStationUpdateOneWithoutTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderUpdateWithoutHandledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    outlet?: OutletUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    tasks?: EmployeeTaskUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutHandledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    tasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderHeaderUncheckedUpdateManyWithoutHandledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAttendancesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutAttendancesNestedInput
    outlet?: OutletUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateManyShiftInput = {
    id?: string
    outletId: string
    role: $Enums.EmployeeRole
    name: string
    email: string
    password: string
    phoneNumber: string
    address: string
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateManyShiftInput = {
    id?: string
    employeeId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutEmployeesNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesApproved?: LeaveRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    workerTasksAssigned?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    ordersHandled?: OrderHeaderUncheckedUpdateManyWithoutHandledByNestedInput
    approvedBy?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    role?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAttendancesNestedInput
    outlet?: OutletUpdateOneRequiredWithoutAttendancesNestedInput
    approvedBy?: EmployeeUpdateOneWithoutApprovedByNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    serviceId: string
    qty: number
    note: string
    unitPrice: number
    subTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateManyOrderInput = {
    id?: string
    employeeId: string
    assignedById?: string | null
    outletId: string
    workStationId?: string | null
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service?: ServiceUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignee?: EmployeeUpdateOneWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutWorkerTasksAssignedNestedInput
    outlet?: OutletUpdateOneRequiredWithoutTasksNestedInput
    station?: WorkerStationUpdateOneWithoutTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskCreateManyStationInput = {
    id?: string
    employeeId: string
    assignedById?: string | null
    orderId?: string | null
    outletId: string
    type: $Enums.Station
    status?: $Enums.TaskStatus
    startAt?: Date | string | null
    finishedAt?: Date | string | null
    qty?: number | null
    isApproved?: boolean | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskUpdateWithoutStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignee?: EmployeeUpdateOneWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutWorkerTasksAssignedNestedInput
    order?: OrderHeaderUpdateOneWithoutTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    type?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    isApproved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}