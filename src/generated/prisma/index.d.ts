
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerAddress
 * 
 */
export type CustomerAddress = $Result.DefaultSelection<Prisma.$CustomerAddressPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model WorkStation
 * 
 */
export type WorkStation = $Result.DefaultSelection<Prisma.$WorkStationPayload>
/**
 * Model EmployeeTask
 * 
 */
export type EmployeeTask = $Result.DefaultSelection<Prisma.$EmployeeTaskPayload>
/**
 * Model PickUpTask
 * 
 */
export type PickUpTask = $Result.DefaultSelection<Prisma.$PickUpTaskPayload>
/**
 * Model DeliveryTask
 * 
 */
export type DeliveryTask = $Result.DefaultSelection<Prisma.$DeliveryTaskPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Outlet
 * 
 */
export type Outlet = $Result.DefaultSelection<Prisma.$OutletPayload>
/**
 * Model OutletSchedule
 * 
 */
export type OutletSchedule = $Result.DefaultSelection<Prisma.$OutletSchedulePayload>
/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = $Result.DefaultSelection<Prisma.$ServiceCategoryPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model OrderHeader
 * 
 */
export type OrderHeader = $Result.DefaultSelection<Prisma.$OrderHeaderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  CUSTOMER: 'CUSTOMER',
  SUPER_ADMIN: 'SUPER_ADMIN',
  OUTLET_ADMIN: 'OUTLET_ADMIN',
  DRIVER: 'DRIVER',
  WORKER: 'WORKER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EARLY_LEAVE: 'EARLY_LEAVE',
  ON_LEAVE: 'ON_LEAVE',
  SICK: 'SICK',
  HOLIDAY: 'HOLIDAY'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const OrderStatus: {
  WAITING_FOR_CONFIRMATION: 'WAITING_FOR_CONFIRMATION',
  WAITING_FOR_DRIVER_PICKUP: 'WAITING_FOR_DRIVER_PICKUP',
  ON_THE_WAY_TO_OUTLET: 'ON_THE_WAY_TO_OUTLET',
  ARRIVED_AT_OUTLET: 'ARRIVED_AT_OUTLET',
  WASHING_IN_PROGRESS: 'WASHING_IN_PROGRESS',
  IRONING_IN_PROGRESS: 'IRONING_IN_PROGRESS',
  PACKING_IN_PROGRESS: 'PACKING_IN_PROGRESS',
  WAITING_FOR_PAYMENT: 'WAITING_FOR_PAYMENT',
  READY_FOR_DELIVERY: 'READY_FOR_DELIVERY',
  OUT_FOR_DELIVERY: 'OUT_FOR_DELIVERY',
  DELIVERED_TO_CUSTOMER: 'DELIVERED_TO_CUSTOMER'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  DEBIT: 'DEBIT',
  CREDIT: 'CREDIT',
  BANK_TRANSFER: 'BANK_TRANSFER',
  QRIS: 'QRIS',
  E_WALLET: 'E_WALLET'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const Station: {
  WASHING: 'WASHING',
  IRONING: 'IRONING',
  PACKING: 'PACKING',
  QA: 'QA',
  ADMIN: 'ADMIN'
};

export type Station = (typeof Station)[keyof typeof Station]


export const PaymentStatus: {
  WAITING: 'WAITING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED',
  CANCELED: 'CANCELED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const TaskStatus: {
  PENDING: 'PENDING',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  ON_HOLD: 'ON_HOLD',
  DONE: 'DONE',
  CANCELLED: 'CANCELLED',
  REJECTED: 'REJECTED',
  REQUEST_BYPASS: 'REQUEST_BYPASS'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Label: {
  HOME: 'HOME',
  OFFICE: 'OFFICE',
  APARTMENT: 'APARTMENT',
  OTHER: 'OTHER'
};

export type Label = (typeof Label)[keyof typeof Label]


export const OAuthProvider: {
  GOOGLE: 'GOOGLE',
  FACEBOOK: 'FACEBOOK',
  TWITTER: 'TWITTER',
  APPLE: 'APPLE',
  GITHUB: 'GITHUB',
  OTHER: 'OTHER'
};

export type OAuthProvider = (typeof OAuthProvider)[keyof typeof OAuthProvider]


export const PickupStatus: {
  WAITING_FOR_DRIVER: 'WAITING_FOR_DRIVER',
  ON_THE_WAY_TO_CUSTOMER: 'ON_THE_WAY_TO_CUSTOMER',
  ON_THE_WAY_TO_OUTLET: 'ON_THE_WAY_TO_OUTLET',
  RECEIVED_BY_OUTLET: 'RECEIVED_BY_OUTLET'
};

export type PickupStatus = (typeof PickupStatus)[keyof typeof PickupStatus]


export const DeilveryStatus: {
  NOT_READY_TO_DELIVER: 'NOT_READY_TO_DELIVER',
  WAITING_FOR_DRIVER: 'WAITING_FOR_DRIVER',
  ON_THE_WAY_TO_OUTLET: 'ON_THE_WAY_TO_OUTLET',
  ON_THE_WAY_TO_CUSTOMER: 'ON_THE_WAY_TO_CUSTOMER',
  RECEIVED_BY_CUSTOMER: 'RECEIVED_BY_CUSTOMER'
};

export type DeilveryStatus = (typeof DeilveryStatus)[keyof typeof DeilveryStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type Station = $Enums.Station

export const Station: typeof $Enums.Station

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type Label = $Enums.Label

export const Label: typeof $Enums.Label

export type OAuthProvider = $Enums.OAuthProvider

export const OAuthProvider: typeof $Enums.OAuthProvider

export type PickupStatus = $Enums.PickupStatus

export const PickupStatus: typeof $Enums.PickupStatus

export type DeilveryStatus = $Enums.DeilveryStatus

export const DeilveryStatus: typeof $Enums.DeilveryStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerAddress`: Exposes CRUD operations for the **CustomerAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerAddresses
    * const customerAddresses = await prisma.customerAddress.findMany()
    * ```
    */
  get customerAddress(): Prisma.CustomerAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workStation`: Exposes CRUD operations for the **WorkStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkStations
    * const workStations = await prisma.workStation.findMany()
    * ```
    */
  get workStation(): Prisma.WorkStationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeTask`: Exposes CRUD operations for the **EmployeeTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeTasks
    * const employeeTasks = await prisma.employeeTask.findMany()
    * ```
    */
  get employeeTask(): Prisma.EmployeeTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pickUpTask`: Exposes CRUD operations for the **PickUpTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PickUpTasks
    * const pickUpTasks = await prisma.pickUpTask.findMany()
    * ```
    */
  get pickUpTask(): Prisma.PickUpTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryTask`: Exposes CRUD operations for the **DeliveryTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryTasks
    * const deliveryTasks = await prisma.deliveryTask.findMany()
    * ```
    */
  get deliveryTask(): Prisma.DeliveryTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outlet`: Exposes CRUD operations for the **Outlet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Outlets
    * const outlets = await prisma.outlet.findMany()
    * ```
    */
  get outlet(): Prisma.OutletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outletSchedule`: Exposes CRUD operations for the **OutletSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutletSchedules
    * const outletSchedules = await prisma.outletSchedule.findMany()
    * ```
    */
  get outletSchedule(): Prisma.OutletScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderHeader`: Exposes CRUD operations for the **OrderHeader** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderHeaders
    * const orderHeaders = await prisma.orderHeader.findMany()
    * ```
    */
  get orderHeader(): Prisma.OrderHeaderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    CustomerAddress: 'CustomerAddress',
    Employee: 'Employee',
    Shift: 'Shift',
    WorkStation: 'WorkStation',
    EmployeeTask: 'EmployeeTask',
    PickUpTask: 'PickUpTask',
    DeliveryTask: 'DeliveryTask',
    Attendance: 'Attendance',
    Outlet: 'Outlet',
    OutletSchedule: 'OutletSchedule',
    ServiceCategory: 'ServiceCategory',
    Service: 'Service',
    OrderHeader: 'OrderHeader',
    OrderItem: 'OrderItem',
    Payment: 'Payment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "customer" | "customerAddress" | "employee" | "shift" | "workStation" | "employeeTask" | "pickUpTask" | "deliveryTask" | "attendance" | "outlet" | "outletSchedule" | "serviceCategory" | "service" | "orderHeader" | "orderItem" | "payment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerAddress: {
        payload: Prisma.$CustomerAddressPayload<ExtArgs>
        fields: Prisma.CustomerAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findFirst: {
            args: Prisma.CustomerAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findMany: {
            args: Prisma.CustomerAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          create: {
            args: Prisma.CustomerAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          createMany: {
            args: Prisma.CustomerAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          delete: {
            args: Prisma.CustomerAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          update: {
            args: Prisma.CustomerAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          deleteMany: {
            args: Prisma.CustomerAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          upsert: {
            args: Prisma.CustomerAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          aggregate: {
            args: Prisma.CustomerAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerAddress>
          }
          groupBy: {
            args: Prisma.CustomerAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerAddressCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      WorkStation: {
        payload: Prisma.$WorkStationPayload<ExtArgs>
        fields: Prisma.WorkStationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkStationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkStationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload>
          }
          findFirst: {
            args: Prisma.WorkStationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkStationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload>
          }
          findMany: {
            args: Prisma.WorkStationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload>[]
          }
          create: {
            args: Prisma.WorkStationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload>
          }
          createMany: {
            args: Prisma.WorkStationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkStationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload>[]
          }
          delete: {
            args: Prisma.WorkStationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload>
          }
          update: {
            args: Prisma.WorkStationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload>
          }
          deleteMany: {
            args: Prisma.WorkStationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkStationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkStationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload>[]
          }
          upsert: {
            args: Prisma.WorkStationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStationPayload>
          }
          aggregate: {
            args: Prisma.WorkStationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkStation>
          }
          groupBy: {
            args: Prisma.WorkStationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkStationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkStationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkStationCountAggregateOutputType> | number
          }
        }
      }
      EmployeeTask: {
        payload: Prisma.$EmployeeTaskPayload<ExtArgs>
        fields: Prisma.EmployeeTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          findFirst: {
            args: Prisma.EmployeeTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          findMany: {
            args: Prisma.EmployeeTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>[]
          }
          create: {
            args: Prisma.EmployeeTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          createMany: {
            args: Prisma.EmployeeTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>[]
          }
          delete: {
            args: Prisma.EmployeeTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          update: {
            args: Prisma.EmployeeTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeTaskPayload>
          }
          aggregate: {
            args: Prisma.EmployeeTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeTask>
          }
          groupBy: {
            args: Prisma.EmployeeTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeTaskCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeTaskCountAggregateOutputType> | number
          }
        }
      }
      PickUpTask: {
        payload: Prisma.$PickUpTaskPayload<ExtArgs>
        fields: Prisma.PickUpTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PickUpTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PickUpTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload>
          }
          findFirst: {
            args: Prisma.PickUpTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PickUpTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload>
          }
          findMany: {
            args: Prisma.PickUpTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload>[]
          }
          create: {
            args: Prisma.PickUpTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload>
          }
          createMany: {
            args: Prisma.PickUpTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PickUpTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload>[]
          }
          delete: {
            args: Prisma.PickUpTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload>
          }
          update: {
            args: Prisma.PickUpTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload>
          }
          deleteMany: {
            args: Prisma.PickUpTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PickUpTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PickUpTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload>[]
          }
          upsert: {
            args: Prisma.PickUpTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickUpTaskPayload>
          }
          aggregate: {
            args: Prisma.PickUpTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePickUpTask>
          }
          groupBy: {
            args: Prisma.PickUpTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<PickUpTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.PickUpTaskCountArgs<ExtArgs>
            result: $Utils.Optional<PickUpTaskCountAggregateOutputType> | number
          }
        }
      }
      DeliveryTask: {
        payload: Prisma.$DeliveryTaskPayload<ExtArgs>
        fields: Prisma.DeliveryTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload>
          }
          findFirst: {
            args: Prisma.DeliveryTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload>
          }
          findMany: {
            args: Prisma.DeliveryTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload>[]
          }
          create: {
            args: Prisma.DeliveryTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload>
          }
          createMany: {
            args: Prisma.DeliveryTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload>[]
          }
          delete: {
            args: Prisma.DeliveryTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload>
          }
          update: {
            args: Prisma.DeliveryTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTaskPayload>
          }
          aggregate: {
            args: Prisma.DeliveryTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryTask>
          }
          groupBy: {
            args: Prisma.DeliveryTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryTaskCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTaskCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Outlet: {
        payload: Prisma.$OutletPayload<ExtArgs>
        fields: Prisma.OutletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          findFirst: {
            args: Prisma.OutletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          findMany: {
            args: Prisma.OutletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>[]
          }
          create: {
            args: Prisma.OutletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          createMany: {
            args: Prisma.OutletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>[]
          }
          delete: {
            args: Prisma.OutletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          update: {
            args: Prisma.OutletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          deleteMany: {
            args: Prisma.OutletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>[]
          }
          upsert: {
            args: Prisma.OutletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          aggregate: {
            args: Prisma.OutletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutlet>
          }
          groupBy: {
            args: Prisma.OutletGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutletGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutletCountArgs<ExtArgs>
            result: $Utils.Optional<OutletCountAggregateOutputType> | number
          }
        }
      }
      OutletSchedule: {
        payload: Prisma.$OutletSchedulePayload<ExtArgs>
        fields: Prisma.OutletScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutletScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutletScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          findFirst: {
            args: Prisma.OutletScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutletScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          findMany: {
            args: Prisma.OutletScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>[]
          }
          create: {
            args: Prisma.OutletScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          createMany: {
            args: Prisma.OutletScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutletScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>[]
          }
          delete: {
            args: Prisma.OutletScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          update: {
            args: Prisma.OutletScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          deleteMany: {
            args: Prisma.OutletScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutletScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutletScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>[]
          }
          upsert: {
            args: Prisma.OutletScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletSchedulePayload>
          }
          aggregate: {
            args: Prisma.OutletScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutletSchedule>
          }
          groupBy: {
            args: Prisma.OutletScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutletScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutletScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<OutletScheduleCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: Prisma.$ServiceCategoryPayload<ExtArgs>
        fields: Prisma.ServiceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      OrderHeader: {
        payload: Prisma.$OrderHeaderPayload<ExtArgs>
        fields: Prisma.OrderHeaderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderHeaderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderHeaderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          findFirst: {
            args: Prisma.OrderHeaderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderHeaderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          findMany: {
            args: Prisma.OrderHeaderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>[]
          }
          create: {
            args: Prisma.OrderHeaderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          createMany: {
            args: Prisma.OrderHeaderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderHeaderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>[]
          }
          delete: {
            args: Prisma.OrderHeaderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          update: {
            args: Prisma.OrderHeaderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          deleteMany: {
            args: Prisma.OrderHeaderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderHeaderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderHeaderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>[]
          }
          upsert: {
            args: Prisma.OrderHeaderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHeaderPayload>
          }
          aggregate: {
            args: Prisma.OrderHeaderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderHeader>
          }
          groupBy: {
            args: Prisma.OrderHeaderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderHeaderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderHeaderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderHeaderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customer?: CustomerOmit
    customerAddress?: CustomerAddressOmit
    employee?: EmployeeOmit
    shift?: ShiftOmit
    workStation?: WorkStationOmit
    employeeTask?: EmployeeTaskOmit
    pickUpTask?: PickUpTaskOmit
    deliveryTask?: DeliveryTaskOmit
    attendance?: AttendanceOmit
    outlet?: OutletOmit
    outletSchedule?: OutletScheduleOmit
    serviceCategory?: ServiceCategoryOmit
    service?: ServiceOmit
    orderHeader?: OrderHeaderOmit
    orderItem?: OrderItemOmit
    payment?: PaymentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    customerAddress: number
    orderHeader: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerAddress?: boolean | CustomerCountOutputTypeCountCustomerAddressArgs
    orderHeader?: boolean | CustomerCountOutputTypeCountOrderHeaderArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrderHeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHeaderWhereInput
  }


  /**
   * Count Type CustomerAddressCountOutputType
   */

  export type CustomerAddressCountOutputType = {
    PickUpTask: number
    DeliveryTask: number
  }

  export type CustomerAddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PickUpTask?: boolean | CustomerAddressCountOutputTypeCountPickUpTaskArgs
    DeliveryTask?: boolean | CustomerAddressCountOutputTypeCountDeliveryTaskArgs
  }

  // Custom InputTypes
  /**
   * CustomerAddressCountOutputType without action
   */
  export type CustomerAddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddressCountOutputType
     */
    select?: CustomerAddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerAddressCountOutputType without action
   */
  export type CustomerAddressCountOutputTypeCountPickUpTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickUpTaskWhereInput
  }

  /**
   * CustomerAddressCountOutputType without action
   */
  export type CustomerAddressCountOutputTypeCountDeliveryTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTaskWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    Attendance: number
    orderHeader: number
    WorkStation: number
    workerTasks: number
    assignedTasks: number
    approvedAttendances: number
    pickUpDriver: number
    pickupAssignedBy: number
    deliveryDriver: number
    deliveryAssignedBy: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Attendance?: boolean | EmployeeCountOutputTypeCountAttendanceArgs
    orderHeader?: boolean | EmployeeCountOutputTypeCountOrderHeaderArgs
    WorkStation?: boolean | EmployeeCountOutputTypeCountWorkStationArgs
    workerTasks?: boolean | EmployeeCountOutputTypeCountWorkerTasksArgs
    assignedTasks?: boolean | EmployeeCountOutputTypeCountAssignedTasksArgs
    approvedAttendances?: boolean | EmployeeCountOutputTypeCountApprovedAttendancesArgs
    pickUpDriver?: boolean | EmployeeCountOutputTypeCountPickUpDriverArgs
    pickupAssignedBy?: boolean | EmployeeCountOutputTypeCountPickupAssignedByArgs
    deliveryDriver?: boolean | EmployeeCountOutputTypeCountDeliveryDriverArgs
    deliveryAssignedBy?: boolean | EmployeeCountOutputTypeCountDeliveryAssignedByArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountOrderHeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHeaderWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWorkStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkStationWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWorkerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountApprovedAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPickUpDriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickUpTaskWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPickupAssignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickUpTaskWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDeliveryDriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTaskWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDeliveryAssignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTaskWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    Employee: number
    Attendance: number
    workerTasks: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | ShiftCountOutputTypeCountEmployeeArgs
    Attendance?: boolean | ShiftCountOutputTypeCountAttendanceArgs
    workerTasks?: boolean | ShiftCountOutputTypeCountWorkerTasksArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountWorkerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }


  /**
   * Count Type WorkStationCountOutputType
   */

  export type WorkStationCountOutputType = {
    workerTasks: number
  }

  export type WorkStationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workerTasks?: boolean | WorkStationCountOutputTypeCountWorkerTasksArgs
  }

  // Custom InputTypes
  /**
   * WorkStationCountOutputType without action
   */
  export type WorkStationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStationCountOutputType
     */
    select?: WorkStationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkStationCountOutputType without action
   */
  export type WorkStationCountOutputTypeCountWorkerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }


  /**
   * Count Type OutletCountOutputType
   */

  export type OutletCountOutputType = {
    Employee: number
    Attendance: number
    OutletSchedule: number
    orderHeader: number
    workerTasks: number
    PickUpTask: number
    DeliveryTask: number
  }

  export type OutletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | OutletCountOutputTypeCountEmployeeArgs
    Attendance?: boolean | OutletCountOutputTypeCountAttendanceArgs
    OutletSchedule?: boolean | OutletCountOutputTypeCountOutletScheduleArgs
    orderHeader?: boolean | OutletCountOutputTypeCountOrderHeaderArgs
    workerTasks?: boolean | OutletCountOutputTypeCountWorkerTasksArgs
    PickUpTask?: boolean | OutletCountOutputTypeCountPickUpTaskArgs
    DeliveryTask?: boolean | OutletCountOutputTypeCountDeliveryTaskArgs
  }

  // Custom InputTypes
  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletCountOutputType
     */
    select?: OutletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountOutletScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutletScheduleWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountOrderHeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHeaderWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountWorkerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountPickUpTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickUpTaskWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountDeliveryTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTaskWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    Service: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Service?: boolean | ServiceCategoryCountOutputTypeCountServiceArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    OrderItem: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItem?: boolean | ServiceCountOutputTypeCountOrderItemArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type OrderHeaderCountOutputType
   */

  export type OrderHeaderCountOutputType = {
    OrderItem: number
    Payment: number
    workerTasks: number
    PickUpTask: number
    DeliveryTask: number
  }

  export type OrderHeaderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItem?: boolean | OrderHeaderCountOutputTypeCountOrderItemArgs
    Payment?: boolean | OrderHeaderCountOutputTypeCountPaymentArgs
    workerTasks?: boolean | OrderHeaderCountOutputTypeCountWorkerTasksArgs
    PickUpTask?: boolean | OrderHeaderCountOutputTypeCountPickUpTaskArgs
    DeliveryTask?: boolean | OrderHeaderCountOutputTypeCountDeliveryTaskArgs
  }

  // Custom InputTypes
  /**
   * OrderHeaderCountOutputType without action
   */
  export type OrderHeaderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeaderCountOutputType
     */
    select?: OrderHeaderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderHeaderCountOutputType without action
   */
  export type OrderHeaderCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderHeaderCountOutputType without action
   */
  export type OrderHeaderCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * OrderHeaderCountOutputType without action
   */
  export type OrderHeaderCountOutputTypeCountWorkerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }

  /**
   * OrderHeaderCountOutputType without action
   */
  export type OrderHeaderCountOutputTypeCountPickUpTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickUpTaskWhereInput
  }

  /**
   * OrderHeaderCountOutputType without action
   */
  export type OrderHeaderCountOutputTypeCountDeliveryTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTaskWhereInput
  }


  /**
   * Count Type OrderItemCountOutputType
   */

  export type OrderItemCountOutputType = {
    workerTasks: number
  }

  export type OrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workerTasks?: boolean | OrderItemCountOutputTypeCountWorkerTasksArgs
  }

  // Custom InputTypes
  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemCountOutputType
     */
    select?: OrderItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountWorkerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    photoUrl: string | null
    isVerified: boolean | null
    selectProvider: $Enums.OAuthProvider | null
    resetPasswordToken: string | null
    resetPasswordTokenExpiresAt: Date | null
    verifyToken: string | null
    verifyTokenExpiresAt: Date | null
    pendingEmail: string | null
    pendingEmailToken: string | null
    pendingEmailTokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    photoUrl: string | null
    isVerified: boolean | null
    selectProvider: $Enums.OAuthProvider | null
    resetPasswordToken: string | null
    resetPasswordTokenExpiresAt: Date | null
    verifyToken: string | null
    verifyTokenExpiresAt: Date | null
    pendingEmail: string | null
    pendingEmailToken: string | null
    pendingEmailTokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    role: number
    name: number
    email: number
    password: number
    phoneNumber: number
    photoUrl: number
    isVerified: number
    selectProvider: number
    resetPasswordToken: number
    resetPasswordTokenExpiresAt: number
    verifyToken: number
    verifyTokenExpiresAt: number
    pendingEmail: number
    pendingEmailToken: number
    pendingEmailTokenExpiresAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    photoUrl?: true
    isVerified?: true
    selectProvider?: true
    resetPasswordToken?: true
    resetPasswordTokenExpiresAt?: true
    verifyToken?: true
    verifyTokenExpiresAt?: true
    pendingEmail?: true
    pendingEmailToken?: true
    pendingEmailTokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    photoUrl?: true
    isVerified?: true
    selectProvider?: true
    resetPasswordToken?: true
    resetPasswordTokenExpiresAt?: true
    verifyToken?: true
    verifyTokenExpiresAt?: true
    pendingEmail?: true
    pendingEmailToken?: true
    pendingEmailTokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    photoUrl?: true
    isVerified?: true
    selectProvider?: true
    resetPasswordToken?: true
    resetPasswordTokenExpiresAt?: true
    verifyToken?: true
    verifyTokenExpiresAt?: true
    pendingEmail?: true
    pendingEmailToken?: true
    pendingEmailTokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    role: $Enums.Role
    name: string | null
    email: string
    password: string | null
    phoneNumber: string | null
    photoUrl: string | null
    isVerified: boolean
    selectProvider: $Enums.OAuthProvider | null
    resetPasswordToken: string | null
    resetPasswordTokenExpiresAt: Date | null
    verifyToken: string | null
    verifyTokenExpiresAt: Date | null
    pendingEmail: string | null
    pendingEmailToken: string | null
    pendingEmailTokenExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    photoUrl?: boolean
    isVerified?: boolean
    selectProvider?: boolean
    resetPasswordToken?: boolean
    resetPasswordTokenExpiresAt?: boolean
    verifyToken?: boolean
    verifyTokenExpiresAt?: boolean
    pendingEmail?: boolean
    pendingEmailToken?: boolean
    pendingEmailTokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customerAddress?: boolean | Customer$customerAddressArgs<ExtArgs>
    orderHeader?: boolean | Customer$orderHeaderArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    photoUrl?: boolean
    isVerified?: boolean
    selectProvider?: boolean
    resetPasswordToken?: boolean
    resetPasswordTokenExpiresAt?: boolean
    verifyToken?: boolean
    verifyTokenExpiresAt?: boolean
    pendingEmail?: boolean
    pendingEmailToken?: boolean
    pendingEmailTokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    photoUrl?: boolean
    isVerified?: boolean
    selectProvider?: boolean
    resetPasswordToken?: boolean
    resetPasswordTokenExpiresAt?: boolean
    verifyToken?: boolean
    verifyTokenExpiresAt?: boolean
    pendingEmail?: boolean
    pendingEmailToken?: boolean
    pendingEmailTokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    photoUrl?: boolean
    isVerified?: boolean
    selectProvider?: boolean
    resetPasswordToken?: boolean
    resetPasswordTokenExpiresAt?: boolean
    verifyToken?: boolean
    verifyTokenExpiresAt?: boolean
    pendingEmail?: boolean
    pendingEmailToken?: boolean
    pendingEmailTokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "name" | "email" | "password" | "phoneNumber" | "photoUrl" | "isVerified" | "selectProvider" | "resetPasswordToken" | "resetPasswordTokenExpiresAt" | "verifyToken" | "verifyTokenExpiresAt" | "pendingEmail" | "pendingEmailToken" | "pendingEmailTokenExpiresAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerAddress?: boolean | Customer$customerAddressArgs<ExtArgs>
    orderHeader?: boolean | Customer$orderHeaderArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      customerAddress: Prisma.$CustomerAddressPayload<ExtArgs>[]
      orderHeader: Prisma.$OrderHeaderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.Role
      name: string | null
      email: string
      password: string | null
      phoneNumber: string | null
      photoUrl: string | null
      isVerified: boolean
      selectProvider: $Enums.OAuthProvider | null
      resetPasswordToken: string | null
      resetPasswordTokenExpiresAt: Date | null
      verifyToken: string | null
      verifyTokenExpiresAt: Date | null
      pendingEmail: string | null
      pendingEmailToken: string | null
      pendingEmailTokenExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerAddress<T extends Customer$customerAddressArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerAddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderHeader<T extends Customer$orderHeaderArgs<ExtArgs> = {}>(args?: Subset<T, Customer$orderHeaderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly role: FieldRef<"Customer", 'Role'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly password: FieldRef<"Customer", 'String'>
    readonly phoneNumber: FieldRef<"Customer", 'String'>
    readonly photoUrl: FieldRef<"Customer", 'String'>
    readonly isVerified: FieldRef<"Customer", 'Boolean'>
    readonly selectProvider: FieldRef<"Customer", 'OAuthProvider'>
    readonly resetPasswordToken: FieldRef<"Customer", 'String'>
    readonly resetPasswordTokenExpiresAt: FieldRef<"Customer", 'DateTime'>
    readonly verifyToken: FieldRef<"Customer", 'String'>
    readonly verifyTokenExpiresAt: FieldRef<"Customer", 'DateTime'>
    readonly pendingEmail: FieldRef<"Customer", 'String'>
    readonly pendingEmailToken: FieldRef<"Customer", 'String'>
    readonly pendingEmailTokenExpiresAt: FieldRef<"Customer", 'DateTime'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly deletedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.customerAddress
   */
  export type Customer$customerAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    cursor?: CustomerAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * Customer.orderHeader
   */
  export type Customer$orderHeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    where?: OrderHeaderWhereInput
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    cursor?: OrderHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerAddress
   */

  export type AggregateCustomerAddress = {
    _count: CustomerAddressCountAggregateOutputType | null
    _avg: CustomerAddressAvgAggregateOutputType | null
    _sum: CustomerAddressSumAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  export type CustomerAddressAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CustomerAddressSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CustomerAddressMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    label: $Enums.Label | null
    address: string | null
    city: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    notes: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerAddressMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    label: $Enums.Label | null
    address: string | null
    city: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    notes: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerAddressCountAggregateOutputType = {
    id: number
    customerId: number
    label: number
    address: number
    city: number
    postalCode: number
    latitude: number
    longitude: number
    notes: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CustomerAddressAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CustomerAddressSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CustomerAddressMinAggregateInputType = {
    id?: true
    customerId?: true
    label?: true
    address?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    notes?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerAddressMaxAggregateInputType = {
    id?: true
    customerId?: true
    label?: true
    address?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    notes?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerAddressCountAggregateInputType = {
    id?: true
    customerId?: true
    label?: true
    address?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    notes?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CustomerAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddress to aggregate.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerAddresses
    **/
    _count?: true | CustomerAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type GetCustomerAddressAggregateType<T extends CustomerAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerAddress[P]>
      : GetScalarType<T[P], AggregateCustomerAddress[P]>
  }




  export type CustomerAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithAggregationInput | CustomerAddressOrderByWithAggregationInput[]
    by: CustomerAddressScalarFieldEnum[] | CustomerAddressScalarFieldEnum
    having?: CustomerAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerAddressCountAggregateInputType | true
    _avg?: CustomerAddressAvgAggregateInputType
    _sum?: CustomerAddressSumAggregateInputType
    _min?: CustomerAddressMinAggregateInputType
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type CustomerAddressGroupByOutputType = {
    id: string
    customerId: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes: string | null
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CustomerAddressCountAggregateOutputType | null
    _avg: CustomerAddressAvgAggregateOutputType | null
    _sum: CustomerAddressSumAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  type GetCustomerAddressGroupByPayload<T extends CustomerAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
        }
      >
    >


  export type CustomerAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    label?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    PickUpTask?: boolean | CustomerAddress$PickUpTaskArgs<ExtArgs>
    DeliveryTask?: boolean | CustomerAddress$DeliveryTaskArgs<ExtArgs>
    _count?: boolean | CustomerAddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    label?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    label?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectScalar = {
    id?: boolean
    customerId?: boolean
    label?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CustomerAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "label" | "address" | "city" | "postalCode" | "latitude" | "longitude" | "notes" | "isPrimary" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["customerAddress"]>
  export type CustomerAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    PickUpTask?: boolean | CustomerAddress$PickUpTaskArgs<ExtArgs>
    DeliveryTask?: boolean | CustomerAddress$DeliveryTaskArgs<ExtArgs>
    _count?: boolean | CustomerAddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerAddress"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>
      PickUpTask: Prisma.$PickUpTaskPayload<ExtArgs>[]
      DeliveryTask: Prisma.$DeliveryTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      label: $Enums.Label
      address: string
      city: string
      postalCode: string
      latitude: number
      longitude: number
      notes: string | null
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["customerAddress"]>
    composites: {}
  }

  type CustomerAddressGetPayload<S extends boolean | null | undefined | CustomerAddressDefaultArgs> = $Result.GetResult<Prisma.$CustomerAddressPayload, S>

  type CustomerAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerAddressCountAggregateInputType | true
    }

  export interface CustomerAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerAddress'], meta: { name: 'CustomerAddress' } }
    /**
     * Find zero or one CustomerAddress that matches the filter.
     * @param {CustomerAddressFindUniqueArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerAddressFindUniqueArgs>(args: SelectSubset<T, CustomerAddressFindUniqueArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerAddressFindUniqueOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerAddressFindFirstArgs>(args?: SelectSubset<T, CustomerAddressFindFirstArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany()
     * 
     * // Get first 10 CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerAddressFindManyArgs>(args?: SelectSubset<T, CustomerAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerAddress.
     * @param {CustomerAddressCreateArgs} args - Arguments to create a CustomerAddress.
     * @example
     * // Create one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.create({
     *   data: {
     *     // ... data to create a CustomerAddress
     *   }
     * })
     * 
     */
    create<T extends CustomerAddressCreateArgs>(args: SelectSubset<T, CustomerAddressCreateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerAddresses.
     * @param {CustomerAddressCreateManyArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerAddressCreateManyArgs>(args?: SelectSubset<T, CustomerAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerAddresses and returns the data saved in the database.
     * @param {CustomerAddressCreateManyAndReturnArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerAddress.
     * @param {CustomerAddressDeleteArgs} args - Arguments to delete one CustomerAddress.
     * @example
     * // Delete one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.delete({
     *   where: {
     *     // ... filter to delete one CustomerAddress
     *   }
     * })
     * 
     */
    delete<T extends CustomerAddressDeleteArgs>(args: SelectSubset<T, CustomerAddressDeleteArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerAddress.
     * @param {CustomerAddressUpdateArgs} args - Arguments to update one CustomerAddress.
     * @example
     * // Update one CustomerAddress
     * const customerAddress = await prisma.customerAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerAddressUpdateArgs>(args: SelectSubset<T, CustomerAddressUpdateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerAddresses.
     * @param {CustomerAddressDeleteManyArgs} args - Arguments to filter CustomerAddresses to delete.
     * @example
     * // Delete a few CustomerAddresses
     * const { count } = await prisma.customerAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerAddressDeleteManyArgs>(args?: SelectSubset<T, CustomerAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerAddressUpdateManyArgs>(args: SelectSubset<T, CustomerAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses and returns the data updated in the database.
     * @param {CustomerAddressUpdateManyAndReturnArgs} args - Arguments to update many CustomerAddresses.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerAddress.
     * @param {CustomerAddressUpsertArgs} args - Arguments to update or create a CustomerAddress.
     * @example
     * // Update or create a CustomerAddress
     * const customerAddress = await prisma.customerAddress.upsert({
     *   create: {
     *     // ... data to create a CustomerAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerAddress we want to update
     *   }
     * })
     */
    upsert<T extends CustomerAddressUpsertArgs>(args: SelectSubset<T, CustomerAddressUpsertArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressCountArgs} args - Arguments to filter CustomerAddresses to count.
     * @example
     * // Count the number of CustomerAddresses
     * const count = await prisma.customerAddress.count({
     *   where: {
     *     // ... the filter for the CustomerAddresses we want to count
     *   }
     * })
    **/
    count<T extends CustomerAddressCountArgs>(
      args?: Subset<T, CustomerAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAddressAggregateArgs>(args: Subset<T, CustomerAddressAggregateArgs>): Prisma.PrismaPromise<GetCustomerAddressAggregateType<T>>

    /**
     * Group by CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerAddressGroupByArgs['orderBy'] }
        : { orderBy?: CustomerAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerAddress model
   */
  readonly fields: CustomerAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PickUpTask<T extends CustomerAddress$PickUpTaskArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAddress$PickUpTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeliveryTask<T extends CustomerAddress$DeliveryTaskArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAddress$DeliveryTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerAddress model
   */
  interface CustomerAddressFieldRefs {
    readonly id: FieldRef<"CustomerAddress", 'String'>
    readonly customerId: FieldRef<"CustomerAddress", 'String'>
    readonly label: FieldRef<"CustomerAddress", 'Label'>
    readonly address: FieldRef<"CustomerAddress", 'String'>
    readonly city: FieldRef<"CustomerAddress", 'String'>
    readonly postalCode: FieldRef<"CustomerAddress", 'String'>
    readonly latitude: FieldRef<"CustomerAddress", 'Float'>
    readonly longitude: FieldRef<"CustomerAddress", 'Float'>
    readonly notes: FieldRef<"CustomerAddress", 'String'>
    readonly isPrimary: FieldRef<"CustomerAddress", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerAddress", 'DateTime'>
    readonly deletedAt: FieldRef<"CustomerAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerAddress findUnique
   */
  export type CustomerAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findUniqueOrThrow
   */
  export type CustomerAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findFirst
   */
  export type CustomerAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findFirstOrThrow
   */
  export type CustomerAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findMany
   */
  export type CustomerAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddresses to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress create
   */
  export type CustomerAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerAddress.
     */
    data: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
  }

  /**
   * CustomerAddress createMany
   */
  export type CustomerAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerAddress createManyAndReturn
   */
  export type CustomerAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress update
   */
  export type CustomerAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerAddress.
     */
    data: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
    /**
     * Choose, which CustomerAddress to update.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress updateMany
   */
  export type CustomerAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
  }

  /**
   * CustomerAddress updateManyAndReturn
   */
  export type CustomerAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress upsert
   */
  export type CustomerAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerAddress to update in case it exists.
     */
    where: CustomerAddressWhereUniqueInput
    /**
     * In case the CustomerAddress found by the `where` argument doesn't exist, create a new CustomerAddress with this data.
     */
    create: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
    /**
     * In case the CustomerAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
  }

  /**
   * CustomerAddress delete
   */
  export type CustomerAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter which CustomerAddress to delete.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress deleteMany
   */
  export type CustomerAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddresses to delete
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to delete.
     */
    limit?: number
  }

  /**
   * CustomerAddress.PickUpTask
   */
  export type CustomerAddress$PickUpTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    where?: PickUpTaskWhereInput
    orderBy?: PickUpTaskOrderByWithRelationInput | PickUpTaskOrderByWithRelationInput[]
    cursor?: PickUpTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PickUpTaskScalarFieldEnum | PickUpTaskScalarFieldEnum[]
  }

  /**
   * CustomerAddress.DeliveryTask
   */
  export type CustomerAddress$DeliveryTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    where?: DeliveryTaskWhereInput
    orderBy?: DeliveryTaskOrderByWithRelationInput | DeliveryTaskOrderByWithRelationInput[]
    cursor?: DeliveryTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryTaskScalarFieldEnum | DeliveryTaskScalarFieldEnum[]
  }

  /**
   * CustomerAddress without action
   */
  export type CustomerAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    outletId: string | null
    shiftId: string | null
    role: $Enums.Role | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    address: string | null
    photoUrl: string | null
    isActive: boolean | null
    resetPasswordToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    outletId: string | null
    shiftId: string | null
    role: $Enums.Role | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    address: string | null
    photoUrl: string | null
    isActive: boolean | null
    resetPasswordToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    outletId: number
    shiftId: number
    role: number
    name: number
    email: number
    password: number
    phoneNumber: number
    address: number
    photoUrl: number
    isActive: number
    resetPasswordToken: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    outletId?: true
    shiftId?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    address?: true
    photoUrl?: true
    isActive?: true
    resetPasswordToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    outletId?: true
    shiftId?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    address?: true
    photoUrl?: true
    isActive?: true
    resetPasswordToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    outletId?: true
    shiftId?: true
    role?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    address?: true
    photoUrl?: true
    isActive?: true
    resetPasswordToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password: string | null
    phoneNumber: string
    address: string
    photoUrl: string | null
    isActive: boolean
    resetPasswordToken: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    shiftId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    address?: boolean
    photoUrl?: boolean
    isActive?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    shifts?: boolean | ShiftDefaultArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    Attendance?: boolean | Employee$AttendanceArgs<ExtArgs>
    orderHeader?: boolean | Employee$orderHeaderArgs<ExtArgs>
    WorkStation?: boolean | Employee$WorkStationArgs<ExtArgs>
    workerTasks?: boolean | Employee$workerTasksArgs<ExtArgs>
    assignedTasks?: boolean | Employee$assignedTasksArgs<ExtArgs>
    approvedAttendances?: boolean | Employee$approvedAttendancesArgs<ExtArgs>
    pickUpDriver?: boolean | Employee$pickUpDriverArgs<ExtArgs>
    pickupAssignedBy?: boolean | Employee$pickupAssignedByArgs<ExtArgs>
    deliveryDriver?: boolean | Employee$deliveryDriverArgs<ExtArgs>
    deliveryAssignedBy?: boolean | Employee$deliveryAssignedByArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    shiftId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    address?: boolean
    photoUrl?: boolean
    isActive?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    shifts?: boolean | ShiftDefaultArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    shiftId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    address?: boolean
    photoUrl?: boolean
    isActive?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    shifts?: boolean | ShiftDefaultArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    outletId?: boolean
    shiftId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    address?: boolean
    photoUrl?: boolean
    isActive?: boolean
    resetPasswordToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "outletId" | "shiftId" | "role" | "name" | "email" | "password" | "phoneNumber" | "address" | "photoUrl" | "isActive" | "resetPasswordToken" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | ShiftDefaultArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    Attendance?: boolean | Employee$AttendanceArgs<ExtArgs>
    orderHeader?: boolean | Employee$orderHeaderArgs<ExtArgs>
    WorkStation?: boolean | Employee$WorkStationArgs<ExtArgs>
    workerTasks?: boolean | Employee$workerTasksArgs<ExtArgs>
    assignedTasks?: boolean | Employee$assignedTasksArgs<ExtArgs>
    approvedAttendances?: boolean | Employee$approvedAttendancesArgs<ExtArgs>
    pickUpDriver?: boolean | Employee$pickUpDriverArgs<ExtArgs>
    pickupAssignedBy?: boolean | Employee$pickupAssignedByArgs<ExtArgs>
    deliveryDriver?: boolean | Employee$deliveryDriverArgs<ExtArgs>
    deliveryAssignedBy?: boolean | Employee$deliveryAssignedByArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | ShiftDefaultArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | ShiftDefaultArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      shifts: Prisma.$ShiftPayload<ExtArgs>
      outlets: Prisma.$OutletPayload<ExtArgs>
      Attendance: Prisma.$AttendancePayload<ExtArgs>[]
      orderHeader: Prisma.$OrderHeaderPayload<ExtArgs>[]
      WorkStation: Prisma.$WorkStationPayload<ExtArgs>[]
      workerTasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
      assignedTasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
      approvedAttendances: Prisma.$AttendancePayload<ExtArgs>[]
      pickUpDriver: Prisma.$PickUpTaskPayload<ExtArgs>[]
      pickupAssignedBy: Prisma.$PickUpTaskPayload<ExtArgs>[]
      deliveryDriver: Prisma.$DeliveryTaskPayload<ExtArgs>[]
      deliveryAssignedBy: Prisma.$DeliveryTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      outletId: string
      shiftId: string
      role: $Enums.Role
      name: string
      email: string
      password: string | null
      phoneNumber: string
      address: string
      photoUrl: string | null
      isActive: boolean
      resetPasswordToken: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shifts<T extends ShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftDefaultArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outlets<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Attendance<T extends Employee$AttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Employee$AttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderHeader<T extends Employee$orderHeaderArgs<ExtArgs> = {}>(args?: Subset<T, Employee$orderHeaderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WorkStation<T extends Employee$WorkStationArgs<ExtArgs> = {}>(args?: Subset<T, Employee$WorkStationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerTasks<T extends Employee$workerTasksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$workerTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTasks<T extends Employee$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedAttendances<T extends Employee$approvedAttendancesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$approvedAttendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pickUpDriver<T extends Employee$pickUpDriverArgs<ExtArgs> = {}>(args?: Subset<T, Employee$pickUpDriverArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pickupAssignedBy<T extends Employee$pickupAssignedByArgs<ExtArgs> = {}>(args?: Subset<T, Employee$pickupAssignedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryDriver<T extends Employee$deliveryDriverArgs<ExtArgs> = {}>(args?: Subset<T, Employee$deliveryDriverArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryAssignedBy<T extends Employee$deliveryAssignedByArgs<ExtArgs> = {}>(args?: Subset<T, Employee$deliveryAssignedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly outletId: FieldRef<"Employee", 'String'>
    readonly shiftId: FieldRef<"Employee", 'String'>
    readonly role: FieldRef<"Employee", 'Role'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly password: FieldRef<"Employee", 'String'>
    readonly phoneNumber: FieldRef<"Employee", 'String'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly photoUrl: FieldRef<"Employee", 'String'>
    readonly isActive: FieldRef<"Employee", 'Boolean'>
    readonly resetPasswordToken: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
    readonly deletedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.Attendance
   */
  export type Employee$AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Employee.orderHeader
   */
  export type Employee$orderHeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    where?: OrderHeaderWhereInput
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    cursor?: OrderHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * Employee.WorkStation
   */
  export type Employee$WorkStationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    where?: WorkStationWhereInput
    orderBy?: WorkStationOrderByWithRelationInput | WorkStationOrderByWithRelationInput[]
    cursor?: WorkStationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkStationScalarFieldEnum | WorkStationScalarFieldEnum[]
  }

  /**
   * Employee.workerTasks
   */
  export type Employee$workerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * Employee.assignedTasks
   */
  export type Employee$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * Employee.approvedAttendances
   */
  export type Employee$approvedAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Employee.pickUpDriver
   */
  export type Employee$pickUpDriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    where?: PickUpTaskWhereInput
    orderBy?: PickUpTaskOrderByWithRelationInput | PickUpTaskOrderByWithRelationInput[]
    cursor?: PickUpTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PickUpTaskScalarFieldEnum | PickUpTaskScalarFieldEnum[]
  }

  /**
   * Employee.pickupAssignedBy
   */
  export type Employee$pickupAssignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    where?: PickUpTaskWhereInput
    orderBy?: PickUpTaskOrderByWithRelationInput | PickUpTaskOrderByWithRelationInput[]
    cursor?: PickUpTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PickUpTaskScalarFieldEnum | PickUpTaskScalarFieldEnum[]
  }

  /**
   * Employee.deliveryDriver
   */
  export type Employee$deliveryDriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    where?: DeliveryTaskWhereInput
    orderBy?: DeliveryTaskOrderByWithRelationInput | DeliveryTaskOrderByWithRelationInput[]
    cursor?: DeliveryTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryTaskScalarFieldEnum | DeliveryTaskScalarFieldEnum[]
  }

  /**
   * Employee.deliveryAssignedBy
   */
  export type Employee$deliveryAssignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    where?: DeliveryTaskWhereInput
    orderBy?: DeliveryTaskOrderByWithRelationInput | DeliveryTaskOrderByWithRelationInput[]
    cursor?: DeliveryTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryTaskScalarFieldEnum | DeliveryTaskScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ShiftMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    name: string
    startTime: Date
    endTime: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ShiftCountAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Employee?: boolean | Shift$EmployeeArgs<ExtArgs>
    Attendance?: boolean | Shift$AttendanceArgs<ExtArgs>
    workerTasks?: boolean | Shift$workerTasksArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startTime" | "endTime" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["shift"]>
  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | Shift$EmployeeArgs<ExtArgs>
    Attendance?: boolean | Shift$AttendanceArgs<ExtArgs>
    workerTasks?: boolean | Shift$workerTasksArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>[]
      Attendance: Prisma.$AttendancePayload<ExtArgs>[]
      workerTasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startTime: Date
      endTime: Date
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts and returns the data updated in the database.
     * @param {ShiftUpdateManyAndReturnArgs} args - Arguments to update many Shifts.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends Shift$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, Shift$EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Attendance<T extends Shift$AttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Shift$AttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerTasks<T extends Shift$workerTasksArgs<ExtArgs> = {}>(args?: Subset<T, Shift$workerTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly name: FieldRef<"Shift", 'String'>
    readonly startTime: FieldRef<"Shift", 'DateTime'>
    readonly endTime: FieldRef<"Shift", 'DateTime'>
    readonly createdAt: FieldRef<"Shift", 'DateTime'>
    readonly updatedAt: FieldRef<"Shift", 'DateTime'>
    readonly deletedAt: FieldRef<"Shift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift updateManyAndReturn
   */
  export type ShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to delete.
     */
    limit?: number
  }

  /**
   * Shift.Employee
   */
  export type Shift$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Shift.Attendance
   */
  export type Shift$AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Shift.workerTasks
   */
  export type Shift$workerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model WorkStation
   */

  export type AggregateWorkStation = {
    _count: WorkStationCountAggregateOutputType | null
    _min: WorkStationMinAggregateOutputType | null
    _max: WorkStationMaxAggregateOutputType | null
  }

  export type WorkStationMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    station: $Enums.Station | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkStationMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    station: $Enums.Station | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkStationCountAggregateOutputType = {
    id: number
    employeeId: number
    station: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WorkStationMinAggregateInputType = {
    id?: true
    employeeId?: true
    station?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkStationMaxAggregateInputType = {
    id?: true
    employeeId?: true
    station?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkStationCountAggregateInputType = {
    id?: true
    employeeId?: true
    station?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WorkStationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkStation to aggregate.
     */
    where?: WorkStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkStations to fetch.
     */
    orderBy?: WorkStationOrderByWithRelationInput | WorkStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkStations
    **/
    _count?: true | WorkStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkStationMaxAggregateInputType
  }

  export type GetWorkStationAggregateType<T extends WorkStationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkStation[P]>
      : GetScalarType<T[P], AggregateWorkStation[P]>
  }




  export type WorkStationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkStationWhereInput
    orderBy?: WorkStationOrderByWithAggregationInput | WorkStationOrderByWithAggregationInput[]
    by: WorkStationScalarFieldEnum[] | WorkStationScalarFieldEnum
    having?: WorkStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkStationCountAggregateInputType | true
    _min?: WorkStationMinAggregateInputType
    _max?: WorkStationMaxAggregateInputType
  }

  export type WorkStationGroupByOutputType = {
    id: string
    employeeId: string
    station: $Enums.Station
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WorkStationCountAggregateOutputType | null
    _min: WorkStationMinAggregateOutputType | null
    _max: WorkStationMaxAggregateOutputType | null
  }

  type GetWorkStationGroupByPayload<T extends WorkStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkStationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkStationGroupByOutputType[P]>
        }
      >
    >


  export type WorkStationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    station?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
    workerTasks?: boolean | WorkStation$workerTasksArgs<ExtArgs>
    _count?: boolean | WorkStationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workStation"]>

  export type WorkStationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    station?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workStation"]>

  export type WorkStationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    station?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workStation"]>

  export type WorkStationSelectScalar = {
    id?: boolean
    employeeId?: boolean
    station?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WorkStationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "station" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["workStation"]>
  export type WorkStationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
    workerTasks?: boolean | WorkStation$workerTasksArgs<ExtArgs>
    _count?: boolean | WorkStationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkStationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type WorkStationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $WorkStationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkStation"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>
      workerTasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      station: $Enums.Station
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["workStation"]>
    composites: {}
  }

  type WorkStationGetPayload<S extends boolean | null | undefined | WorkStationDefaultArgs> = $Result.GetResult<Prisma.$WorkStationPayload, S>

  type WorkStationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkStationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkStationCountAggregateInputType | true
    }

  export interface WorkStationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkStation'], meta: { name: 'WorkStation' } }
    /**
     * Find zero or one WorkStation that matches the filter.
     * @param {WorkStationFindUniqueArgs} args - Arguments to find a WorkStation
     * @example
     * // Get one WorkStation
     * const workStation = await prisma.workStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkStationFindUniqueArgs>(args: SelectSubset<T, WorkStationFindUniqueArgs<ExtArgs>>): Prisma__WorkStationClient<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkStation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkStationFindUniqueOrThrowArgs} args - Arguments to find a WorkStation
     * @example
     * // Get one WorkStation
     * const workStation = await prisma.workStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkStationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkStationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkStationClient<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStationFindFirstArgs} args - Arguments to find a WorkStation
     * @example
     * // Get one WorkStation
     * const workStation = await prisma.workStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkStationFindFirstArgs>(args?: SelectSubset<T, WorkStationFindFirstArgs<ExtArgs>>): Prisma__WorkStationClient<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkStation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStationFindFirstOrThrowArgs} args - Arguments to find a WorkStation
     * @example
     * // Get one WorkStation
     * const workStation = await prisma.workStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkStationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkStationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkStationClient<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkStations
     * const workStations = await prisma.workStation.findMany()
     * 
     * // Get first 10 WorkStations
     * const workStations = await prisma.workStation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workStationWithIdOnly = await prisma.workStation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkStationFindManyArgs>(args?: SelectSubset<T, WorkStationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkStation.
     * @param {WorkStationCreateArgs} args - Arguments to create a WorkStation.
     * @example
     * // Create one WorkStation
     * const WorkStation = await prisma.workStation.create({
     *   data: {
     *     // ... data to create a WorkStation
     *   }
     * })
     * 
     */
    create<T extends WorkStationCreateArgs>(args: SelectSubset<T, WorkStationCreateArgs<ExtArgs>>): Prisma__WorkStationClient<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkStations.
     * @param {WorkStationCreateManyArgs} args - Arguments to create many WorkStations.
     * @example
     * // Create many WorkStations
     * const workStation = await prisma.workStation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkStationCreateManyArgs>(args?: SelectSubset<T, WorkStationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkStations and returns the data saved in the database.
     * @param {WorkStationCreateManyAndReturnArgs} args - Arguments to create many WorkStations.
     * @example
     * // Create many WorkStations
     * const workStation = await prisma.workStation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkStations and only return the `id`
     * const workStationWithIdOnly = await prisma.workStation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkStationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkStationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkStation.
     * @param {WorkStationDeleteArgs} args - Arguments to delete one WorkStation.
     * @example
     * // Delete one WorkStation
     * const WorkStation = await prisma.workStation.delete({
     *   where: {
     *     // ... filter to delete one WorkStation
     *   }
     * })
     * 
     */
    delete<T extends WorkStationDeleteArgs>(args: SelectSubset<T, WorkStationDeleteArgs<ExtArgs>>): Prisma__WorkStationClient<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkStation.
     * @param {WorkStationUpdateArgs} args - Arguments to update one WorkStation.
     * @example
     * // Update one WorkStation
     * const workStation = await prisma.workStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkStationUpdateArgs>(args: SelectSubset<T, WorkStationUpdateArgs<ExtArgs>>): Prisma__WorkStationClient<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkStations.
     * @param {WorkStationDeleteManyArgs} args - Arguments to filter WorkStations to delete.
     * @example
     * // Delete a few WorkStations
     * const { count } = await prisma.workStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkStationDeleteManyArgs>(args?: SelectSubset<T, WorkStationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkStations
     * const workStation = await prisma.workStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkStationUpdateManyArgs>(args: SelectSubset<T, WorkStationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkStations and returns the data updated in the database.
     * @param {WorkStationUpdateManyAndReturnArgs} args - Arguments to update many WorkStations.
     * @example
     * // Update many WorkStations
     * const workStation = await prisma.workStation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkStations and only return the `id`
     * const workStationWithIdOnly = await prisma.workStation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkStationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkStationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkStation.
     * @param {WorkStationUpsertArgs} args - Arguments to update or create a WorkStation.
     * @example
     * // Update or create a WorkStation
     * const workStation = await prisma.workStation.upsert({
     *   create: {
     *     // ... data to create a WorkStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkStation we want to update
     *   }
     * })
     */
    upsert<T extends WorkStationUpsertArgs>(args: SelectSubset<T, WorkStationUpsertArgs<ExtArgs>>): Prisma__WorkStationClient<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStationCountArgs} args - Arguments to filter WorkStations to count.
     * @example
     * // Count the number of WorkStations
     * const count = await prisma.workStation.count({
     *   where: {
     *     // ... the filter for the WorkStations we want to count
     *   }
     * })
    **/
    count<T extends WorkStationCountArgs>(
      args?: Subset<T, WorkStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkStationAggregateArgs>(args: Subset<T, WorkStationAggregateArgs>): Prisma.PrismaPromise<GetWorkStationAggregateType<T>>

    /**
     * Group by WorkStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkStationGroupByArgs['orderBy'] }
        : { orderBy?: WorkStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkStation model
   */
  readonly fields: WorkStationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkStationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workerTasks<T extends WorkStation$workerTasksArgs<ExtArgs> = {}>(args?: Subset<T, WorkStation$workerTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkStation model
   */
  interface WorkStationFieldRefs {
    readonly id: FieldRef<"WorkStation", 'String'>
    readonly employeeId: FieldRef<"WorkStation", 'String'>
    readonly station: FieldRef<"WorkStation", 'Station'>
    readonly createdAt: FieldRef<"WorkStation", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkStation", 'DateTime'>
    readonly deletedAt: FieldRef<"WorkStation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkStation findUnique
   */
  export type WorkStationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkStation to fetch.
     */
    where: WorkStationWhereUniqueInput
  }

  /**
   * WorkStation findUniqueOrThrow
   */
  export type WorkStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkStation to fetch.
     */
    where: WorkStationWhereUniqueInput
  }

  /**
   * WorkStation findFirst
   */
  export type WorkStationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkStation to fetch.
     */
    where?: WorkStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkStations to fetch.
     */
    orderBy?: WorkStationOrderByWithRelationInput | WorkStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkStations.
     */
    cursor?: WorkStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkStations.
     */
    distinct?: WorkStationScalarFieldEnum | WorkStationScalarFieldEnum[]
  }

  /**
   * WorkStation findFirstOrThrow
   */
  export type WorkStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkStation to fetch.
     */
    where?: WorkStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkStations to fetch.
     */
    orderBy?: WorkStationOrderByWithRelationInput | WorkStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkStations.
     */
    cursor?: WorkStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkStations.
     */
    distinct?: WorkStationScalarFieldEnum | WorkStationScalarFieldEnum[]
  }

  /**
   * WorkStation findMany
   */
  export type WorkStationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    /**
     * Filter, which WorkStations to fetch.
     */
    where?: WorkStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkStations to fetch.
     */
    orderBy?: WorkStationOrderByWithRelationInput | WorkStationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkStations.
     */
    cursor?: WorkStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkStations.
     */
    skip?: number
    distinct?: WorkStationScalarFieldEnum | WorkStationScalarFieldEnum[]
  }

  /**
   * WorkStation create
   */
  export type WorkStationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkStation.
     */
    data: XOR<WorkStationCreateInput, WorkStationUncheckedCreateInput>
  }

  /**
   * WorkStation createMany
   */
  export type WorkStationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkStations.
     */
    data: WorkStationCreateManyInput | WorkStationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkStation createManyAndReturn
   */
  export type WorkStationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkStations.
     */
    data: WorkStationCreateManyInput | WorkStationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkStation update
   */
  export type WorkStationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkStation.
     */
    data: XOR<WorkStationUpdateInput, WorkStationUncheckedUpdateInput>
    /**
     * Choose, which WorkStation to update.
     */
    where: WorkStationWhereUniqueInput
  }

  /**
   * WorkStation updateMany
   */
  export type WorkStationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkStations.
     */
    data: XOR<WorkStationUpdateManyMutationInput, WorkStationUncheckedUpdateManyInput>
    /**
     * Filter which WorkStations to update
     */
    where?: WorkStationWhereInput
    /**
     * Limit how many WorkStations to update.
     */
    limit?: number
  }

  /**
   * WorkStation updateManyAndReturn
   */
  export type WorkStationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * The data used to update WorkStations.
     */
    data: XOR<WorkStationUpdateManyMutationInput, WorkStationUncheckedUpdateManyInput>
    /**
     * Filter which WorkStations to update
     */
    where?: WorkStationWhereInput
    /**
     * Limit how many WorkStations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkStation upsert
   */
  export type WorkStationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkStation to update in case it exists.
     */
    where: WorkStationWhereUniqueInput
    /**
     * In case the WorkStation found by the `where` argument doesn't exist, create a new WorkStation with this data.
     */
    create: XOR<WorkStationCreateInput, WorkStationUncheckedCreateInput>
    /**
     * In case the WorkStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkStationUpdateInput, WorkStationUncheckedUpdateInput>
  }

  /**
   * WorkStation delete
   */
  export type WorkStationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
    /**
     * Filter which WorkStation to delete.
     */
    where: WorkStationWhereUniqueInput
  }

  /**
   * WorkStation deleteMany
   */
  export type WorkStationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkStations to delete
     */
    where?: WorkStationWhereInput
    /**
     * Limit how many WorkStations to delete.
     */
    limit?: number
  }

  /**
   * WorkStation.workerTasks
   */
  export type WorkStation$workerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * WorkStation without action
   */
  export type WorkStationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStation
     */
    select?: WorkStationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStation
     */
    omit?: WorkStationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStationInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeTask
   */

  export type AggregateEmployeeTask = {
    _count: EmployeeTaskCountAggregateOutputType | null
    _avg: EmployeeTaskAvgAggregateOutputType | null
    _sum: EmployeeTaskSumAggregateOutputType | null
    _min: EmployeeTaskMinAggregateOutputType | null
    _max: EmployeeTaskMaxAggregateOutputType | null
  }

  export type EmployeeTaskAvgAggregateOutputType = {
    itemQty: number | null
  }

  export type EmployeeTaskSumAggregateOutputType = {
    itemQty: number | null
  }

  export type EmployeeTaskMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    orderHeaderId: string | null
    orderItemId: string | null
    outletId: string | null
    shiftId: string | null
    workStationId: string | null
    status: $Enums.TaskStatus | null
    itemQty: number | null
    itemUnit: string | null
    bypassReqNote: string | null
    bypassReq: boolean | null
    isReqAprooved: boolean | null
    itemPassedNote: string | null
    assignedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeTaskMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    orderHeaderId: string | null
    orderItemId: string | null
    outletId: string | null
    shiftId: string | null
    workStationId: string | null
    status: $Enums.TaskStatus | null
    itemQty: number | null
    itemUnit: string | null
    bypassReqNote: string | null
    bypassReq: boolean | null
    isReqAprooved: boolean | null
    itemPassedNote: string | null
    assignedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeTaskCountAggregateOutputType = {
    id: number
    employeeId: number
    orderHeaderId: number
    orderItemId: number
    outletId: number
    shiftId: number
    workStationId: number
    status: number
    itemQty: number
    itemUnit: number
    bypassReqNote: number
    bypassReq: number
    isReqAprooved: number
    itemPassedNote: number
    assignedById: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EmployeeTaskAvgAggregateInputType = {
    itemQty?: true
  }

  export type EmployeeTaskSumAggregateInputType = {
    itemQty?: true
  }

  export type EmployeeTaskMinAggregateInputType = {
    id?: true
    employeeId?: true
    orderHeaderId?: true
    orderItemId?: true
    outletId?: true
    shiftId?: true
    workStationId?: true
    status?: true
    itemQty?: true
    itemUnit?: true
    bypassReqNote?: true
    bypassReq?: true
    isReqAprooved?: true
    itemPassedNote?: true
    assignedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeTaskMaxAggregateInputType = {
    id?: true
    employeeId?: true
    orderHeaderId?: true
    orderItemId?: true
    outletId?: true
    shiftId?: true
    workStationId?: true
    status?: true
    itemQty?: true
    itemUnit?: true
    bypassReqNote?: true
    bypassReq?: true
    isReqAprooved?: true
    itemPassedNote?: true
    assignedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeTaskCountAggregateInputType = {
    id?: true
    employeeId?: true
    orderHeaderId?: true
    orderItemId?: true
    outletId?: true
    shiftId?: true
    workStationId?: true
    status?: true
    itemQty?: true
    itemUnit?: true
    bypassReqNote?: true
    bypassReq?: true
    isReqAprooved?: true
    itemPassedNote?: true
    assignedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EmployeeTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeTask to aggregate.
     */
    where?: EmployeeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTasks to fetch.
     */
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeTasks
    **/
    _count?: true | EmployeeTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeTaskMaxAggregateInputType
  }

  export type GetEmployeeTaskAggregateType<T extends EmployeeTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeTask[P]>
      : GetScalarType<T[P], AggregateEmployeeTask[P]>
  }




  export type EmployeeTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithAggregationInput | EmployeeTaskOrderByWithAggregationInput[]
    by: EmployeeTaskScalarFieldEnum[] | EmployeeTaskScalarFieldEnum
    having?: EmployeeTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeTaskCountAggregateInputType | true
    _avg?: EmployeeTaskAvgAggregateInputType
    _sum?: EmployeeTaskSumAggregateInputType
    _min?: EmployeeTaskMinAggregateInputType
    _max?: EmployeeTaskMaxAggregateInputType
  }

  export type EmployeeTaskGroupByOutputType = {
    id: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    shiftId: string
    workStationId: string
    status: $Enums.TaskStatus
    itemQty: number | null
    itemUnit: string | null
    bypassReqNote: string | null
    bypassReq: boolean | null
    isReqAprooved: boolean | null
    itemPassedNote: string | null
    assignedById: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EmployeeTaskCountAggregateOutputType | null
    _avg: EmployeeTaskAvgAggregateOutputType | null
    _sum: EmployeeTaskSumAggregateOutputType | null
    _min: EmployeeTaskMinAggregateOutputType | null
    _max: EmployeeTaskMaxAggregateOutputType | null
  }

  type GetEmployeeTaskGroupByPayload<T extends EmployeeTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeTaskGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeTaskGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    orderHeaderId?: boolean
    orderItemId?: boolean
    outletId?: boolean
    shiftId?: boolean
    workStationId?: boolean
    status?: boolean
    itemQty?: boolean
    itemUnit?: boolean
    bypassReqNote?: boolean
    bypassReq?: boolean
    isReqAprooved?: boolean
    itemPassedNote?: boolean
    assignedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    orderHeader?: boolean | EmployeeTask$orderHeaderArgs<ExtArgs>
    orderItem?: boolean | EmployeeTask$orderItemArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    workStation?: boolean | WorkStationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeTask"]>

  export type EmployeeTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    orderHeaderId?: boolean
    orderItemId?: boolean
    outletId?: boolean
    shiftId?: boolean
    workStationId?: boolean
    status?: boolean
    itemQty?: boolean
    itemUnit?: boolean
    bypassReqNote?: boolean
    bypassReq?: boolean
    isReqAprooved?: boolean
    itemPassedNote?: boolean
    assignedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    orderHeader?: boolean | EmployeeTask$orderHeaderArgs<ExtArgs>
    orderItem?: boolean | EmployeeTask$orderItemArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    workStation?: boolean | WorkStationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeTask"]>

  export type EmployeeTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    orderHeaderId?: boolean
    orderItemId?: boolean
    outletId?: boolean
    shiftId?: boolean
    workStationId?: boolean
    status?: boolean
    itemQty?: boolean
    itemUnit?: boolean
    bypassReqNote?: boolean
    bypassReq?: boolean
    isReqAprooved?: boolean
    itemPassedNote?: boolean
    assignedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    orderHeader?: boolean | EmployeeTask$orderHeaderArgs<ExtArgs>
    orderItem?: boolean | EmployeeTask$orderItemArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    workStation?: boolean | WorkStationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeTask"]>

  export type EmployeeTaskSelectScalar = {
    id?: boolean
    employeeId?: boolean
    orderHeaderId?: boolean
    orderItemId?: boolean
    outletId?: boolean
    shiftId?: boolean
    workStationId?: boolean
    status?: boolean
    itemQty?: boolean
    itemUnit?: boolean
    bypassReqNote?: boolean
    bypassReq?: boolean
    isReqAprooved?: boolean
    itemPassedNote?: boolean
    assignedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EmployeeTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "orderHeaderId" | "orderItemId" | "outletId" | "shiftId" | "workStationId" | "status" | "itemQty" | "itemUnit" | "bypassReqNote" | "bypassReq" | "isReqAprooved" | "itemPassedNote" | "assignedById" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["employeeTask"]>
  export type EmployeeTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    orderHeader?: boolean | EmployeeTask$orderHeaderArgs<ExtArgs>
    orderItem?: boolean | EmployeeTask$orderItemArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    workStation?: boolean | WorkStationDefaultArgs<ExtArgs>
  }
  export type EmployeeTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    orderHeader?: boolean | EmployeeTask$orderHeaderArgs<ExtArgs>
    orderItem?: boolean | EmployeeTask$orderItemArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    workStation?: boolean | WorkStationDefaultArgs<ExtArgs>
  }
  export type EmployeeTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | EmployeeTask$assignedByArgs<ExtArgs>
    orderHeader?: boolean | EmployeeTask$orderHeaderArgs<ExtArgs>
    orderItem?: boolean | EmployeeTask$orderItemArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
    workStation?: boolean | WorkStationDefaultArgs<ExtArgs>
  }

  export type $EmployeeTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeTask"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      assignedBy: Prisma.$EmployeePayload<ExtArgs> | null
      orderHeader: Prisma.$OrderHeaderPayload<ExtArgs> | null
      orderItem: Prisma.$OrderItemPayload<ExtArgs> | null
      outlet: Prisma.$OutletPayload<ExtArgs>
      shift: Prisma.$ShiftPayload<ExtArgs>
      workStation: Prisma.$WorkStationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      orderHeaderId: string
      orderItemId: string
      outletId: string
      shiftId: string
      workStationId: string
      status: $Enums.TaskStatus
      itemQty: number | null
      itemUnit: string | null
      bypassReqNote: string | null
      bypassReq: boolean | null
      isReqAprooved: boolean | null
      itemPassedNote: string | null
      assignedById: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["employeeTask"]>
    composites: {}
  }

  type EmployeeTaskGetPayload<S extends boolean | null | undefined | EmployeeTaskDefaultArgs> = $Result.GetResult<Prisma.$EmployeeTaskPayload, S>

  type EmployeeTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeTaskCountAggregateInputType | true
    }

  export interface EmployeeTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeTask'], meta: { name: 'EmployeeTask' } }
    /**
     * Find zero or one EmployeeTask that matches the filter.
     * @param {EmployeeTaskFindUniqueArgs} args - Arguments to find a EmployeeTask
     * @example
     * // Get one EmployeeTask
     * const employeeTask = await prisma.employeeTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeTaskFindUniqueArgs>(args: SelectSubset<T, EmployeeTaskFindUniqueArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeTaskFindUniqueOrThrowArgs} args - Arguments to find a EmployeeTask
     * @example
     * // Get one EmployeeTask
     * const employeeTask = await prisma.employeeTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskFindFirstArgs} args - Arguments to find a EmployeeTask
     * @example
     * // Get one EmployeeTask
     * const employeeTask = await prisma.employeeTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeTaskFindFirstArgs>(args?: SelectSubset<T, EmployeeTaskFindFirstArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskFindFirstOrThrowArgs} args - Arguments to find a EmployeeTask
     * @example
     * // Get one EmployeeTask
     * const employeeTask = await prisma.employeeTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeTasks
     * const employeeTasks = await prisma.employeeTask.findMany()
     * 
     * // Get first 10 EmployeeTasks
     * const employeeTasks = await prisma.employeeTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeTaskWithIdOnly = await prisma.employeeTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeTaskFindManyArgs>(args?: SelectSubset<T, EmployeeTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeTask.
     * @param {EmployeeTaskCreateArgs} args - Arguments to create a EmployeeTask.
     * @example
     * // Create one EmployeeTask
     * const EmployeeTask = await prisma.employeeTask.create({
     *   data: {
     *     // ... data to create a EmployeeTask
     *   }
     * })
     * 
     */
    create<T extends EmployeeTaskCreateArgs>(args: SelectSubset<T, EmployeeTaskCreateArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeTasks.
     * @param {EmployeeTaskCreateManyArgs} args - Arguments to create many EmployeeTasks.
     * @example
     * // Create many EmployeeTasks
     * const employeeTask = await prisma.employeeTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeTaskCreateManyArgs>(args?: SelectSubset<T, EmployeeTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeTasks and returns the data saved in the database.
     * @param {EmployeeTaskCreateManyAndReturnArgs} args - Arguments to create many EmployeeTasks.
     * @example
     * // Create many EmployeeTasks
     * const employeeTask = await prisma.employeeTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeTasks and only return the `id`
     * const employeeTaskWithIdOnly = await prisma.employeeTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeTask.
     * @param {EmployeeTaskDeleteArgs} args - Arguments to delete one EmployeeTask.
     * @example
     * // Delete one EmployeeTask
     * const EmployeeTask = await prisma.employeeTask.delete({
     *   where: {
     *     // ... filter to delete one EmployeeTask
     *   }
     * })
     * 
     */
    delete<T extends EmployeeTaskDeleteArgs>(args: SelectSubset<T, EmployeeTaskDeleteArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeTask.
     * @param {EmployeeTaskUpdateArgs} args - Arguments to update one EmployeeTask.
     * @example
     * // Update one EmployeeTask
     * const employeeTask = await prisma.employeeTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeTaskUpdateArgs>(args: SelectSubset<T, EmployeeTaskUpdateArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeTasks.
     * @param {EmployeeTaskDeleteManyArgs} args - Arguments to filter EmployeeTasks to delete.
     * @example
     * // Delete a few EmployeeTasks
     * const { count } = await prisma.employeeTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeTaskDeleteManyArgs>(args?: SelectSubset<T, EmployeeTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeTasks
     * const employeeTask = await prisma.employeeTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeTaskUpdateManyArgs>(args: SelectSubset<T, EmployeeTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeTasks and returns the data updated in the database.
     * @param {EmployeeTaskUpdateManyAndReturnArgs} args - Arguments to update many EmployeeTasks.
     * @example
     * // Update many EmployeeTasks
     * const employeeTask = await prisma.employeeTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeTasks and only return the `id`
     * const employeeTaskWithIdOnly = await prisma.employeeTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeTask.
     * @param {EmployeeTaskUpsertArgs} args - Arguments to update or create a EmployeeTask.
     * @example
     * // Update or create a EmployeeTask
     * const employeeTask = await prisma.employeeTask.upsert({
     *   create: {
     *     // ... data to create a EmployeeTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeTask we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeTaskUpsertArgs>(args: SelectSubset<T, EmployeeTaskUpsertArgs<ExtArgs>>): Prisma__EmployeeTaskClient<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskCountArgs} args - Arguments to filter EmployeeTasks to count.
     * @example
     * // Count the number of EmployeeTasks
     * const count = await prisma.employeeTask.count({
     *   where: {
     *     // ... the filter for the EmployeeTasks we want to count
     *   }
     * })
    **/
    count<T extends EmployeeTaskCountArgs>(
      args?: Subset<T, EmployeeTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeTaskAggregateArgs>(args: Subset<T, EmployeeTaskAggregateArgs>): Prisma.PrismaPromise<GetEmployeeTaskAggregateType<T>>

    /**
     * Group by EmployeeTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeTaskGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeTask model
   */
  readonly fields: EmployeeTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedBy<T extends EmployeeTask$assignedByArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTask$assignedByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderHeader<T extends EmployeeTask$orderHeaderArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTask$orderHeaderArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderItem<T extends EmployeeTask$orderItemArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeTask$orderItemArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shift<T extends ShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftDefaultArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workStation<T extends WorkStationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkStationDefaultArgs<ExtArgs>>): Prisma__WorkStationClient<$Result.GetResult<Prisma.$WorkStationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeTask model
   */
  interface EmployeeTaskFieldRefs {
    readonly id: FieldRef<"EmployeeTask", 'String'>
    readonly employeeId: FieldRef<"EmployeeTask", 'String'>
    readonly orderHeaderId: FieldRef<"EmployeeTask", 'String'>
    readonly orderItemId: FieldRef<"EmployeeTask", 'String'>
    readonly outletId: FieldRef<"EmployeeTask", 'String'>
    readonly shiftId: FieldRef<"EmployeeTask", 'String'>
    readonly workStationId: FieldRef<"EmployeeTask", 'String'>
    readonly status: FieldRef<"EmployeeTask", 'TaskStatus'>
    readonly itemQty: FieldRef<"EmployeeTask", 'Int'>
    readonly itemUnit: FieldRef<"EmployeeTask", 'String'>
    readonly bypassReqNote: FieldRef<"EmployeeTask", 'String'>
    readonly bypassReq: FieldRef<"EmployeeTask", 'Boolean'>
    readonly isReqAprooved: FieldRef<"EmployeeTask", 'Boolean'>
    readonly itemPassedNote: FieldRef<"EmployeeTask", 'String'>
    readonly assignedById: FieldRef<"EmployeeTask", 'String'>
    readonly createdAt: FieldRef<"EmployeeTask", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeTask", 'DateTime'>
    readonly deletedAt: FieldRef<"EmployeeTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeTask findUnique
   */
  export type EmployeeTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTask to fetch.
     */
    where: EmployeeTaskWhereUniqueInput
  }

  /**
   * EmployeeTask findUniqueOrThrow
   */
  export type EmployeeTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTask to fetch.
     */
    where: EmployeeTaskWhereUniqueInput
  }

  /**
   * EmployeeTask findFirst
   */
  export type EmployeeTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTask to fetch.
     */
    where?: EmployeeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTasks to fetch.
     */
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeTasks.
     */
    cursor?: EmployeeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeTasks.
     */
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * EmployeeTask findFirstOrThrow
   */
  export type EmployeeTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTask to fetch.
     */
    where?: EmployeeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTasks to fetch.
     */
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeTasks.
     */
    cursor?: EmployeeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeTasks.
     */
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * EmployeeTask findMany
   */
  export type EmployeeTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeTasks to fetch.
     */
    where?: EmployeeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeTasks to fetch.
     */
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeTasks.
     */
    cursor?: EmployeeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeTasks.
     */
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * EmployeeTask create
   */
  export type EmployeeTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeTask.
     */
    data: XOR<EmployeeTaskCreateInput, EmployeeTaskUncheckedCreateInput>
  }

  /**
   * EmployeeTask createMany
   */
  export type EmployeeTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeTasks.
     */
    data: EmployeeTaskCreateManyInput | EmployeeTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeTask createManyAndReturn
   */
  export type EmployeeTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeTasks.
     */
    data: EmployeeTaskCreateManyInput | EmployeeTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeTask update
   */
  export type EmployeeTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeTask.
     */
    data: XOR<EmployeeTaskUpdateInput, EmployeeTaskUncheckedUpdateInput>
    /**
     * Choose, which EmployeeTask to update.
     */
    where: EmployeeTaskWhereUniqueInput
  }

  /**
   * EmployeeTask updateMany
   */
  export type EmployeeTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeTasks.
     */
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeTasks to update
     */
    where?: EmployeeTaskWhereInput
    /**
     * Limit how many EmployeeTasks to update.
     */
    limit?: number
  }

  /**
   * EmployeeTask updateManyAndReturn
   */
  export type EmployeeTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeTasks.
     */
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeTasks to update
     */
    where?: EmployeeTaskWhereInput
    /**
     * Limit how many EmployeeTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeTask upsert
   */
  export type EmployeeTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeTask to update in case it exists.
     */
    where: EmployeeTaskWhereUniqueInput
    /**
     * In case the EmployeeTask found by the `where` argument doesn't exist, create a new EmployeeTask with this data.
     */
    create: XOR<EmployeeTaskCreateInput, EmployeeTaskUncheckedCreateInput>
    /**
     * In case the EmployeeTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeTaskUpdateInput, EmployeeTaskUncheckedUpdateInput>
  }

  /**
   * EmployeeTask delete
   */
  export type EmployeeTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    /**
     * Filter which EmployeeTask to delete.
     */
    where: EmployeeTaskWhereUniqueInput
  }

  /**
   * EmployeeTask deleteMany
   */
  export type EmployeeTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeTasks to delete
     */
    where?: EmployeeTaskWhereInput
    /**
     * Limit how many EmployeeTasks to delete.
     */
    limit?: number
  }

  /**
   * EmployeeTask.assignedBy
   */
  export type EmployeeTask$assignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * EmployeeTask.orderHeader
   */
  export type EmployeeTask$orderHeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    where?: OrderHeaderWhereInput
  }

  /**
   * EmployeeTask.orderItem
   */
  export type EmployeeTask$orderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
  }

  /**
   * EmployeeTask without action
   */
  export type EmployeeTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
  }


  /**
   * Model PickUpTask
   */

  export type AggregatePickUpTask = {
    _count: PickUpTaskCountAggregateOutputType | null
    _avg: PickUpTaskAvgAggregateOutputType | null
    _sum: PickUpTaskSumAggregateOutputType | null
    _min: PickUpTaskMinAggregateOutputType | null
    _max: PickUpTaskMaxAggregateOutputType | null
  }

  export type PickUpTaskAvgAggregateOutputType = {
    distance: number | null
    price: number | null
  }

  export type PickUpTaskSumAggregateOutputType = {
    distance: number | null
    price: number | null
  }

  export type PickUpTaskMinAggregateOutputType = {
    id: string | null
    driverId: string | null
    outletId: string | null
    customerAddressId: string | null
    assignedByAdminId: string | null
    orderHeaderId: string | null
    status: $Enums.PickupStatus | null
    distance: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PickUpTaskMaxAggregateOutputType = {
    id: string | null
    driverId: string | null
    outletId: string | null
    customerAddressId: string | null
    assignedByAdminId: string | null
    orderHeaderId: string | null
    status: $Enums.PickupStatus | null
    distance: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PickUpTaskCountAggregateOutputType = {
    id: number
    driverId: number
    outletId: number
    customerAddressId: number
    assignedByAdminId: number
    orderHeaderId: number
    status: number
    distance: number
    price: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PickUpTaskAvgAggregateInputType = {
    distance?: true
    price?: true
  }

  export type PickUpTaskSumAggregateInputType = {
    distance?: true
    price?: true
  }

  export type PickUpTaskMinAggregateInputType = {
    id?: true
    driverId?: true
    outletId?: true
    customerAddressId?: true
    assignedByAdminId?: true
    orderHeaderId?: true
    status?: true
    distance?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PickUpTaskMaxAggregateInputType = {
    id?: true
    driverId?: true
    outletId?: true
    customerAddressId?: true
    assignedByAdminId?: true
    orderHeaderId?: true
    status?: true
    distance?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PickUpTaskCountAggregateInputType = {
    id?: true
    driverId?: true
    outletId?: true
    customerAddressId?: true
    assignedByAdminId?: true
    orderHeaderId?: true
    status?: true
    distance?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PickUpTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PickUpTask to aggregate.
     */
    where?: PickUpTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickUpTasks to fetch.
     */
    orderBy?: PickUpTaskOrderByWithRelationInput | PickUpTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PickUpTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickUpTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickUpTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PickUpTasks
    **/
    _count?: true | PickUpTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PickUpTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PickUpTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PickUpTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PickUpTaskMaxAggregateInputType
  }

  export type GetPickUpTaskAggregateType<T extends PickUpTaskAggregateArgs> = {
        [P in keyof T & keyof AggregatePickUpTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePickUpTask[P]>
      : GetScalarType<T[P], AggregatePickUpTask[P]>
  }




  export type PickUpTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickUpTaskWhereInput
    orderBy?: PickUpTaskOrderByWithAggregationInput | PickUpTaskOrderByWithAggregationInput[]
    by: PickUpTaskScalarFieldEnum[] | PickUpTaskScalarFieldEnum
    having?: PickUpTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PickUpTaskCountAggregateInputType | true
    _avg?: PickUpTaskAvgAggregateInputType
    _sum?: PickUpTaskSumAggregateInputType
    _min?: PickUpTaskMinAggregateInputType
    _max?: PickUpTaskMaxAggregateInputType
  }

  export type PickUpTaskGroupByOutputType = {
    id: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.PickupStatus
    distance: number
    price: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PickUpTaskCountAggregateOutputType | null
    _avg: PickUpTaskAvgAggregateOutputType | null
    _sum: PickUpTaskSumAggregateOutputType | null
    _min: PickUpTaskMinAggregateOutputType | null
    _max: PickUpTaskMaxAggregateOutputType | null
  }

  type GetPickUpTaskGroupByPayload<T extends PickUpTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PickUpTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PickUpTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PickUpTaskGroupByOutputType[P]>
            : GetScalarType<T[P], PickUpTaskGroupByOutputType[P]>
        }
      >
    >


  export type PickUpTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    outletId?: boolean
    customerAddressId?: boolean
    assignedByAdminId?: boolean
    orderHeaderId?: boolean
    status?: boolean
    distance?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | PickUpTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pickUpTask"]>

  export type PickUpTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    outletId?: boolean
    customerAddressId?: boolean
    assignedByAdminId?: boolean
    orderHeaderId?: boolean
    status?: boolean
    distance?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | PickUpTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pickUpTask"]>

  export type PickUpTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    outletId?: boolean
    customerAddressId?: boolean
    assignedByAdminId?: boolean
    orderHeaderId?: boolean
    status?: boolean
    distance?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | PickUpTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pickUpTask"]>

  export type PickUpTaskSelectScalar = {
    id?: boolean
    driverId?: boolean
    outletId?: boolean
    customerAddressId?: boolean
    assignedByAdminId?: boolean
    orderHeaderId?: boolean
    status?: boolean
    distance?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PickUpTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "driverId" | "outletId" | "customerAddressId" | "assignedByAdminId" | "orderHeaderId" | "status" | "distance" | "price" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["pickUpTask"]>
  export type PickUpTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | PickUpTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }
  export type PickUpTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | PickUpTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }
  export type PickUpTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | PickUpTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }

  export type $PickUpTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PickUpTask"
    objects: {
      driver: Prisma.$EmployeePayload<ExtArgs>
      assignedBy: Prisma.$EmployeePayload<ExtArgs> | null
      outlets: Prisma.$OutletPayload<ExtArgs>
      customerAddress: Prisma.$CustomerAddressPayload<ExtArgs>
      orderHeader: Prisma.$OrderHeaderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      driverId: string
      outletId: string
      customerAddressId: string
      assignedByAdminId: string
      orderHeaderId: string
      status: $Enums.PickupStatus
      distance: number
      price: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["pickUpTask"]>
    composites: {}
  }

  type PickUpTaskGetPayload<S extends boolean | null | undefined | PickUpTaskDefaultArgs> = $Result.GetResult<Prisma.$PickUpTaskPayload, S>

  type PickUpTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PickUpTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PickUpTaskCountAggregateInputType | true
    }

  export interface PickUpTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PickUpTask'], meta: { name: 'PickUpTask' } }
    /**
     * Find zero or one PickUpTask that matches the filter.
     * @param {PickUpTaskFindUniqueArgs} args - Arguments to find a PickUpTask
     * @example
     * // Get one PickUpTask
     * const pickUpTask = await prisma.pickUpTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PickUpTaskFindUniqueArgs>(args: SelectSubset<T, PickUpTaskFindUniqueArgs<ExtArgs>>): Prisma__PickUpTaskClient<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PickUpTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PickUpTaskFindUniqueOrThrowArgs} args - Arguments to find a PickUpTask
     * @example
     * // Get one PickUpTask
     * const pickUpTask = await prisma.pickUpTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PickUpTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, PickUpTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PickUpTaskClient<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PickUpTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickUpTaskFindFirstArgs} args - Arguments to find a PickUpTask
     * @example
     * // Get one PickUpTask
     * const pickUpTask = await prisma.pickUpTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PickUpTaskFindFirstArgs>(args?: SelectSubset<T, PickUpTaskFindFirstArgs<ExtArgs>>): Prisma__PickUpTaskClient<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PickUpTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickUpTaskFindFirstOrThrowArgs} args - Arguments to find a PickUpTask
     * @example
     * // Get one PickUpTask
     * const pickUpTask = await prisma.pickUpTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PickUpTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, PickUpTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__PickUpTaskClient<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PickUpTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickUpTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PickUpTasks
     * const pickUpTasks = await prisma.pickUpTask.findMany()
     * 
     * // Get first 10 PickUpTasks
     * const pickUpTasks = await prisma.pickUpTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pickUpTaskWithIdOnly = await prisma.pickUpTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PickUpTaskFindManyArgs>(args?: SelectSubset<T, PickUpTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PickUpTask.
     * @param {PickUpTaskCreateArgs} args - Arguments to create a PickUpTask.
     * @example
     * // Create one PickUpTask
     * const PickUpTask = await prisma.pickUpTask.create({
     *   data: {
     *     // ... data to create a PickUpTask
     *   }
     * })
     * 
     */
    create<T extends PickUpTaskCreateArgs>(args: SelectSubset<T, PickUpTaskCreateArgs<ExtArgs>>): Prisma__PickUpTaskClient<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PickUpTasks.
     * @param {PickUpTaskCreateManyArgs} args - Arguments to create many PickUpTasks.
     * @example
     * // Create many PickUpTasks
     * const pickUpTask = await prisma.pickUpTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PickUpTaskCreateManyArgs>(args?: SelectSubset<T, PickUpTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PickUpTasks and returns the data saved in the database.
     * @param {PickUpTaskCreateManyAndReturnArgs} args - Arguments to create many PickUpTasks.
     * @example
     * // Create many PickUpTasks
     * const pickUpTask = await prisma.pickUpTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PickUpTasks and only return the `id`
     * const pickUpTaskWithIdOnly = await prisma.pickUpTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PickUpTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, PickUpTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PickUpTask.
     * @param {PickUpTaskDeleteArgs} args - Arguments to delete one PickUpTask.
     * @example
     * // Delete one PickUpTask
     * const PickUpTask = await prisma.pickUpTask.delete({
     *   where: {
     *     // ... filter to delete one PickUpTask
     *   }
     * })
     * 
     */
    delete<T extends PickUpTaskDeleteArgs>(args: SelectSubset<T, PickUpTaskDeleteArgs<ExtArgs>>): Prisma__PickUpTaskClient<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PickUpTask.
     * @param {PickUpTaskUpdateArgs} args - Arguments to update one PickUpTask.
     * @example
     * // Update one PickUpTask
     * const pickUpTask = await prisma.pickUpTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PickUpTaskUpdateArgs>(args: SelectSubset<T, PickUpTaskUpdateArgs<ExtArgs>>): Prisma__PickUpTaskClient<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PickUpTasks.
     * @param {PickUpTaskDeleteManyArgs} args - Arguments to filter PickUpTasks to delete.
     * @example
     * // Delete a few PickUpTasks
     * const { count } = await prisma.pickUpTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PickUpTaskDeleteManyArgs>(args?: SelectSubset<T, PickUpTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PickUpTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickUpTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PickUpTasks
     * const pickUpTask = await prisma.pickUpTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PickUpTaskUpdateManyArgs>(args: SelectSubset<T, PickUpTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PickUpTasks and returns the data updated in the database.
     * @param {PickUpTaskUpdateManyAndReturnArgs} args - Arguments to update many PickUpTasks.
     * @example
     * // Update many PickUpTasks
     * const pickUpTask = await prisma.pickUpTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PickUpTasks and only return the `id`
     * const pickUpTaskWithIdOnly = await prisma.pickUpTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PickUpTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, PickUpTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PickUpTask.
     * @param {PickUpTaskUpsertArgs} args - Arguments to update or create a PickUpTask.
     * @example
     * // Update or create a PickUpTask
     * const pickUpTask = await prisma.pickUpTask.upsert({
     *   create: {
     *     // ... data to create a PickUpTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PickUpTask we want to update
     *   }
     * })
     */
    upsert<T extends PickUpTaskUpsertArgs>(args: SelectSubset<T, PickUpTaskUpsertArgs<ExtArgs>>): Prisma__PickUpTaskClient<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PickUpTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickUpTaskCountArgs} args - Arguments to filter PickUpTasks to count.
     * @example
     * // Count the number of PickUpTasks
     * const count = await prisma.pickUpTask.count({
     *   where: {
     *     // ... the filter for the PickUpTasks we want to count
     *   }
     * })
    **/
    count<T extends PickUpTaskCountArgs>(
      args?: Subset<T, PickUpTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PickUpTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PickUpTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickUpTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PickUpTaskAggregateArgs>(args: Subset<T, PickUpTaskAggregateArgs>): Prisma.PrismaPromise<GetPickUpTaskAggregateType<T>>

    /**
     * Group by PickUpTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickUpTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PickUpTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PickUpTaskGroupByArgs['orderBy'] }
        : { orderBy?: PickUpTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PickUpTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPickUpTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PickUpTask model
   */
  readonly fields: PickUpTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PickUpTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PickUpTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedBy<T extends PickUpTask$assignedByArgs<ExtArgs> = {}>(args?: Subset<T, PickUpTask$assignedByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    outlets<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customerAddress<T extends CustomerAddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAddressDefaultArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderHeader<T extends OrderHeaderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeaderDefaultArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PickUpTask model
   */
  interface PickUpTaskFieldRefs {
    readonly id: FieldRef<"PickUpTask", 'String'>
    readonly driverId: FieldRef<"PickUpTask", 'String'>
    readonly outletId: FieldRef<"PickUpTask", 'String'>
    readonly customerAddressId: FieldRef<"PickUpTask", 'String'>
    readonly assignedByAdminId: FieldRef<"PickUpTask", 'String'>
    readonly orderHeaderId: FieldRef<"PickUpTask", 'String'>
    readonly status: FieldRef<"PickUpTask", 'PickupStatus'>
    readonly distance: FieldRef<"PickUpTask", 'Int'>
    readonly price: FieldRef<"PickUpTask", 'Int'>
    readonly createdAt: FieldRef<"PickUpTask", 'DateTime'>
    readonly updatedAt: FieldRef<"PickUpTask", 'DateTime'>
    readonly deletedAt: FieldRef<"PickUpTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PickUpTask findUnique
   */
  export type PickUpTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    /**
     * Filter, which PickUpTask to fetch.
     */
    where: PickUpTaskWhereUniqueInput
  }

  /**
   * PickUpTask findUniqueOrThrow
   */
  export type PickUpTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    /**
     * Filter, which PickUpTask to fetch.
     */
    where: PickUpTaskWhereUniqueInput
  }

  /**
   * PickUpTask findFirst
   */
  export type PickUpTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    /**
     * Filter, which PickUpTask to fetch.
     */
    where?: PickUpTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickUpTasks to fetch.
     */
    orderBy?: PickUpTaskOrderByWithRelationInput | PickUpTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PickUpTasks.
     */
    cursor?: PickUpTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickUpTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickUpTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PickUpTasks.
     */
    distinct?: PickUpTaskScalarFieldEnum | PickUpTaskScalarFieldEnum[]
  }

  /**
   * PickUpTask findFirstOrThrow
   */
  export type PickUpTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    /**
     * Filter, which PickUpTask to fetch.
     */
    where?: PickUpTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickUpTasks to fetch.
     */
    orderBy?: PickUpTaskOrderByWithRelationInput | PickUpTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PickUpTasks.
     */
    cursor?: PickUpTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickUpTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickUpTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PickUpTasks.
     */
    distinct?: PickUpTaskScalarFieldEnum | PickUpTaskScalarFieldEnum[]
  }

  /**
   * PickUpTask findMany
   */
  export type PickUpTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    /**
     * Filter, which PickUpTasks to fetch.
     */
    where?: PickUpTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickUpTasks to fetch.
     */
    orderBy?: PickUpTaskOrderByWithRelationInput | PickUpTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PickUpTasks.
     */
    cursor?: PickUpTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickUpTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickUpTasks.
     */
    skip?: number
    distinct?: PickUpTaskScalarFieldEnum | PickUpTaskScalarFieldEnum[]
  }

  /**
   * PickUpTask create
   */
  export type PickUpTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a PickUpTask.
     */
    data: XOR<PickUpTaskCreateInput, PickUpTaskUncheckedCreateInput>
  }

  /**
   * PickUpTask createMany
   */
  export type PickUpTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PickUpTasks.
     */
    data: PickUpTaskCreateManyInput | PickUpTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PickUpTask createManyAndReturn
   */
  export type PickUpTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * The data used to create many PickUpTasks.
     */
    data: PickUpTaskCreateManyInput | PickUpTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PickUpTask update
   */
  export type PickUpTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a PickUpTask.
     */
    data: XOR<PickUpTaskUpdateInput, PickUpTaskUncheckedUpdateInput>
    /**
     * Choose, which PickUpTask to update.
     */
    where: PickUpTaskWhereUniqueInput
  }

  /**
   * PickUpTask updateMany
   */
  export type PickUpTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PickUpTasks.
     */
    data: XOR<PickUpTaskUpdateManyMutationInput, PickUpTaskUncheckedUpdateManyInput>
    /**
     * Filter which PickUpTasks to update
     */
    where?: PickUpTaskWhereInput
    /**
     * Limit how many PickUpTasks to update.
     */
    limit?: number
  }

  /**
   * PickUpTask updateManyAndReturn
   */
  export type PickUpTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * The data used to update PickUpTasks.
     */
    data: XOR<PickUpTaskUpdateManyMutationInput, PickUpTaskUncheckedUpdateManyInput>
    /**
     * Filter which PickUpTasks to update
     */
    where?: PickUpTaskWhereInput
    /**
     * Limit how many PickUpTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PickUpTask upsert
   */
  export type PickUpTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the PickUpTask to update in case it exists.
     */
    where: PickUpTaskWhereUniqueInput
    /**
     * In case the PickUpTask found by the `where` argument doesn't exist, create a new PickUpTask with this data.
     */
    create: XOR<PickUpTaskCreateInput, PickUpTaskUncheckedCreateInput>
    /**
     * In case the PickUpTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PickUpTaskUpdateInput, PickUpTaskUncheckedUpdateInput>
  }

  /**
   * PickUpTask delete
   */
  export type PickUpTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    /**
     * Filter which PickUpTask to delete.
     */
    where: PickUpTaskWhereUniqueInput
  }

  /**
   * PickUpTask deleteMany
   */
  export type PickUpTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PickUpTasks to delete
     */
    where?: PickUpTaskWhereInput
    /**
     * Limit how many PickUpTasks to delete.
     */
    limit?: number
  }

  /**
   * PickUpTask.assignedBy
   */
  export type PickUpTask$assignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * PickUpTask without action
   */
  export type PickUpTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryTask
   */

  export type AggregateDeliveryTask = {
    _count: DeliveryTaskCountAggregateOutputType | null
    _avg: DeliveryTaskAvgAggregateOutputType | null
    _sum: DeliveryTaskSumAggregateOutputType | null
    _min: DeliveryTaskMinAggregateOutputType | null
    _max: DeliveryTaskMaxAggregateOutputType | null
  }

  export type DeliveryTaskAvgAggregateOutputType = {
    distance: number | null
    price: number | null
  }

  export type DeliveryTaskSumAggregateOutputType = {
    distance: number | null
    price: number | null
  }

  export type DeliveryTaskMinAggregateOutputType = {
    id: string | null
    driverId: string | null
    outletId: string | null
    customerAddressId: string | null
    assignedByAdminId: string | null
    orderHeaderId: string | null
    status: $Enums.DeilveryStatus | null
    distance: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DeliveryTaskMaxAggregateOutputType = {
    id: string | null
    driverId: string | null
    outletId: string | null
    customerAddressId: string | null
    assignedByAdminId: string | null
    orderHeaderId: string | null
    status: $Enums.DeilveryStatus | null
    distance: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DeliveryTaskCountAggregateOutputType = {
    id: number
    driverId: number
    outletId: number
    customerAddressId: number
    assignedByAdminId: number
    orderHeaderId: number
    status: number
    distance: number
    price: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DeliveryTaskAvgAggregateInputType = {
    distance?: true
    price?: true
  }

  export type DeliveryTaskSumAggregateInputType = {
    distance?: true
    price?: true
  }

  export type DeliveryTaskMinAggregateInputType = {
    id?: true
    driverId?: true
    outletId?: true
    customerAddressId?: true
    assignedByAdminId?: true
    orderHeaderId?: true
    status?: true
    distance?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DeliveryTaskMaxAggregateInputType = {
    id?: true
    driverId?: true
    outletId?: true
    customerAddressId?: true
    assignedByAdminId?: true
    orderHeaderId?: true
    status?: true
    distance?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DeliveryTaskCountAggregateInputType = {
    id?: true
    driverId?: true
    outletId?: true
    customerAddressId?: true
    assignedByAdminId?: true
    orderHeaderId?: true
    status?: true
    distance?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DeliveryTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryTask to aggregate.
     */
    where?: DeliveryTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTasks to fetch.
     */
    orderBy?: DeliveryTaskOrderByWithRelationInput | DeliveryTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryTasks
    **/
    _count?: true | DeliveryTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryTaskMaxAggregateInputType
  }

  export type GetDeliveryTaskAggregateType<T extends DeliveryTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryTask[P]>
      : GetScalarType<T[P], AggregateDeliveryTask[P]>
  }




  export type DeliveryTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTaskWhereInput
    orderBy?: DeliveryTaskOrderByWithAggregationInput | DeliveryTaskOrderByWithAggregationInput[]
    by: DeliveryTaskScalarFieldEnum[] | DeliveryTaskScalarFieldEnum
    having?: DeliveryTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryTaskCountAggregateInputType | true
    _avg?: DeliveryTaskAvgAggregateInputType
    _sum?: DeliveryTaskSumAggregateInputType
    _min?: DeliveryTaskMinAggregateInputType
    _max?: DeliveryTaskMaxAggregateInputType
  }

  export type DeliveryTaskGroupByOutputType = {
    id: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: DeliveryTaskCountAggregateOutputType | null
    _avg: DeliveryTaskAvgAggregateOutputType | null
    _sum: DeliveryTaskSumAggregateOutputType | null
    _min: DeliveryTaskMinAggregateOutputType | null
    _max: DeliveryTaskMaxAggregateOutputType | null
  }

  type GetDeliveryTaskGroupByPayload<T extends DeliveryTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryTaskGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryTaskGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    outletId?: boolean
    customerAddressId?: boolean
    assignedByAdminId?: boolean
    orderHeaderId?: boolean
    status?: boolean
    distance?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | DeliveryTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTask"]>

  export type DeliveryTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    outletId?: boolean
    customerAddressId?: boolean
    assignedByAdminId?: boolean
    orderHeaderId?: boolean
    status?: boolean
    distance?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | DeliveryTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTask"]>

  export type DeliveryTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    outletId?: boolean
    customerAddressId?: boolean
    assignedByAdminId?: boolean
    orderHeaderId?: boolean
    status?: boolean
    distance?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | DeliveryTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTask"]>

  export type DeliveryTaskSelectScalar = {
    id?: boolean
    driverId?: boolean
    outletId?: boolean
    customerAddressId?: boolean
    assignedByAdminId?: boolean
    orderHeaderId?: boolean
    status?: boolean
    distance?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type DeliveryTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "driverId" | "outletId" | "customerAddressId" | "assignedByAdminId" | "orderHeaderId" | "status" | "distance" | "price" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["deliveryTask"]>
  export type DeliveryTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | DeliveryTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }
  export type DeliveryTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | DeliveryTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }
  export type DeliveryTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedBy?: boolean | DeliveryTask$assignedByArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    customerAddress?: boolean | CustomerAddressDefaultArgs<ExtArgs>
    orderHeader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }

  export type $DeliveryTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryTask"
    objects: {
      driver: Prisma.$EmployeePayload<ExtArgs>
      assignedBy: Prisma.$EmployeePayload<ExtArgs> | null
      outlets: Prisma.$OutletPayload<ExtArgs>
      customerAddress: Prisma.$CustomerAddressPayload<ExtArgs>
      orderHeader: Prisma.$OrderHeaderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      driverId: string
      outletId: string
      customerAddressId: string
      assignedByAdminId: string
      orderHeaderId: string
      status: $Enums.DeilveryStatus
      distance: number
      price: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["deliveryTask"]>
    composites: {}
  }

  type DeliveryTaskGetPayload<S extends boolean | null | undefined | DeliveryTaskDefaultArgs> = $Result.GetResult<Prisma.$DeliveryTaskPayload, S>

  type DeliveryTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryTaskCountAggregateInputType | true
    }

  export interface DeliveryTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryTask'], meta: { name: 'DeliveryTask' } }
    /**
     * Find zero or one DeliveryTask that matches the filter.
     * @param {DeliveryTaskFindUniqueArgs} args - Arguments to find a DeliveryTask
     * @example
     * // Get one DeliveryTask
     * const deliveryTask = await prisma.deliveryTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryTaskFindUniqueArgs>(args: SelectSubset<T, DeliveryTaskFindUniqueArgs<ExtArgs>>): Prisma__DeliveryTaskClient<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryTaskFindUniqueOrThrowArgs} args - Arguments to find a DeliveryTask
     * @example
     * // Get one DeliveryTask
     * const deliveryTask = await prisma.deliveryTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryTaskClient<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTaskFindFirstArgs} args - Arguments to find a DeliveryTask
     * @example
     * // Get one DeliveryTask
     * const deliveryTask = await prisma.deliveryTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryTaskFindFirstArgs>(args?: SelectSubset<T, DeliveryTaskFindFirstArgs<ExtArgs>>): Prisma__DeliveryTaskClient<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTaskFindFirstOrThrowArgs} args - Arguments to find a DeliveryTask
     * @example
     * // Get one DeliveryTask
     * const deliveryTask = await prisma.deliveryTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryTaskClient<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryTasks
     * const deliveryTasks = await prisma.deliveryTask.findMany()
     * 
     * // Get first 10 DeliveryTasks
     * const deliveryTasks = await prisma.deliveryTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryTaskWithIdOnly = await prisma.deliveryTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryTaskFindManyArgs>(args?: SelectSubset<T, DeliveryTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryTask.
     * @param {DeliveryTaskCreateArgs} args - Arguments to create a DeliveryTask.
     * @example
     * // Create one DeliveryTask
     * const DeliveryTask = await prisma.deliveryTask.create({
     *   data: {
     *     // ... data to create a DeliveryTask
     *   }
     * })
     * 
     */
    create<T extends DeliveryTaskCreateArgs>(args: SelectSubset<T, DeliveryTaskCreateArgs<ExtArgs>>): Prisma__DeliveryTaskClient<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryTasks.
     * @param {DeliveryTaskCreateManyArgs} args - Arguments to create many DeliveryTasks.
     * @example
     * // Create many DeliveryTasks
     * const deliveryTask = await prisma.deliveryTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryTaskCreateManyArgs>(args?: SelectSubset<T, DeliveryTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryTasks and returns the data saved in the database.
     * @param {DeliveryTaskCreateManyAndReturnArgs} args - Arguments to create many DeliveryTasks.
     * @example
     * // Create many DeliveryTasks
     * const deliveryTask = await prisma.deliveryTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryTasks and only return the `id`
     * const deliveryTaskWithIdOnly = await prisma.deliveryTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryTask.
     * @param {DeliveryTaskDeleteArgs} args - Arguments to delete one DeliveryTask.
     * @example
     * // Delete one DeliveryTask
     * const DeliveryTask = await prisma.deliveryTask.delete({
     *   where: {
     *     // ... filter to delete one DeliveryTask
     *   }
     * })
     * 
     */
    delete<T extends DeliveryTaskDeleteArgs>(args: SelectSubset<T, DeliveryTaskDeleteArgs<ExtArgs>>): Prisma__DeliveryTaskClient<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryTask.
     * @param {DeliveryTaskUpdateArgs} args - Arguments to update one DeliveryTask.
     * @example
     * // Update one DeliveryTask
     * const deliveryTask = await prisma.deliveryTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryTaskUpdateArgs>(args: SelectSubset<T, DeliveryTaskUpdateArgs<ExtArgs>>): Prisma__DeliveryTaskClient<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryTasks.
     * @param {DeliveryTaskDeleteManyArgs} args - Arguments to filter DeliveryTasks to delete.
     * @example
     * // Delete a few DeliveryTasks
     * const { count } = await prisma.deliveryTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryTaskDeleteManyArgs>(args?: SelectSubset<T, DeliveryTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryTasks
     * const deliveryTask = await prisma.deliveryTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryTaskUpdateManyArgs>(args: SelectSubset<T, DeliveryTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTasks and returns the data updated in the database.
     * @param {DeliveryTaskUpdateManyAndReturnArgs} args - Arguments to update many DeliveryTasks.
     * @example
     * // Update many DeliveryTasks
     * const deliveryTask = await prisma.deliveryTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryTasks and only return the `id`
     * const deliveryTaskWithIdOnly = await prisma.deliveryTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryTask.
     * @param {DeliveryTaskUpsertArgs} args - Arguments to update or create a DeliveryTask.
     * @example
     * // Update or create a DeliveryTask
     * const deliveryTask = await prisma.deliveryTask.upsert({
     *   create: {
     *     // ... data to create a DeliveryTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryTask we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryTaskUpsertArgs>(args: SelectSubset<T, DeliveryTaskUpsertArgs<ExtArgs>>): Prisma__DeliveryTaskClient<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTaskCountArgs} args - Arguments to filter DeliveryTasks to count.
     * @example
     * // Count the number of DeliveryTasks
     * const count = await prisma.deliveryTask.count({
     *   where: {
     *     // ... the filter for the DeliveryTasks we want to count
     *   }
     * })
    **/
    count<T extends DeliveryTaskCountArgs>(
      args?: Subset<T, DeliveryTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryTaskAggregateArgs>(args: Subset<T, DeliveryTaskAggregateArgs>): Prisma.PrismaPromise<GetDeliveryTaskAggregateType<T>>

    /**
     * Group by DeliveryTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryTaskGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryTask model
   */
  readonly fields: DeliveryTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedBy<T extends DeliveryTask$assignedByArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryTask$assignedByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    outlets<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customerAddress<T extends CustomerAddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAddressDefaultArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderHeader<T extends OrderHeaderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeaderDefaultArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryTask model
   */
  interface DeliveryTaskFieldRefs {
    readonly id: FieldRef<"DeliveryTask", 'String'>
    readonly driverId: FieldRef<"DeliveryTask", 'String'>
    readonly outletId: FieldRef<"DeliveryTask", 'String'>
    readonly customerAddressId: FieldRef<"DeliveryTask", 'String'>
    readonly assignedByAdminId: FieldRef<"DeliveryTask", 'String'>
    readonly orderHeaderId: FieldRef<"DeliveryTask", 'String'>
    readonly status: FieldRef<"DeliveryTask", 'DeilveryStatus'>
    readonly distance: FieldRef<"DeliveryTask", 'Int'>
    readonly price: FieldRef<"DeliveryTask", 'Int'>
    readonly createdAt: FieldRef<"DeliveryTask", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryTask", 'DateTime'>
    readonly deletedAt: FieldRef<"DeliveryTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryTask findUnique
   */
  export type DeliveryTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTask to fetch.
     */
    where: DeliveryTaskWhereUniqueInput
  }

  /**
   * DeliveryTask findUniqueOrThrow
   */
  export type DeliveryTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTask to fetch.
     */
    where: DeliveryTaskWhereUniqueInput
  }

  /**
   * DeliveryTask findFirst
   */
  export type DeliveryTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTask to fetch.
     */
    where?: DeliveryTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTasks to fetch.
     */
    orderBy?: DeliveryTaskOrderByWithRelationInput | DeliveryTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTasks.
     */
    cursor?: DeliveryTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTasks.
     */
    distinct?: DeliveryTaskScalarFieldEnum | DeliveryTaskScalarFieldEnum[]
  }

  /**
   * DeliveryTask findFirstOrThrow
   */
  export type DeliveryTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTask to fetch.
     */
    where?: DeliveryTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTasks to fetch.
     */
    orderBy?: DeliveryTaskOrderByWithRelationInput | DeliveryTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTasks.
     */
    cursor?: DeliveryTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTasks.
     */
    distinct?: DeliveryTaskScalarFieldEnum | DeliveryTaskScalarFieldEnum[]
  }

  /**
   * DeliveryTask findMany
   */
  export type DeliveryTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTasks to fetch.
     */
    where?: DeliveryTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTasks to fetch.
     */
    orderBy?: DeliveryTaskOrderByWithRelationInput | DeliveryTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryTasks.
     */
    cursor?: DeliveryTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTasks.
     */
    skip?: number
    distinct?: DeliveryTaskScalarFieldEnum | DeliveryTaskScalarFieldEnum[]
  }

  /**
   * DeliveryTask create
   */
  export type DeliveryTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryTask.
     */
    data: XOR<DeliveryTaskCreateInput, DeliveryTaskUncheckedCreateInput>
  }

  /**
   * DeliveryTask createMany
   */
  export type DeliveryTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryTasks.
     */
    data: DeliveryTaskCreateManyInput | DeliveryTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryTask createManyAndReturn
   */
  export type DeliveryTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryTasks.
     */
    data: DeliveryTaskCreateManyInput | DeliveryTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryTask update
   */
  export type DeliveryTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryTask.
     */
    data: XOR<DeliveryTaskUpdateInput, DeliveryTaskUncheckedUpdateInput>
    /**
     * Choose, which DeliveryTask to update.
     */
    where: DeliveryTaskWhereUniqueInput
  }

  /**
   * DeliveryTask updateMany
   */
  export type DeliveryTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryTasks.
     */
    data: XOR<DeliveryTaskUpdateManyMutationInput, DeliveryTaskUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTasks to update
     */
    where?: DeliveryTaskWhereInput
    /**
     * Limit how many DeliveryTasks to update.
     */
    limit?: number
  }

  /**
   * DeliveryTask updateManyAndReturn
   */
  export type DeliveryTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryTasks.
     */
    data: XOR<DeliveryTaskUpdateManyMutationInput, DeliveryTaskUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTasks to update
     */
    where?: DeliveryTaskWhereInput
    /**
     * Limit how many DeliveryTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryTask upsert
   */
  export type DeliveryTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryTask to update in case it exists.
     */
    where: DeliveryTaskWhereUniqueInput
    /**
     * In case the DeliveryTask found by the `where` argument doesn't exist, create a new DeliveryTask with this data.
     */
    create: XOR<DeliveryTaskCreateInput, DeliveryTaskUncheckedCreateInput>
    /**
     * In case the DeliveryTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryTaskUpdateInput, DeliveryTaskUncheckedUpdateInput>
  }

  /**
   * DeliveryTask delete
   */
  export type DeliveryTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    /**
     * Filter which DeliveryTask to delete.
     */
    where: DeliveryTaskWhereUniqueInput
  }

  /**
   * DeliveryTask deleteMany
   */
  export type DeliveryTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryTasks to delete
     */
    where?: DeliveryTaskWhereInput
    /**
     * Limit how many DeliveryTasks to delete.
     */
    limit?: number
  }

  /**
   * DeliveryTask.assignedBy
   */
  export type DeliveryTask$assignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * DeliveryTask without action
   */
  export type DeliveryTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    shiftId: string | null
    outletId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    clockInAt: Date | null
    clockOutAt: Date | null
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
    notes: string | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    shiftId: string | null
    outletId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    clockInAt: Date | null
    clockOutAt: Date | null
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
    notes: string | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    employeeId: number
    shiftId: number
    outletId: number
    date: number
    status: number
    clockInAt: number
    clockOutAt: number
    workMinutes: number
    lateMinutes: number
    earlyLeaveMin: number
    notes: number
    approvedById: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
  }

  export type AttendanceSumAggregateInputType = {
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    outletId?: true
    date?: true
    status?: true
    clockInAt?: true
    clockOutAt?: true
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
    notes?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    outletId?: true
    date?: true
    status?: true
    clockInAt?: true
    clockOutAt?: true
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
    notes?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    outletId?: true
    date?: true
    status?: true
    clockInAt?: true
    clockOutAt?: true
    workMinutes?: true
    lateMinutes?: true
    earlyLeaveMin?: true
    notes?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date
    status: $Enums.AttendanceStatus
    clockInAt: Date | null
    clockOutAt: Date | null
    workMinutes: number | null
    lateMinutes: number | null
    earlyLeaveMin: number | null
    notes: string | null
    approvedById: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    outletId?: boolean
    date?: boolean
    status?: boolean
    clockInAt?: boolean
    clockOutAt?: boolean
    workMinutes?: boolean
    lateMinutes?: boolean
    earlyLeaveMin?: boolean
    notes?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    outletId?: boolean
    date?: boolean
    status?: boolean
    clockInAt?: boolean
    clockOutAt?: boolean
    workMinutes?: boolean
    lateMinutes?: boolean
    earlyLeaveMin?: boolean
    notes?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    outletId?: boolean
    date?: boolean
    status?: boolean
    clockInAt?: boolean
    clockOutAt?: boolean
    workMinutes?: boolean
    lateMinutes?: boolean
    earlyLeaveMin?: boolean
    notes?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    outletId?: boolean
    date?: boolean
    status?: boolean
    clockInAt?: boolean
    clockOutAt?: boolean
    workMinutes?: boolean
    lateMinutes?: boolean
    earlyLeaveMin?: boolean
    notes?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "shiftId" | "outletId" | "date" | "status" | "clockInAt" | "clockOutAt" | "workMinutes" | "lateMinutes" | "earlyLeaveMin" | "notes" | "approvedById" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    approvedBy?: boolean | Attendance$approvedByArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>
      outlet: Prisma.$OutletPayload<ExtArgs>
      approvedBy: Prisma.$EmployeePayload<ExtArgs> | null
      shift: Prisma.$ShiftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      shiftId: string
      outletId: string
      date: Date
      status: $Enums.AttendanceStatus
      clockInAt: Date | null
      clockOutAt: Date | null
      workMinutes: number | null
      lateMinutes: number | null
      earlyLeaveMin: number | null
      notes: string | null
      approvedById: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Attendance$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$approvedByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shift<T extends ShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftDefaultArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly employeeId: FieldRef<"Attendance", 'String'>
    readonly shiftId: FieldRef<"Attendance", 'String'>
    readonly outletId: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly clockInAt: FieldRef<"Attendance", 'DateTime'>
    readonly clockOutAt: FieldRef<"Attendance", 'DateTime'>
    readonly workMinutes: FieldRef<"Attendance", 'Int'>
    readonly lateMinutes: FieldRef<"Attendance", 'Int'>
    readonly earlyLeaveMin: FieldRef<"Attendance", 'Int'>
    readonly notes: FieldRef<"Attendance", 'String'>
    readonly approvedById: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
    readonly deletedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance.approvedBy
   */
  export type Attendance$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Outlet
   */

  export type AggregateOutlet = {
    _count: OutletCountAggregateOutputType | null
    _avg: OutletAvgAggregateOutputType | null
    _sum: OutletSumAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  export type OutletAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    coverageArea: number | null
  }

  export type OutletSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    coverageArea: number | null
  }

  export type OutletMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phoneNumber: string | null
    city: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    coverageArea: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OutletMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phoneNumber: string | null
    city: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    coverageArea: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OutletCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phoneNumber: number
    city: number
    postalCode: number
    latitude: number
    longitude: number
    coverageArea: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OutletAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    coverageArea?: true
  }

  export type OutletSumAggregateInputType = {
    latitude?: true
    longitude?: true
    coverageArea?: true
  }

  export type OutletMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phoneNumber?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    coverageArea?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OutletMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phoneNumber?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    coverageArea?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OutletCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phoneNumber?: true
    city?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    coverageArea?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OutletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outlet to aggregate.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Outlets
    **/
    _count?: true | OutletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutletMaxAggregateInputType
  }

  export type GetOutletAggregateType<T extends OutletAggregateArgs> = {
        [P in keyof T & keyof AggregateOutlet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutlet[P]>
      : GetScalarType<T[P], AggregateOutlet[P]>
  }




  export type OutletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutletWhereInput
    orderBy?: OutletOrderByWithAggregationInput | OutletOrderByWithAggregationInput[]
    by: OutletScalarFieldEnum[] | OutletScalarFieldEnum
    having?: OutletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutletCountAggregateInputType | true
    _avg?: OutletAvgAggregateInputType
    _sum?: OutletSumAggregateInputType
    _min?: OutletMinAggregateInputType
    _max?: OutletMaxAggregateInputType
  }

  export type OutletGroupByOutputType = {
    id: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OutletCountAggregateOutputType | null
    _avg: OutletAvgAggregateOutputType | null
    _sum: OutletSumAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  type GetOutletGroupByPayload<T extends OutletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutletGroupByOutputType[P]>
            : GetScalarType<T[P], OutletGroupByOutputType[P]>
        }
      >
    >


  export type OutletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    coverageArea?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Employee?: boolean | Outlet$EmployeeArgs<ExtArgs>
    Attendance?: boolean | Outlet$AttendanceArgs<ExtArgs>
    OutletSchedule?: boolean | Outlet$OutletScheduleArgs<ExtArgs>
    orderHeader?: boolean | Outlet$orderHeaderArgs<ExtArgs>
    workerTasks?: boolean | Outlet$workerTasksArgs<ExtArgs>
    PickUpTask?: boolean | Outlet$PickUpTaskArgs<ExtArgs>
    DeliveryTask?: boolean | Outlet$DeliveryTaskArgs<ExtArgs>
    _count?: boolean | OutletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outlet"]>

  export type OutletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    coverageArea?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["outlet"]>

  export type OutletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    coverageArea?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["outlet"]>

  export type OutletSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    city?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    coverageArea?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OutletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phoneNumber" | "city" | "postalCode" | "latitude" | "longitude" | "coverageArea" | "isActive" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["outlet"]>
  export type OutletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | Outlet$EmployeeArgs<ExtArgs>
    Attendance?: boolean | Outlet$AttendanceArgs<ExtArgs>
    OutletSchedule?: boolean | Outlet$OutletScheduleArgs<ExtArgs>
    orderHeader?: boolean | Outlet$orderHeaderArgs<ExtArgs>
    workerTasks?: boolean | Outlet$workerTasksArgs<ExtArgs>
    PickUpTask?: boolean | Outlet$PickUpTaskArgs<ExtArgs>
    DeliveryTask?: boolean | Outlet$DeliveryTaskArgs<ExtArgs>
    _count?: boolean | OutletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OutletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OutletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OutletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Outlet"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>[]
      Attendance: Prisma.$AttendancePayload<ExtArgs>[]
      OutletSchedule: Prisma.$OutletSchedulePayload<ExtArgs>[]
      orderHeader: Prisma.$OrderHeaderPayload<ExtArgs>[]
      workerTasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
      PickUpTask: Prisma.$PickUpTaskPayload<ExtArgs>[]
      DeliveryTask: Prisma.$DeliveryTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phoneNumber: string
      city: string
      postalCode: string
      latitude: number
      longitude: number
      coverageArea: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["outlet"]>
    composites: {}
  }

  type OutletGetPayload<S extends boolean | null | undefined | OutletDefaultArgs> = $Result.GetResult<Prisma.$OutletPayload, S>

  type OutletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutletCountAggregateInputType | true
    }

  export interface OutletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Outlet'], meta: { name: 'Outlet' } }
    /**
     * Find zero or one Outlet that matches the filter.
     * @param {OutletFindUniqueArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutletFindUniqueArgs>(args: SelectSubset<T, OutletFindUniqueArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Outlet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutletFindUniqueOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutletFindUniqueOrThrowArgs>(args: SelectSubset<T, OutletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outlet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletFindFirstArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutletFindFirstArgs>(args?: SelectSubset<T, OutletFindFirstArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outlet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletFindFirstOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutletFindFirstOrThrowArgs>(args?: SelectSubset<T, OutletFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Outlets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Outlets
     * const outlets = await prisma.outlet.findMany()
     * 
     * // Get first 10 Outlets
     * const outlets = await prisma.outlet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outletWithIdOnly = await prisma.outlet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutletFindManyArgs>(args?: SelectSubset<T, OutletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Outlet.
     * @param {OutletCreateArgs} args - Arguments to create a Outlet.
     * @example
     * // Create one Outlet
     * const Outlet = await prisma.outlet.create({
     *   data: {
     *     // ... data to create a Outlet
     *   }
     * })
     * 
     */
    create<T extends OutletCreateArgs>(args: SelectSubset<T, OutletCreateArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Outlets.
     * @param {OutletCreateManyArgs} args - Arguments to create many Outlets.
     * @example
     * // Create many Outlets
     * const outlet = await prisma.outlet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutletCreateManyArgs>(args?: SelectSubset<T, OutletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Outlets and returns the data saved in the database.
     * @param {OutletCreateManyAndReturnArgs} args - Arguments to create many Outlets.
     * @example
     * // Create many Outlets
     * const outlet = await prisma.outlet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Outlets and only return the `id`
     * const outletWithIdOnly = await prisma.outlet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutletCreateManyAndReturnArgs>(args?: SelectSubset<T, OutletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Outlet.
     * @param {OutletDeleteArgs} args - Arguments to delete one Outlet.
     * @example
     * // Delete one Outlet
     * const Outlet = await prisma.outlet.delete({
     *   where: {
     *     // ... filter to delete one Outlet
     *   }
     * })
     * 
     */
    delete<T extends OutletDeleteArgs>(args: SelectSubset<T, OutletDeleteArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Outlet.
     * @param {OutletUpdateArgs} args - Arguments to update one Outlet.
     * @example
     * // Update one Outlet
     * const outlet = await prisma.outlet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutletUpdateArgs>(args: SelectSubset<T, OutletUpdateArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Outlets.
     * @param {OutletDeleteManyArgs} args - Arguments to filter Outlets to delete.
     * @example
     * // Delete a few Outlets
     * const { count } = await prisma.outlet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutletDeleteManyArgs>(args?: SelectSubset<T, OutletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Outlets
     * const outlet = await prisma.outlet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutletUpdateManyArgs>(args: SelectSubset<T, OutletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outlets and returns the data updated in the database.
     * @param {OutletUpdateManyAndReturnArgs} args - Arguments to update many Outlets.
     * @example
     * // Update many Outlets
     * const outlet = await prisma.outlet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Outlets and only return the `id`
     * const outletWithIdOnly = await prisma.outlet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutletUpdateManyAndReturnArgs>(args: SelectSubset<T, OutletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Outlet.
     * @param {OutletUpsertArgs} args - Arguments to update or create a Outlet.
     * @example
     * // Update or create a Outlet
     * const outlet = await prisma.outlet.upsert({
     *   create: {
     *     // ... data to create a Outlet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Outlet we want to update
     *   }
     * })
     */
    upsert<T extends OutletUpsertArgs>(args: SelectSubset<T, OutletUpsertArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletCountArgs} args - Arguments to filter Outlets to count.
     * @example
     * // Count the number of Outlets
     * const count = await prisma.outlet.count({
     *   where: {
     *     // ... the filter for the Outlets we want to count
     *   }
     * })
    **/
    count<T extends OutletCountArgs>(
      args?: Subset<T, OutletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutletAggregateArgs>(args: Subset<T, OutletAggregateArgs>): Prisma.PrismaPromise<GetOutletAggregateType<T>>

    /**
     * Group by Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutletGroupByArgs['orderBy'] }
        : { orderBy?: OutletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Outlet model
   */
  readonly fields: OutletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Outlet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends Outlet$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Attendance<T extends Outlet$AttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$AttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OutletSchedule<T extends Outlet$OutletScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$OutletScheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderHeader<T extends Outlet$orderHeaderArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$orderHeaderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerTasks<T extends Outlet$workerTasksArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$workerTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PickUpTask<T extends Outlet$PickUpTaskArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$PickUpTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeliveryTask<T extends Outlet$DeliveryTaskArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$DeliveryTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Outlet model
   */
  interface OutletFieldRefs {
    readonly id: FieldRef<"Outlet", 'String'>
    readonly name: FieldRef<"Outlet", 'String'>
    readonly address: FieldRef<"Outlet", 'String'>
    readonly phoneNumber: FieldRef<"Outlet", 'String'>
    readonly city: FieldRef<"Outlet", 'String'>
    readonly postalCode: FieldRef<"Outlet", 'String'>
    readonly latitude: FieldRef<"Outlet", 'Float'>
    readonly longitude: FieldRef<"Outlet", 'Float'>
    readonly coverageArea: FieldRef<"Outlet", 'Int'>
    readonly isActive: FieldRef<"Outlet", 'Boolean'>
    readonly createdAt: FieldRef<"Outlet", 'DateTime'>
    readonly updatedAt: FieldRef<"Outlet", 'DateTime'>
    readonly deletedAt: FieldRef<"Outlet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Outlet findUnique
   */
  export type OutletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet findUniqueOrThrow
   */
  export type OutletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet findFirst
   */
  export type OutletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outlets.
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outlets.
     */
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Outlet findFirstOrThrow
   */
  export type OutletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outlets.
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outlets.
     */
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Outlet findMany
   */
  export type OutletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlets to fetch.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Outlets.
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Outlet create
   */
  export type OutletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * The data needed to create a Outlet.
     */
    data: XOR<OutletCreateInput, OutletUncheckedCreateInput>
  }

  /**
   * Outlet createMany
   */
  export type OutletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Outlets.
     */
    data: OutletCreateManyInput | OutletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Outlet createManyAndReturn
   */
  export type OutletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * The data used to create many Outlets.
     */
    data: OutletCreateManyInput | OutletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Outlet update
   */
  export type OutletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * The data needed to update a Outlet.
     */
    data: XOR<OutletUpdateInput, OutletUncheckedUpdateInput>
    /**
     * Choose, which Outlet to update.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet updateMany
   */
  export type OutletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Outlets.
     */
    data: XOR<OutletUpdateManyMutationInput, OutletUncheckedUpdateManyInput>
    /**
     * Filter which Outlets to update
     */
    where?: OutletWhereInput
    /**
     * Limit how many Outlets to update.
     */
    limit?: number
  }

  /**
   * Outlet updateManyAndReturn
   */
  export type OutletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * The data used to update Outlets.
     */
    data: XOR<OutletUpdateManyMutationInput, OutletUncheckedUpdateManyInput>
    /**
     * Filter which Outlets to update
     */
    where?: OutletWhereInput
    /**
     * Limit how many Outlets to update.
     */
    limit?: number
  }

  /**
   * Outlet upsert
   */
  export type OutletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * The filter to search for the Outlet to update in case it exists.
     */
    where: OutletWhereUniqueInput
    /**
     * In case the Outlet found by the `where` argument doesn't exist, create a new Outlet with this data.
     */
    create: XOR<OutletCreateInput, OutletUncheckedCreateInput>
    /**
     * In case the Outlet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutletUpdateInput, OutletUncheckedUpdateInput>
  }

  /**
   * Outlet delete
   */
  export type OutletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter which Outlet to delete.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet deleteMany
   */
  export type OutletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outlets to delete
     */
    where?: OutletWhereInput
    /**
     * Limit how many Outlets to delete.
     */
    limit?: number
  }

  /**
   * Outlet.Employee
   */
  export type Outlet$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Outlet.Attendance
   */
  export type Outlet$AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Outlet.OutletSchedule
   */
  export type Outlet$OutletScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    where?: OutletScheduleWhereInput
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    cursor?: OutletScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutletScheduleScalarFieldEnum | OutletScheduleScalarFieldEnum[]
  }

  /**
   * Outlet.orderHeader
   */
  export type Outlet$orderHeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    where?: OrderHeaderWhereInput
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    cursor?: OrderHeaderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * Outlet.workerTasks
   */
  export type Outlet$workerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * Outlet.PickUpTask
   */
  export type Outlet$PickUpTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    where?: PickUpTaskWhereInput
    orderBy?: PickUpTaskOrderByWithRelationInput | PickUpTaskOrderByWithRelationInput[]
    cursor?: PickUpTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PickUpTaskScalarFieldEnum | PickUpTaskScalarFieldEnum[]
  }

  /**
   * Outlet.DeliveryTask
   */
  export type Outlet$DeliveryTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    where?: DeliveryTaskWhereInput
    orderBy?: DeliveryTaskOrderByWithRelationInput | DeliveryTaskOrderByWithRelationInput[]
    cursor?: DeliveryTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryTaskScalarFieldEnum | DeliveryTaskScalarFieldEnum[]
  }

  /**
   * Outlet without action
   */
  export type OutletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
  }


  /**
   * Model OutletSchedule
   */

  export type AggregateOutletSchedule = {
    _count: OutletScheduleCountAggregateOutputType | null
    _min: OutletScheduleMinAggregateOutputType | null
    _max: OutletScheduleMaxAggregateOutputType | null
  }

  export type OutletScheduleMinAggregateOutputType = {
    id: string | null
    outletId: string | null
    detailDays: string | null
    openHour: Date | null
    closeHour: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OutletScheduleMaxAggregateOutputType = {
    id: string | null
    outletId: string | null
    detailDays: string | null
    openHour: Date | null
    closeHour: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OutletScheduleCountAggregateOutputType = {
    id: number
    outletId: number
    detailDays: number
    openHour: number
    closeHour: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OutletScheduleMinAggregateInputType = {
    id?: true
    outletId?: true
    detailDays?: true
    openHour?: true
    closeHour?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OutletScheduleMaxAggregateInputType = {
    id?: true
    outletId?: true
    detailDays?: true
    openHour?: true
    closeHour?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OutletScheduleCountAggregateInputType = {
    id?: true
    outletId?: true
    detailDays?: true
    openHour?: true
    closeHour?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OutletScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutletSchedule to aggregate.
     */
    where?: OutletScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutletSchedules to fetch.
     */
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutletScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutletSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutletSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutletSchedules
    **/
    _count?: true | OutletScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutletScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutletScheduleMaxAggregateInputType
  }

  export type GetOutletScheduleAggregateType<T extends OutletScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateOutletSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutletSchedule[P]>
      : GetScalarType<T[P], AggregateOutletSchedule[P]>
  }




  export type OutletScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutletScheduleWhereInput
    orderBy?: OutletScheduleOrderByWithAggregationInput | OutletScheduleOrderByWithAggregationInput[]
    by: OutletScheduleScalarFieldEnum[] | OutletScheduleScalarFieldEnum
    having?: OutletScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutletScheduleCountAggregateInputType | true
    _min?: OutletScheduleMinAggregateInputType
    _max?: OutletScheduleMaxAggregateInputType
  }

  export type OutletScheduleGroupByOutputType = {
    id: string
    outletId: string
    detailDays: string
    openHour: Date
    closeHour: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OutletScheduleCountAggregateOutputType | null
    _min: OutletScheduleMinAggregateOutputType | null
    _max: OutletScheduleMaxAggregateOutputType | null
  }

  type GetOutletScheduleGroupByPayload<T extends OutletScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutletScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutletScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutletScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], OutletScheduleGroupByOutputType[P]>
        }
      >
    >


  export type OutletScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    detailDays?: boolean
    openHour?: boolean
    closeHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outletSchedule"]>

  export type OutletScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    detailDays?: boolean
    openHour?: boolean
    closeHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outletSchedule"]>

  export type OutletScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outletId?: boolean
    detailDays?: boolean
    openHour?: boolean
    closeHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outletSchedule"]>

  export type OutletScheduleSelectScalar = {
    id?: boolean
    outletId?: boolean
    detailDays?: boolean
    openHour?: boolean
    closeHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OutletScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "outletId" | "detailDays" | "openHour" | "closeHour" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["outletSchedule"]>
  export type OutletScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }
  export type OutletScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }
  export type OutletScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
  }

  export type $OutletSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutletSchedule"
    objects: {
      outlet: Prisma.$OutletPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      outletId: string
      detailDays: string
      openHour: Date
      closeHour: Date
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["outletSchedule"]>
    composites: {}
  }

  type OutletScheduleGetPayload<S extends boolean | null | undefined | OutletScheduleDefaultArgs> = $Result.GetResult<Prisma.$OutletSchedulePayload, S>

  type OutletScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutletScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutletScheduleCountAggregateInputType | true
    }

  export interface OutletScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutletSchedule'], meta: { name: 'OutletSchedule' } }
    /**
     * Find zero or one OutletSchedule that matches the filter.
     * @param {OutletScheduleFindUniqueArgs} args - Arguments to find a OutletSchedule
     * @example
     * // Get one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutletScheduleFindUniqueArgs>(args: SelectSubset<T, OutletScheduleFindUniqueArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OutletSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutletScheduleFindUniqueOrThrowArgs} args - Arguments to find a OutletSchedule
     * @example
     * // Get one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutletScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, OutletScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutletSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleFindFirstArgs} args - Arguments to find a OutletSchedule
     * @example
     * // Get one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutletScheduleFindFirstArgs>(args?: SelectSubset<T, OutletScheduleFindFirstArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutletSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleFindFirstOrThrowArgs} args - Arguments to find a OutletSchedule
     * @example
     * // Get one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutletScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, OutletScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutletSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutletSchedules
     * const outletSchedules = await prisma.outletSchedule.findMany()
     * 
     * // Get first 10 OutletSchedules
     * const outletSchedules = await prisma.outletSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outletScheduleWithIdOnly = await prisma.outletSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutletScheduleFindManyArgs>(args?: SelectSubset<T, OutletScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OutletSchedule.
     * @param {OutletScheduleCreateArgs} args - Arguments to create a OutletSchedule.
     * @example
     * // Create one OutletSchedule
     * const OutletSchedule = await prisma.outletSchedule.create({
     *   data: {
     *     // ... data to create a OutletSchedule
     *   }
     * })
     * 
     */
    create<T extends OutletScheduleCreateArgs>(args: SelectSubset<T, OutletScheduleCreateArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OutletSchedules.
     * @param {OutletScheduleCreateManyArgs} args - Arguments to create many OutletSchedules.
     * @example
     * // Create many OutletSchedules
     * const outletSchedule = await prisma.outletSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutletScheduleCreateManyArgs>(args?: SelectSubset<T, OutletScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutletSchedules and returns the data saved in the database.
     * @param {OutletScheduleCreateManyAndReturnArgs} args - Arguments to create many OutletSchedules.
     * @example
     * // Create many OutletSchedules
     * const outletSchedule = await prisma.outletSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutletSchedules and only return the `id`
     * const outletScheduleWithIdOnly = await prisma.outletSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutletScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, OutletScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OutletSchedule.
     * @param {OutletScheduleDeleteArgs} args - Arguments to delete one OutletSchedule.
     * @example
     * // Delete one OutletSchedule
     * const OutletSchedule = await prisma.outletSchedule.delete({
     *   where: {
     *     // ... filter to delete one OutletSchedule
     *   }
     * })
     * 
     */
    delete<T extends OutletScheduleDeleteArgs>(args: SelectSubset<T, OutletScheduleDeleteArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OutletSchedule.
     * @param {OutletScheduleUpdateArgs} args - Arguments to update one OutletSchedule.
     * @example
     * // Update one OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutletScheduleUpdateArgs>(args: SelectSubset<T, OutletScheduleUpdateArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OutletSchedules.
     * @param {OutletScheduleDeleteManyArgs} args - Arguments to filter OutletSchedules to delete.
     * @example
     * // Delete a few OutletSchedules
     * const { count } = await prisma.outletSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutletScheduleDeleteManyArgs>(args?: SelectSubset<T, OutletScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutletSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutletSchedules
     * const outletSchedule = await prisma.outletSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutletScheduleUpdateManyArgs>(args: SelectSubset<T, OutletScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutletSchedules and returns the data updated in the database.
     * @param {OutletScheduleUpdateManyAndReturnArgs} args - Arguments to update many OutletSchedules.
     * @example
     * // Update many OutletSchedules
     * const outletSchedule = await prisma.outletSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OutletSchedules and only return the `id`
     * const outletScheduleWithIdOnly = await prisma.outletSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutletScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, OutletScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OutletSchedule.
     * @param {OutletScheduleUpsertArgs} args - Arguments to update or create a OutletSchedule.
     * @example
     * // Update or create a OutletSchedule
     * const outletSchedule = await prisma.outletSchedule.upsert({
     *   create: {
     *     // ... data to create a OutletSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutletSchedule we want to update
     *   }
     * })
     */
    upsert<T extends OutletScheduleUpsertArgs>(args: SelectSubset<T, OutletScheduleUpsertArgs<ExtArgs>>): Prisma__OutletScheduleClient<$Result.GetResult<Prisma.$OutletSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OutletSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleCountArgs} args - Arguments to filter OutletSchedules to count.
     * @example
     * // Count the number of OutletSchedules
     * const count = await prisma.outletSchedule.count({
     *   where: {
     *     // ... the filter for the OutletSchedules we want to count
     *   }
     * })
    **/
    count<T extends OutletScheduleCountArgs>(
      args?: Subset<T, OutletScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutletScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutletSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutletScheduleAggregateArgs>(args: Subset<T, OutletScheduleAggregateArgs>): Prisma.PrismaPromise<GetOutletScheduleAggregateType<T>>

    /**
     * Group by OutletSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutletScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutletScheduleGroupByArgs['orderBy'] }
        : { orderBy?: OutletScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutletScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutletScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutletSchedule model
   */
  readonly fields: OutletScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutletSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutletScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutletSchedule model
   */
  interface OutletScheduleFieldRefs {
    readonly id: FieldRef<"OutletSchedule", 'String'>
    readonly outletId: FieldRef<"OutletSchedule", 'String'>
    readonly detailDays: FieldRef<"OutletSchedule", 'String'>
    readonly openHour: FieldRef<"OutletSchedule", 'DateTime'>
    readonly closeHour: FieldRef<"OutletSchedule", 'DateTime'>
    readonly createdAt: FieldRef<"OutletSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"OutletSchedule", 'DateTime'>
    readonly deletedAt: FieldRef<"OutletSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutletSchedule findUnique
   */
  export type OutletScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedule to fetch.
     */
    where: OutletScheduleWhereUniqueInput
  }

  /**
   * OutletSchedule findUniqueOrThrow
   */
  export type OutletScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedule to fetch.
     */
    where: OutletScheduleWhereUniqueInput
  }

  /**
   * OutletSchedule findFirst
   */
  export type OutletScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedule to fetch.
     */
    where?: OutletScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutletSchedules to fetch.
     */
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutletSchedules.
     */
    cursor?: OutletScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutletSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutletSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutletSchedules.
     */
    distinct?: OutletScheduleScalarFieldEnum | OutletScheduleScalarFieldEnum[]
  }

  /**
   * OutletSchedule findFirstOrThrow
   */
  export type OutletScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedule to fetch.
     */
    where?: OutletScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutletSchedules to fetch.
     */
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutletSchedules.
     */
    cursor?: OutletScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutletSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutletSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutletSchedules.
     */
    distinct?: OutletScheduleScalarFieldEnum | OutletScheduleScalarFieldEnum[]
  }

  /**
   * OutletSchedule findMany
   */
  export type OutletScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OutletSchedules to fetch.
     */
    where?: OutletScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutletSchedules to fetch.
     */
    orderBy?: OutletScheduleOrderByWithRelationInput | OutletScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutletSchedules.
     */
    cursor?: OutletScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutletSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutletSchedules.
     */
    skip?: number
    distinct?: OutletScheduleScalarFieldEnum | OutletScheduleScalarFieldEnum[]
  }

  /**
   * OutletSchedule create
   */
  export type OutletScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a OutletSchedule.
     */
    data: XOR<OutletScheduleCreateInput, OutletScheduleUncheckedCreateInput>
  }

  /**
   * OutletSchedule createMany
   */
  export type OutletScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutletSchedules.
     */
    data: OutletScheduleCreateManyInput | OutletScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutletSchedule createManyAndReturn
   */
  export type OutletScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many OutletSchedules.
     */
    data: OutletScheduleCreateManyInput | OutletScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutletSchedule update
   */
  export type OutletScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a OutletSchedule.
     */
    data: XOR<OutletScheduleUpdateInput, OutletScheduleUncheckedUpdateInput>
    /**
     * Choose, which OutletSchedule to update.
     */
    where: OutletScheduleWhereUniqueInput
  }

  /**
   * OutletSchedule updateMany
   */
  export type OutletScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutletSchedules.
     */
    data: XOR<OutletScheduleUpdateManyMutationInput, OutletScheduleUncheckedUpdateManyInput>
    /**
     * Filter which OutletSchedules to update
     */
    where?: OutletScheduleWhereInput
    /**
     * Limit how many OutletSchedules to update.
     */
    limit?: number
  }

  /**
   * OutletSchedule updateManyAndReturn
   */
  export type OutletScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * The data used to update OutletSchedules.
     */
    data: XOR<OutletScheduleUpdateManyMutationInput, OutletScheduleUncheckedUpdateManyInput>
    /**
     * Filter which OutletSchedules to update
     */
    where?: OutletScheduleWhereInput
    /**
     * Limit how many OutletSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutletSchedule upsert
   */
  export type OutletScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the OutletSchedule to update in case it exists.
     */
    where: OutletScheduleWhereUniqueInput
    /**
     * In case the OutletSchedule found by the `where` argument doesn't exist, create a new OutletSchedule with this data.
     */
    create: XOR<OutletScheduleCreateInput, OutletScheduleUncheckedCreateInput>
    /**
     * In case the OutletSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutletScheduleUpdateInput, OutletScheduleUncheckedUpdateInput>
  }

  /**
   * OutletSchedule delete
   */
  export type OutletScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
    /**
     * Filter which OutletSchedule to delete.
     */
    where: OutletScheduleWhereUniqueInput
  }

  /**
   * OutletSchedule deleteMany
   */
  export type OutletScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutletSchedules to delete
     */
    where?: OutletScheduleWhereInput
    /**
     * Limit how many OutletSchedules to delete.
     */
    limit?: number
  }

  /**
   * OutletSchedule without action
   */
  export type OutletScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletSchedule
     */
    select?: OutletScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutletSchedule
     */
    omit?: OutletScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: ServiceCategoryOrderByWithAggregationInput | ServiceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Service?: boolean | ServiceCategory$ServiceArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ServiceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["serviceCategory"]>
  export type ServiceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Service?: boolean | ServiceCategory$ServiceArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCategory"
    objects: {
      Service: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCategoryFindUniqueArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCategoryFindFirstArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCategoryFindManyArgs>(args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends ServiceCategoryCreateArgs>(args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCategories.
     * @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCategoryCreateManyArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCategories and returns the data saved in the database.
     * @param {ServiceCategoryCreateManyAndReturnArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends ServiceCategoryDeleteArgs>(args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCategoryUpdateArgs>(args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCategoryDeleteManyArgs>(args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCategoryUpdateManyArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories and returns the data updated in the database.
     * @param {ServiceCategoryUpdateManyAndReturnArgs} args - Arguments to update many ServiceCategories.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCategoryUpsertArgs>(args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCategory model
   */
  readonly fields: ServiceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Service<T extends ServiceCategory$ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$ServiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCategory model
   */
  interface ServiceCategoryFieldRefs {
    readonly id: FieldRef<"ServiceCategory", 'String'>
    readonly name: FieldRef<"ServiceCategory", 'String'>
    readonly createdAt: FieldRef<"ServiceCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceCategory", 'DateTime'>
    readonly deletedAt: FieldRef<"ServiceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCategory findUnique
   */
  export type ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findFirst
   */
  export type ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }

  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory createManyAndReturn
   */
  export type ServiceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory updateManyAndReturn
   */
  export type ServiceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }

  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to delete.
     */
    limit?: number
  }

  /**
   * ServiceCategory.Service
   */
  export type ServiceCategory$ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    basePrice: number | null
    minQty: number | null
    etaHours: number | null
  }

  export type ServiceSumAggregateOutputType = {
    basePrice: number | null
    minQty: number | null
    etaHours: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    serviceCategoryId: string | null
    name: string | null
    unit: string | null
    basePrice: number | null
    minQty: number | null
    etaHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    serviceCategoryId: string | null
    name: string | null
    unit: string | null
    basePrice: number | null
    minQty: number | null
    etaHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    serviceCategoryId: number
    name: number
    unit: number
    basePrice: number
    minQty: number
    etaHours: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    basePrice?: true
    minQty?: true
    etaHours?: true
  }

  export type ServiceSumAggregateInputType = {
    basePrice?: true
    minQty?: true
    etaHours?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    serviceCategoryId?: true
    name?: true
    unit?: true
    basePrice?: true
    minQty?: true
    etaHours?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    serviceCategoryId?: true
    name?: true
    unit?: true
    basePrice?: true
    minQty?: true
    etaHours?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    serviceCategoryId?: true
    name?: true
    unit?: true
    basePrice?: true
    minQty?: true
    etaHours?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    serviceCategoryId: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    etaHours: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceCategoryId?: boolean
    name?: boolean
    unit?: boolean
    basePrice?: boolean
    minQty?: boolean
    etaHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    serviceCatId?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    OrderItem?: boolean | Service$OrderItemArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceCategoryId?: boolean
    name?: boolean
    unit?: boolean
    basePrice?: boolean
    minQty?: boolean
    etaHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    serviceCatId?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceCategoryId?: boolean
    name?: boolean
    unit?: boolean
    basePrice?: boolean
    minQty?: boolean
    etaHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    serviceCatId?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    serviceCategoryId?: boolean
    name?: boolean
    unit?: boolean
    basePrice?: boolean
    minQty?: boolean
    etaHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceCategoryId" | "name" | "unit" | "basePrice" | "minQty" | "etaHours" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceCatId?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    OrderItem?: boolean | Service$OrderItemArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceCatId?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceCatId?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      serviceCatId: Prisma.$ServiceCategoryPayload<ExtArgs>
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceCategoryId: string
      name: string
      unit: string
      basePrice: number
      minQty: number
      etaHours: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceCatId<T extends ServiceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryDefaultArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    OrderItem<T extends Service$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, Service$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly serviceCategoryId: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly unit: FieldRef<"Service", 'String'>
    readonly basePrice: FieldRef<"Service", 'Int'>
    readonly minQty: FieldRef<"Service", 'Int'>
    readonly etaHours: FieldRef<"Service", 'Int'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
    readonly deletedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.OrderItem
   */
  export type Service$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model OrderHeader
   */

  export type AggregateOrderHeader = {
    _count: OrderHeaderCountAggregateOutputType | null
    _avg: OrderHeaderAvgAggregateOutputType | null
    _sum: OrderHeaderSumAggregateOutputType | null
    _min: OrderHeaderMinAggregateOutputType | null
    _max: OrderHeaderMaxAggregateOutputType | null
  }

  export type OrderHeaderAvgAggregateOutputType = {
    estHours: number | null
  }

  export type OrderHeaderSumAggregateOutputType = {
    estHours: number | null
  }

  export type OrderHeaderMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    handledById: string | null
    outletId: string | null
    status: $Enums.OrderStatus | null
    notes: string | null
    pickupAt: Date | null
    deliverAt: Date | null
    estHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderHeaderMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    handledById: string | null
    outletId: string | null
    status: $Enums.OrderStatus | null
    notes: string | null
    pickupAt: Date | null
    deliverAt: Date | null
    estHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderHeaderCountAggregateOutputType = {
    id: number
    customerId: number
    handledById: number
    outletId: number
    status: number
    notes: number
    pickupAt: number
    deliverAt: number
    estHours: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OrderHeaderAvgAggregateInputType = {
    estHours?: true
  }

  export type OrderHeaderSumAggregateInputType = {
    estHours?: true
  }

  export type OrderHeaderMinAggregateInputType = {
    id?: true
    customerId?: true
    handledById?: true
    outletId?: true
    status?: true
    notes?: true
    pickupAt?: true
    deliverAt?: true
    estHours?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderHeaderMaxAggregateInputType = {
    id?: true
    customerId?: true
    handledById?: true
    outletId?: true
    status?: true
    notes?: true
    pickupAt?: true
    deliverAt?: true
    estHours?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderHeaderCountAggregateInputType = {
    id?: true
    customerId?: true
    handledById?: true
    outletId?: true
    status?: true
    notes?: true
    pickupAt?: true
    deliverAt?: true
    estHours?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OrderHeaderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderHeader to aggregate.
     */
    where?: OrderHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHeaders to fetch.
     */
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderHeaders
    **/
    _count?: true | OrderHeaderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderHeaderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderHeaderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderHeaderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderHeaderMaxAggregateInputType
  }

  export type GetOrderHeaderAggregateType<T extends OrderHeaderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderHeader]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderHeader[P]>
      : GetScalarType<T[P], AggregateOrderHeader[P]>
  }




  export type OrderHeaderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHeaderWhereInput
    orderBy?: OrderHeaderOrderByWithAggregationInput | OrderHeaderOrderByWithAggregationInput[]
    by: OrderHeaderScalarFieldEnum[] | OrderHeaderScalarFieldEnum
    having?: OrderHeaderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderHeaderCountAggregateInputType | true
    _avg?: OrderHeaderAvgAggregateInputType
    _sum?: OrderHeaderSumAggregateInputType
    _min?: OrderHeaderMinAggregateInputType
    _max?: OrderHeaderMaxAggregateInputType
  }

  export type OrderHeaderGroupByOutputType = {
    id: string
    customerId: string
    handledById: string | null
    outletId: string
    status: $Enums.OrderStatus
    notes: string
    pickupAt: Date
    deliverAt: Date
    estHours: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OrderHeaderCountAggregateOutputType | null
    _avg: OrderHeaderAvgAggregateOutputType | null
    _sum: OrderHeaderSumAggregateOutputType | null
    _min: OrderHeaderMinAggregateOutputType | null
    _max: OrderHeaderMaxAggregateOutputType | null
  }

  type GetOrderHeaderGroupByPayload<T extends OrderHeaderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderHeaderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderHeaderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderHeaderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderHeaderGroupByOutputType[P]>
        }
      >
    >


  export type OrderHeaderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    handledById?: boolean
    outletId?: boolean
    status?: boolean
    notes?: boolean
    pickupAt?: boolean
    deliverAt?: boolean
    estHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    employees?: boolean | OrderHeader$employeesArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    OrderItem?: boolean | OrderHeader$OrderItemArgs<ExtArgs>
    Payment?: boolean | OrderHeader$PaymentArgs<ExtArgs>
    workerTasks?: boolean | OrderHeader$workerTasksArgs<ExtArgs>
    PickUpTask?: boolean | OrderHeader$PickUpTaskArgs<ExtArgs>
    DeliveryTask?: boolean | OrderHeader$DeliveryTaskArgs<ExtArgs>
    _count?: boolean | OrderHeaderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderHeader"]>

  export type OrderHeaderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    handledById?: boolean
    outletId?: boolean
    status?: boolean
    notes?: boolean
    pickupAt?: boolean
    deliverAt?: boolean
    estHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    employees?: boolean | OrderHeader$employeesArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderHeader"]>

  export type OrderHeaderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    handledById?: boolean
    outletId?: boolean
    status?: boolean
    notes?: boolean
    pickupAt?: boolean
    deliverAt?: boolean
    estHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    employees?: boolean | OrderHeader$employeesArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderHeader"]>

  export type OrderHeaderSelectScalar = {
    id?: boolean
    customerId?: boolean
    handledById?: boolean
    outletId?: boolean
    status?: boolean
    notes?: boolean
    pickupAt?: boolean
    deliverAt?: boolean
    estHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OrderHeaderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "handledById" | "outletId" | "status" | "notes" | "pickupAt" | "deliverAt" | "estHours" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["orderHeader"]>
  export type OrderHeaderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    employees?: boolean | OrderHeader$employeesArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
    OrderItem?: boolean | OrderHeader$OrderItemArgs<ExtArgs>
    Payment?: boolean | OrderHeader$PaymentArgs<ExtArgs>
    workerTasks?: boolean | OrderHeader$workerTasksArgs<ExtArgs>
    PickUpTask?: boolean | OrderHeader$PickUpTaskArgs<ExtArgs>
    DeliveryTask?: boolean | OrderHeader$DeliveryTaskArgs<ExtArgs>
    _count?: boolean | OrderHeaderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderHeaderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    employees?: boolean | OrderHeader$employeesArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
  }
  export type OrderHeaderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    employees?: boolean | OrderHeader$employeesArgs<ExtArgs>
    outlets?: boolean | OutletDefaultArgs<ExtArgs>
  }

  export type $OrderHeaderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderHeader"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>
      employees: Prisma.$EmployeePayload<ExtArgs> | null
      outlets: Prisma.$OutletPayload<ExtArgs>
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
      Payment: Prisma.$PaymentPayload<ExtArgs>[]
      workerTasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
      PickUpTask: Prisma.$PickUpTaskPayload<ExtArgs>[]
      DeliveryTask: Prisma.$DeliveryTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      handledById: string | null
      outletId: string
      status: $Enums.OrderStatus
      notes: string
      pickupAt: Date
      deliverAt: Date
      estHours: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["orderHeader"]>
    composites: {}
  }

  type OrderHeaderGetPayload<S extends boolean | null | undefined | OrderHeaderDefaultArgs> = $Result.GetResult<Prisma.$OrderHeaderPayload, S>

  type OrderHeaderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderHeaderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderHeaderCountAggregateInputType | true
    }

  export interface OrderHeaderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderHeader'], meta: { name: 'OrderHeader' } }
    /**
     * Find zero or one OrderHeader that matches the filter.
     * @param {OrderHeaderFindUniqueArgs} args - Arguments to find a OrderHeader
     * @example
     * // Get one OrderHeader
     * const orderHeader = await prisma.orderHeader.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderHeaderFindUniqueArgs>(args: SelectSubset<T, OrderHeaderFindUniqueArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderHeader that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderHeaderFindUniqueOrThrowArgs} args - Arguments to find a OrderHeader
     * @example
     * // Get one OrderHeader
     * const orderHeader = await prisma.orderHeader.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderHeaderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderHeaderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderHeader that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderFindFirstArgs} args - Arguments to find a OrderHeader
     * @example
     * // Get one OrderHeader
     * const orderHeader = await prisma.orderHeader.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderHeaderFindFirstArgs>(args?: SelectSubset<T, OrderHeaderFindFirstArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderHeader that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderFindFirstOrThrowArgs} args - Arguments to find a OrderHeader
     * @example
     * // Get one OrderHeader
     * const orderHeader = await prisma.orderHeader.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderHeaderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderHeaderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderHeaders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderHeaders
     * const orderHeaders = await prisma.orderHeader.findMany()
     * 
     * // Get first 10 OrderHeaders
     * const orderHeaders = await prisma.orderHeader.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderHeaderWithIdOnly = await prisma.orderHeader.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderHeaderFindManyArgs>(args?: SelectSubset<T, OrderHeaderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderHeader.
     * @param {OrderHeaderCreateArgs} args - Arguments to create a OrderHeader.
     * @example
     * // Create one OrderHeader
     * const OrderHeader = await prisma.orderHeader.create({
     *   data: {
     *     // ... data to create a OrderHeader
     *   }
     * })
     * 
     */
    create<T extends OrderHeaderCreateArgs>(args: SelectSubset<T, OrderHeaderCreateArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderHeaders.
     * @param {OrderHeaderCreateManyArgs} args - Arguments to create many OrderHeaders.
     * @example
     * // Create many OrderHeaders
     * const orderHeader = await prisma.orderHeader.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderHeaderCreateManyArgs>(args?: SelectSubset<T, OrderHeaderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderHeaders and returns the data saved in the database.
     * @param {OrderHeaderCreateManyAndReturnArgs} args - Arguments to create many OrderHeaders.
     * @example
     * // Create many OrderHeaders
     * const orderHeader = await prisma.orderHeader.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderHeaders and only return the `id`
     * const orderHeaderWithIdOnly = await prisma.orderHeader.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderHeaderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderHeaderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderHeader.
     * @param {OrderHeaderDeleteArgs} args - Arguments to delete one OrderHeader.
     * @example
     * // Delete one OrderHeader
     * const OrderHeader = await prisma.orderHeader.delete({
     *   where: {
     *     // ... filter to delete one OrderHeader
     *   }
     * })
     * 
     */
    delete<T extends OrderHeaderDeleteArgs>(args: SelectSubset<T, OrderHeaderDeleteArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderHeader.
     * @param {OrderHeaderUpdateArgs} args - Arguments to update one OrderHeader.
     * @example
     * // Update one OrderHeader
     * const orderHeader = await prisma.orderHeader.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderHeaderUpdateArgs>(args: SelectSubset<T, OrderHeaderUpdateArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderHeaders.
     * @param {OrderHeaderDeleteManyArgs} args - Arguments to filter OrderHeaders to delete.
     * @example
     * // Delete a few OrderHeaders
     * const { count } = await prisma.orderHeader.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderHeaderDeleteManyArgs>(args?: SelectSubset<T, OrderHeaderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderHeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderHeaders
     * const orderHeader = await prisma.orderHeader.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderHeaderUpdateManyArgs>(args: SelectSubset<T, OrderHeaderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderHeaders and returns the data updated in the database.
     * @param {OrderHeaderUpdateManyAndReturnArgs} args - Arguments to update many OrderHeaders.
     * @example
     * // Update many OrderHeaders
     * const orderHeader = await prisma.orderHeader.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderHeaders and only return the `id`
     * const orderHeaderWithIdOnly = await prisma.orderHeader.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderHeaderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderHeaderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderHeader.
     * @param {OrderHeaderUpsertArgs} args - Arguments to update or create a OrderHeader.
     * @example
     * // Update or create a OrderHeader
     * const orderHeader = await prisma.orderHeader.upsert({
     *   create: {
     *     // ... data to create a OrderHeader
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderHeader we want to update
     *   }
     * })
     */
    upsert<T extends OrderHeaderUpsertArgs>(args: SelectSubset<T, OrderHeaderUpsertArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderHeaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderCountArgs} args - Arguments to filter OrderHeaders to count.
     * @example
     * // Count the number of OrderHeaders
     * const count = await prisma.orderHeader.count({
     *   where: {
     *     // ... the filter for the OrderHeaders we want to count
     *   }
     * })
    **/
    count<T extends OrderHeaderCountArgs>(
      args?: Subset<T, OrderHeaderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderHeaderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderHeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderHeaderAggregateArgs>(args: Subset<T, OrderHeaderAggregateArgs>): Prisma.PrismaPromise<GetOrderHeaderAggregateType<T>>

    /**
     * Group by OrderHeader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHeaderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderHeaderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderHeaderGroupByArgs['orderBy'] }
        : { orderBy?: OrderHeaderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderHeaderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderHeaderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderHeader model
   */
  readonly fields: OrderHeaderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderHeader.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderHeaderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employees<T extends OrderHeader$employeesArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeader$employeesArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    outlets<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    OrderItem<T extends OrderHeader$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeader$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Payment<T extends OrderHeader$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeader$PaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerTasks<T extends OrderHeader$workerTasksArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeader$workerTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PickUpTask<T extends OrderHeader$PickUpTaskArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeader$PickUpTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickUpTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeliveryTask<T extends OrderHeader$DeliveryTaskArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeader$DeliveryTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderHeader model
   */
  interface OrderHeaderFieldRefs {
    readonly id: FieldRef<"OrderHeader", 'String'>
    readonly customerId: FieldRef<"OrderHeader", 'String'>
    readonly handledById: FieldRef<"OrderHeader", 'String'>
    readonly outletId: FieldRef<"OrderHeader", 'String'>
    readonly status: FieldRef<"OrderHeader", 'OrderStatus'>
    readonly notes: FieldRef<"OrderHeader", 'String'>
    readonly pickupAt: FieldRef<"OrderHeader", 'DateTime'>
    readonly deliverAt: FieldRef<"OrderHeader", 'DateTime'>
    readonly estHours: FieldRef<"OrderHeader", 'Int'>
    readonly createdAt: FieldRef<"OrderHeader", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderHeader", 'DateTime'>
    readonly deletedAt: FieldRef<"OrderHeader", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderHeader findUnique
   */
  export type OrderHeaderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeader to fetch.
     */
    where: OrderHeaderWhereUniqueInput
  }

  /**
   * OrderHeader findUniqueOrThrow
   */
  export type OrderHeaderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeader to fetch.
     */
    where: OrderHeaderWhereUniqueInput
  }

  /**
   * OrderHeader findFirst
   */
  export type OrderHeaderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeader to fetch.
     */
    where?: OrderHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHeaders to fetch.
     */
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderHeaders.
     */
    cursor?: OrderHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderHeaders.
     */
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * OrderHeader findFirstOrThrow
   */
  export type OrderHeaderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeader to fetch.
     */
    where?: OrderHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHeaders to fetch.
     */
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderHeaders.
     */
    cursor?: OrderHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHeaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderHeaders.
     */
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * OrderHeader findMany
   */
  export type OrderHeaderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter, which OrderHeaders to fetch.
     */
    where?: OrderHeaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHeaders to fetch.
     */
    orderBy?: OrderHeaderOrderByWithRelationInput | OrderHeaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderHeaders.
     */
    cursor?: OrderHeaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHeaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHeaders.
     */
    skip?: number
    distinct?: OrderHeaderScalarFieldEnum | OrderHeaderScalarFieldEnum[]
  }

  /**
   * OrderHeader create
   */
  export type OrderHeaderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderHeader.
     */
    data: XOR<OrderHeaderCreateInput, OrderHeaderUncheckedCreateInput>
  }

  /**
   * OrderHeader createMany
   */
  export type OrderHeaderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderHeaders.
     */
    data: OrderHeaderCreateManyInput | OrderHeaderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderHeader createManyAndReturn
   */
  export type OrderHeaderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * The data used to create many OrderHeaders.
     */
    data: OrderHeaderCreateManyInput | OrderHeaderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderHeader update
   */
  export type OrderHeaderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderHeader.
     */
    data: XOR<OrderHeaderUpdateInput, OrderHeaderUncheckedUpdateInput>
    /**
     * Choose, which OrderHeader to update.
     */
    where: OrderHeaderWhereUniqueInput
  }

  /**
   * OrderHeader updateMany
   */
  export type OrderHeaderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderHeaders.
     */
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyInput>
    /**
     * Filter which OrderHeaders to update
     */
    where?: OrderHeaderWhereInput
    /**
     * Limit how many OrderHeaders to update.
     */
    limit?: number
  }

  /**
   * OrderHeader updateManyAndReturn
   */
  export type OrderHeaderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * The data used to update OrderHeaders.
     */
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyInput>
    /**
     * Filter which OrderHeaders to update
     */
    where?: OrderHeaderWhereInput
    /**
     * Limit how many OrderHeaders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderHeader upsert
   */
  export type OrderHeaderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderHeader to update in case it exists.
     */
    where: OrderHeaderWhereUniqueInput
    /**
     * In case the OrderHeader found by the `where` argument doesn't exist, create a new OrderHeader with this data.
     */
    create: XOR<OrderHeaderCreateInput, OrderHeaderUncheckedCreateInput>
    /**
     * In case the OrderHeader was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderHeaderUpdateInput, OrderHeaderUncheckedUpdateInput>
  }

  /**
   * OrderHeader delete
   */
  export type OrderHeaderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
    /**
     * Filter which OrderHeader to delete.
     */
    where: OrderHeaderWhereUniqueInput
  }

  /**
   * OrderHeader deleteMany
   */
  export type OrderHeaderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderHeaders to delete
     */
    where?: OrderHeaderWhereInput
    /**
     * Limit how many OrderHeaders to delete.
     */
    limit?: number
  }

  /**
   * OrderHeader.employees
   */
  export type OrderHeader$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * OrderHeader.OrderItem
   */
  export type OrderHeader$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderHeader.Payment
   */
  export type OrderHeader$PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * OrderHeader.workerTasks
   */
  export type OrderHeader$workerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * OrderHeader.PickUpTask
   */
  export type OrderHeader$PickUpTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickUpTask
     */
    select?: PickUpTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickUpTask
     */
    omit?: PickUpTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickUpTaskInclude<ExtArgs> | null
    where?: PickUpTaskWhereInput
    orderBy?: PickUpTaskOrderByWithRelationInput | PickUpTaskOrderByWithRelationInput[]
    cursor?: PickUpTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PickUpTaskScalarFieldEnum | PickUpTaskScalarFieldEnum[]
  }

  /**
   * OrderHeader.DeliveryTask
   */
  export type OrderHeader$DeliveryTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTask
     */
    select?: DeliveryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTask
     */
    omit?: DeliveryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTaskInclude<ExtArgs> | null
    where?: DeliveryTaskWhereInput
    orderBy?: DeliveryTaskOrderByWithRelationInput | DeliveryTaskOrderByWithRelationInput[]
    cursor?: DeliveryTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryTaskScalarFieldEnum | DeliveryTaskScalarFieldEnum[]
  }

  /**
   * OrderHeader without action
   */
  export type OrderHeaderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHeader
     */
    select?: OrderHeaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHeader
     */
    omit?: OrderHeaderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHeaderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    qty: number | null
    unitPrice: number | null
    subTotal: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    qty: number | null
    unitPrice: number | null
    subTotal: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderHeaderId: string | null
    serviceId: string | null
    qty: number | null
    unitPrice: number | null
    subTotal: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderHeaderId: string | null
    serviceId: string | null
    qty: number | null
    unitPrice: number | null
    subTotal: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderHeaderId: number
    serviceId: number
    qty: number
    unitPrice: number
    subTotal: number
    note: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    subTotal?: true
  }

  export type OrderItemSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    subTotal?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderHeaderId?: true
    serviceId?: true
    qty?: true
    unitPrice?: true
    subTotal?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderHeaderId?: true
    serviceId?: true
    qty?: true
    unitPrice?: true
    subTotal?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderHeaderId?: true
    serviceId?: true
    qty?: true
    unitPrice?: true
    subTotal?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderHeaderId: string
    serviceId: string
    qty: number
    unitPrice: number
    subTotal: number
    note: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderHeaderId?: boolean
    serviceId?: boolean
    qty?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    workerTasks?: boolean | OrderItem$workerTasksArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderHeaderId?: boolean
    serviceId?: boolean
    qty?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderHeaderId?: boolean
    serviceId?: boolean
    qty?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderHeaderId?: boolean
    serviceId?: boolean
    qty?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderHeaderId" | "serviceId" | "qty" | "unitPrice" | "subTotal" | "note" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    workerTasks?: boolean | OrderItem$workerTasksArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      orderheader: Prisma.$OrderHeaderPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      workerTasks: Prisma.$EmployeeTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderHeaderId: string
      serviceId: string
      qty: number
      unitPrice: number
      subTotal: number
      note: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderheader<T extends OrderHeaderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeaderDefaultArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workerTasks<T extends OrderItem$workerTasksArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$workerTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderHeaderId: FieldRef<"OrderItem", 'String'>
    readonly serviceId: FieldRef<"OrderItem", 'String'>
    readonly qty: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Int'>
    readonly subTotal: FieldRef<"OrderItem", 'Int'>
    readonly note: FieldRef<"OrderItem", 'String'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly deletedAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.workerTasks
   */
  export type OrderItem$workerTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeTask
     */
    select?: EmployeeTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeTask
     */
    omit?: EmployeeTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeTaskInclude<ExtArgs> | null
    where?: EmployeeTaskWhereInput
    orderBy?: EmployeeTaskOrderByWithRelationInput | EmployeeTaskOrderByWithRelationInput[]
    cursor?: EmployeeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeTaskScalarFieldEnum | EmployeeTaskScalarFieldEnum[]
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    orderHeaderId: string | null
    method: $Enums.PaymentMethod | null
    amount: number | null
    status: $Enums.PaymentStatus | null
    providerRef: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    orderHeaderId: string | null
    method: $Enums.PaymentMethod | null
    amount: number | null
    status: $Enums.PaymentStatus | null
    providerRef: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderHeaderId: number
    method: number
    amount: number
    status: number
    providerRef: number
    paidAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderHeaderId?: true
    method?: true
    amount?: true
    status?: true
    providerRef?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderHeaderId?: true
    method?: true
    amount?: true
    status?: true
    providerRef?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderHeaderId?: true
    method?: true
    amount?: true
    status?: true
    providerRef?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    orderHeaderId: string
    method: $Enums.PaymentMethod
    amount: number
    status: $Enums.PaymentStatus
    providerRef: string
    paidAt: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderHeaderId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    providerRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderHeaderId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    providerRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderHeaderId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    providerRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orderHeaderId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    providerRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderHeaderId" | "method" | "amount" | "status" | "providerRef" | "paidAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderheader?: boolean | OrderHeaderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      orderheader: Prisma.$OrderHeaderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderHeaderId: string
      method: $Enums.PaymentMethod
      amount: number
      status: $Enums.PaymentStatus
      providerRef: string
      paidAt: Date
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderheader<T extends OrderHeaderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderHeaderDefaultArgs<ExtArgs>>): Prisma__OrderHeaderClient<$Result.GetResult<Prisma.$OrderHeaderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly orderHeaderId: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly providerRef: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly deletedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    role: 'role',
    name: 'name',
    email: 'email',
    password: 'password',
    phoneNumber: 'phoneNumber',
    photoUrl: 'photoUrl',
    isVerified: 'isVerified',
    selectProvider: 'selectProvider',
    resetPasswordToken: 'resetPasswordToken',
    resetPasswordTokenExpiresAt: 'resetPasswordTokenExpiresAt',
    verifyToken: 'verifyToken',
    verifyTokenExpiresAt: 'verifyTokenExpiresAt',
    pendingEmail: 'pendingEmail',
    pendingEmailToken: 'pendingEmailToken',
    pendingEmailTokenExpiresAt: 'pendingEmailTokenExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerAddressScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    label: 'label',
    address: 'address',
    city: 'city',
    postalCode: 'postalCode',
    latitude: 'latitude',
    longitude: 'longitude',
    notes: 'notes',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CustomerAddressScalarFieldEnum = (typeof CustomerAddressScalarFieldEnum)[keyof typeof CustomerAddressScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    outletId: 'outletId',
    shiftId: 'shiftId',
    role: 'role',
    name: 'name',
    email: 'email',
    password: 'password',
    phoneNumber: 'phoneNumber',
    address: 'address',
    photoUrl: 'photoUrl',
    isActive: 'isActive',
    resetPasswordToken: 'resetPasswordToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const WorkStationScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    station: 'station',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WorkStationScalarFieldEnum = (typeof WorkStationScalarFieldEnum)[keyof typeof WorkStationScalarFieldEnum]


  export const EmployeeTaskScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    orderHeaderId: 'orderHeaderId',
    orderItemId: 'orderItemId',
    outletId: 'outletId',
    shiftId: 'shiftId',
    workStationId: 'workStationId',
    status: 'status',
    itemQty: 'itemQty',
    itemUnit: 'itemUnit',
    bypassReqNote: 'bypassReqNote',
    bypassReq: 'bypassReq',
    isReqAprooved: 'isReqAprooved',
    itemPassedNote: 'itemPassedNote',
    assignedById: 'assignedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EmployeeTaskScalarFieldEnum = (typeof EmployeeTaskScalarFieldEnum)[keyof typeof EmployeeTaskScalarFieldEnum]


  export const PickUpTaskScalarFieldEnum: {
    id: 'id',
    driverId: 'driverId',
    outletId: 'outletId',
    customerAddressId: 'customerAddressId',
    assignedByAdminId: 'assignedByAdminId',
    orderHeaderId: 'orderHeaderId',
    status: 'status',
    distance: 'distance',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PickUpTaskScalarFieldEnum = (typeof PickUpTaskScalarFieldEnum)[keyof typeof PickUpTaskScalarFieldEnum]


  export const DeliveryTaskScalarFieldEnum: {
    id: 'id',
    driverId: 'driverId',
    outletId: 'outletId',
    customerAddressId: 'customerAddressId',
    assignedByAdminId: 'assignedByAdminId',
    orderHeaderId: 'orderHeaderId',
    status: 'status',
    distance: 'distance',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DeliveryTaskScalarFieldEnum = (typeof DeliveryTaskScalarFieldEnum)[keyof typeof DeliveryTaskScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    shiftId: 'shiftId',
    outletId: 'outletId',
    date: 'date',
    status: 'status',
    clockInAt: 'clockInAt',
    clockOutAt: 'clockOutAt',
    workMinutes: 'workMinutes',
    lateMinutes: 'lateMinutes',
    earlyLeaveMin: 'earlyLeaveMin',
    notes: 'notes',
    approvedById: 'approvedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const OutletScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phoneNumber: 'phoneNumber',
    city: 'city',
    postalCode: 'postalCode',
    latitude: 'latitude',
    longitude: 'longitude',
    coverageArea: 'coverageArea',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OutletScalarFieldEnum = (typeof OutletScalarFieldEnum)[keyof typeof OutletScalarFieldEnum]


  export const OutletScheduleScalarFieldEnum: {
    id: 'id',
    outletId: 'outletId',
    detailDays: 'detailDays',
    openHour: 'openHour',
    closeHour: 'closeHour',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OutletScheduleScalarFieldEnum = (typeof OutletScheduleScalarFieldEnum)[keyof typeof OutletScheduleScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    serviceCategoryId: 'serviceCategoryId',
    name: 'name',
    unit: 'unit',
    basePrice: 'basePrice',
    minQty: 'minQty',
    etaHours: 'etaHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const OrderHeaderScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    handledById: 'handledById',
    outletId: 'outletId',
    status: 'status',
    notes: 'notes',
    pickupAt: 'pickupAt',
    deliverAt: 'deliverAt',
    estHours: 'estHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OrderHeaderScalarFieldEnum = (typeof OrderHeaderScalarFieldEnum)[keyof typeof OrderHeaderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderHeaderId: 'orderHeaderId',
    serviceId: 'serviceId',
    qty: 'qty',
    unitPrice: 'unitPrice',
    subTotal: 'subTotal',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderHeaderId: 'orderHeaderId',
    method: 'method',
    amount: 'amount',
    status: 'status',
    providerRef: 'providerRef',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'OAuthProvider'
   */
  export type EnumOAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OAuthProvider'>
    


  /**
   * Reference to a field of type 'OAuthProvider[]'
   */
  export type ListEnumOAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OAuthProvider[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Label'
   */
  export type EnumLabelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Label'>
    


  /**
   * Reference to a field of type 'Label[]'
   */
  export type ListEnumLabelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Label[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Station'
   */
  export type EnumStationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Station'>
    


  /**
   * Reference to a field of type 'Station[]'
   */
  export type ListEnumStationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Station[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PickupStatus'
   */
  export type EnumPickupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PickupStatus'>
    


  /**
   * Reference to a field of type 'PickupStatus[]'
   */
  export type ListEnumPickupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PickupStatus[]'>
    


  /**
   * Reference to a field of type 'DeilveryStatus'
   */
  export type EnumDeilveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeilveryStatus'>
    


  /**
   * Reference to a field of type 'DeilveryStatus[]'
   */
  export type ListEnumDeilveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeilveryStatus[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    role?: EnumRoleFilter<"Customer"> | $Enums.Role
    name?: StringNullableFilter<"Customer"> | string | null
    email?: StringFilter<"Customer"> | string
    password?: StringNullableFilter<"Customer"> | string | null
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    photoUrl?: StringNullableFilter<"Customer"> | string | null
    isVerified?: BoolFilter<"Customer"> | boolean
    selectProvider?: EnumOAuthProviderNullableFilter<"Customer"> | $Enums.OAuthProvider | null
    resetPasswordToken?: StringNullableFilter<"Customer"> | string | null
    resetPasswordTokenExpiresAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    verifyToken?: StringNullableFilter<"Customer"> | string | null
    verifyTokenExpiresAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    pendingEmail?: StringNullableFilter<"Customer"> | string | null
    pendingEmailToken?: StringNullableFilter<"Customer"> | string | null
    pendingEmailTokenExpiresAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    customerAddress?: CustomerAddressListRelationFilter
    orderHeader?: OrderHeaderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    selectProvider?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordTokenExpiresAt?: SortOrderInput | SortOrder
    verifyToken?: SortOrderInput | SortOrder
    verifyTokenExpiresAt?: SortOrderInput | SortOrder
    pendingEmail?: SortOrderInput | SortOrder
    pendingEmailToken?: SortOrderInput | SortOrder
    pendingEmailTokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    customerAddress?: CustomerAddressOrderByRelationAggregateInput
    orderHeader?: OrderHeaderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    role?: EnumRoleFilter<"Customer"> | $Enums.Role
    name?: StringNullableFilter<"Customer"> | string | null
    password?: StringNullableFilter<"Customer"> | string | null
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    photoUrl?: StringNullableFilter<"Customer"> | string | null
    isVerified?: BoolFilter<"Customer"> | boolean
    selectProvider?: EnumOAuthProviderNullableFilter<"Customer"> | $Enums.OAuthProvider | null
    resetPasswordToken?: StringNullableFilter<"Customer"> | string | null
    resetPasswordTokenExpiresAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    verifyToken?: StringNullableFilter<"Customer"> | string | null
    verifyTokenExpiresAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    pendingEmail?: StringNullableFilter<"Customer"> | string | null
    pendingEmailToken?: StringNullableFilter<"Customer"> | string | null
    pendingEmailTokenExpiresAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    customerAddress?: CustomerAddressListRelationFilter
    orderHeader?: OrderHeaderListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    selectProvider?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordTokenExpiresAt?: SortOrderInput | SortOrder
    verifyToken?: SortOrderInput | SortOrder
    verifyTokenExpiresAt?: SortOrderInput | SortOrder
    pendingEmail?: SortOrderInput | SortOrder
    pendingEmailToken?: SortOrderInput | SortOrder
    pendingEmailTokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    role?: EnumRoleWithAggregatesFilter<"Customer"> | $Enums.Role
    name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringWithAggregatesFilter<"Customer"> | string
    password?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Customer"> | boolean
    selectProvider?: EnumOAuthProviderNullableWithAggregatesFilter<"Customer"> | $Enums.OAuthProvider | null
    resetPasswordToken?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    resetPasswordTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    verifyToken?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    verifyTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    pendingEmail?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    pendingEmailToken?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    pendingEmailTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
  }

  export type CustomerAddressWhereInput = {
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    label?: EnumLabelFilter<"CustomerAddress"> | $Enums.Label
    address?: StringFilter<"CustomerAddress"> | string
    city?: StringFilter<"CustomerAddress"> | string
    postalCode?: StringFilter<"CustomerAddress"> | string
    latitude?: FloatFilter<"CustomerAddress"> | number
    longitude?: FloatFilter<"CustomerAddress"> | number
    notes?: StringNullableFilter<"CustomerAddress"> | string | null
    isPrimary?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CustomerAddress"> | Date | string | null
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    PickUpTask?: PickUpTaskListRelationFilter
    DeliveryTask?: DeliveryTaskListRelationFilter
  }

  export type CustomerAddressOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    customers?: CustomerOrderByWithRelationInput
    PickUpTask?: PickUpTaskOrderByRelationAggregateInput
    DeliveryTask?: DeliveryTaskOrderByRelationAggregateInput
  }

  export type CustomerAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    customerId?: StringFilter<"CustomerAddress"> | string
    label?: EnumLabelFilter<"CustomerAddress"> | $Enums.Label
    address?: StringFilter<"CustomerAddress"> | string
    city?: StringFilter<"CustomerAddress"> | string
    postalCode?: StringFilter<"CustomerAddress"> | string
    latitude?: FloatFilter<"CustomerAddress"> | number
    longitude?: FloatFilter<"CustomerAddress"> | number
    notes?: StringNullableFilter<"CustomerAddress"> | string | null
    isPrimary?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CustomerAddress"> | Date | string | null
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    PickUpTask?: PickUpTaskListRelationFilter
    DeliveryTask?: DeliveryTaskListRelationFilter
  }, "id">

  export type CustomerAddressOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CustomerAddressCountOrderByAggregateInput
    _avg?: CustomerAddressAvgOrderByAggregateInput
    _max?: CustomerAddressMaxOrderByAggregateInput
    _min?: CustomerAddressMinOrderByAggregateInput
    _sum?: CustomerAddressSumOrderByAggregateInput
  }

  export type CustomerAddressScalarWhereWithAggregatesInput = {
    AND?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    OR?: CustomerAddressScalarWhereWithAggregatesInput[]
    NOT?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerAddress"> | string
    customerId?: StringWithAggregatesFilter<"CustomerAddress"> | string
    label?: EnumLabelWithAggregatesFilter<"CustomerAddress"> | $Enums.Label
    address?: StringWithAggregatesFilter<"CustomerAddress"> | string
    city?: StringWithAggregatesFilter<"CustomerAddress"> | string
    postalCode?: StringWithAggregatesFilter<"CustomerAddress"> | string
    latitude?: FloatWithAggregatesFilter<"CustomerAddress"> | number
    longitude?: FloatWithAggregatesFilter<"CustomerAddress"> | number
    notes?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"CustomerAddress"> | Date | string | null
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    outletId?: StringFilter<"Employee"> | string
    shiftId?: StringFilter<"Employee"> | string
    role?: EnumRoleFilter<"Employee"> | $Enums.Role
    name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    password?: StringNullableFilter<"Employee"> | string | null
    phoneNumber?: StringFilter<"Employee"> | string
    address?: StringFilter<"Employee"> | string
    photoUrl?: StringNullableFilter<"Employee"> | string | null
    isActive?: BoolFilter<"Employee"> | boolean
    resetPasswordToken?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    shifts?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
    outlets?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    Attendance?: AttendanceListRelationFilter
    orderHeader?: OrderHeaderListRelationFilter
    WorkStation?: WorkStationListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
    assignedTasks?: EmployeeTaskListRelationFilter
    approvedAttendances?: AttendanceListRelationFilter
    pickUpDriver?: PickUpTaskListRelationFilter
    pickupAssignedBy?: PickUpTaskListRelationFilter
    deliveryDriver?: DeliveryTaskListRelationFilter
    deliveryAssignedBy?: DeliveryTaskListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    shifts?: ShiftOrderByWithRelationInput
    outlets?: OutletOrderByWithRelationInput
    Attendance?: AttendanceOrderByRelationAggregateInput
    orderHeader?: OrderHeaderOrderByRelationAggregateInput
    WorkStation?: WorkStationOrderByRelationAggregateInput
    workerTasks?: EmployeeTaskOrderByRelationAggregateInput
    assignedTasks?: EmployeeTaskOrderByRelationAggregateInput
    approvedAttendances?: AttendanceOrderByRelationAggregateInput
    pickUpDriver?: PickUpTaskOrderByRelationAggregateInput
    pickupAssignedBy?: PickUpTaskOrderByRelationAggregateInput
    deliveryDriver?: DeliveryTaskOrderByRelationAggregateInput
    deliveryAssignedBy?: DeliveryTaskOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    outletId?: StringFilter<"Employee"> | string
    shiftId?: StringFilter<"Employee"> | string
    role?: EnumRoleFilter<"Employee"> | $Enums.Role
    name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    password?: StringNullableFilter<"Employee"> | string | null
    phoneNumber?: StringFilter<"Employee"> | string
    address?: StringFilter<"Employee"> | string
    photoUrl?: StringNullableFilter<"Employee"> | string | null
    isActive?: BoolFilter<"Employee"> | boolean
    resetPasswordToken?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    shifts?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
    outlets?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    Attendance?: AttendanceListRelationFilter
    orderHeader?: OrderHeaderListRelationFilter
    WorkStation?: WorkStationListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
    assignedTasks?: EmployeeTaskListRelationFilter
    approvedAttendances?: AttendanceListRelationFilter
    pickUpDriver?: PickUpTaskListRelationFilter
    pickupAssignedBy?: PickUpTaskListRelationFilter
    deliveryDriver?: DeliveryTaskListRelationFilter
    deliveryAssignedBy?: DeliveryTaskListRelationFilter
  }, "id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    outletId?: StringWithAggregatesFilter<"Employee"> | string
    shiftId?: StringWithAggregatesFilter<"Employee"> | string
    role?: EnumRoleWithAggregatesFilter<"Employee"> | $Enums.Role
    name?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringWithAggregatesFilter<"Employee"> | string
    password?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"Employee"> | string
    address?: StringWithAggregatesFilter<"Employee"> | string
    photoUrl?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    isActive?: BoolWithAggregatesFilter<"Employee"> | boolean
    resetPasswordToken?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    name?: StringFilter<"Shift"> | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    Employee?: EmployeeListRelationFilter
    Attendance?: AttendanceListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Employee?: EmployeeOrderByRelationAggregateInput
    Attendance?: AttendanceOrderByRelationAggregateInput
    workerTasks?: EmployeeTaskOrderByRelationAggregateInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    name?: StringFilter<"Shift"> | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    Employee?: EmployeeListRelationFilter
    Attendance?: AttendanceListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    name?: StringWithAggregatesFilter<"Shift"> | string
    startTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Shift"> | Date | string | null
  }

  export type WorkStationWhereInput = {
    AND?: WorkStationWhereInput | WorkStationWhereInput[]
    OR?: WorkStationWhereInput[]
    NOT?: WorkStationWhereInput | WorkStationWhereInput[]
    id?: StringFilter<"WorkStation"> | string
    employeeId?: StringFilter<"WorkStation"> | string
    station?: EnumStationFilter<"WorkStation"> | $Enums.Station
    createdAt?: DateTimeFilter<"WorkStation"> | Date | string
    updatedAt?: DateTimeFilter<"WorkStation"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkStation"> | Date | string | null
    employees?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    workerTasks?: EmployeeTaskListRelationFilter
  }

  export type WorkStationOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    employees?: EmployeeOrderByWithRelationInput
    workerTasks?: EmployeeTaskOrderByRelationAggregateInput
  }

  export type WorkStationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkStationWhereInput | WorkStationWhereInput[]
    OR?: WorkStationWhereInput[]
    NOT?: WorkStationWhereInput | WorkStationWhereInput[]
    employeeId?: StringFilter<"WorkStation"> | string
    station?: EnumStationFilter<"WorkStation"> | $Enums.Station
    createdAt?: DateTimeFilter<"WorkStation"> | Date | string
    updatedAt?: DateTimeFilter<"WorkStation"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkStation"> | Date | string | null
    employees?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    workerTasks?: EmployeeTaskListRelationFilter
  }, "id">

  export type WorkStationOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WorkStationCountOrderByAggregateInput
    _max?: WorkStationMaxOrderByAggregateInput
    _min?: WorkStationMinOrderByAggregateInput
  }

  export type WorkStationScalarWhereWithAggregatesInput = {
    AND?: WorkStationScalarWhereWithAggregatesInput | WorkStationScalarWhereWithAggregatesInput[]
    OR?: WorkStationScalarWhereWithAggregatesInput[]
    NOT?: WorkStationScalarWhereWithAggregatesInput | WorkStationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkStation"> | string
    employeeId?: StringWithAggregatesFilter<"WorkStation"> | string
    station?: EnumStationWithAggregatesFilter<"WorkStation"> | $Enums.Station
    createdAt?: DateTimeWithAggregatesFilter<"WorkStation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkStation"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"WorkStation"> | Date | string | null
  }

  export type EmployeeTaskWhereInput = {
    AND?: EmployeeTaskWhereInput | EmployeeTaskWhereInput[]
    OR?: EmployeeTaskWhereInput[]
    NOT?: EmployeeTaskWhereInput | EmployeeTaskWhereInput[]
    id?: StringFilter<"EmployeeTask"> | string
    employeeId?: StringFilter<"EmployeeTask"> | string
    orderHeaderId?: StringFilter<"EmployeeTask"> | string
    orderItemId?: StringFilter<"EmployeeTask"> | string
    outletId?: StringFilter<"EmployeeTask"> | string
    shiftId?: StringFilter<"EmployeeTask"> | string
    workStationId?: StringFilter<"EmployeeTask"> | string
    status?: EnumTaskStatusFilter<"EmployeeTask"> | $Enums.TaskStatus
    itemQty?: IntNullableFilter<"EmployeeTask"> | number | null
    itemUnit?: StringNullableFilter<"EmployeeTask"> | string | null
    bypassReqNote?: StringNullableFilter<"EmployeeTask"> | string | null
    bypassReq?: BoolNullableFilter<"EmployeeTask"> | boolean | null
    isReqAprooved?: BoolNullableFilter<"EmployeeTask"> | boolean | null
    itemPassedNote?: StringNullableFilter<"EmployeeTask"> | string | null
    assignedById?: StringNullableFilter<"EmployeeTask"> | string | null
    createdAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    assignedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    orderHeader?: XOR<OrderHeaderNullableScalarRelationFilter, OrderHeaderWhereInput> | null
    orderItem?: XOR<OrderItemNullableScalarRelationFilter, OrderItemWhereInput> | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
    workStation?: XOR<WorkStationScalarRelationFilter, WorkStationWhereInput>
  }

  export type EmployeeTaskOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    orderHeaderId?: SortOrder
    orderItemId?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    workStationId?: SortOrder
    status?: SortOrder
    itemQty?: SortOrderInput | SortOrder
    itemUnit?: SortOrderInput | SortOrder
    bypassReqNote?: SortOrderInput | SortOrder
    bypassReq?: SortOrderInput | SortOrder
    isReqAprooved?: SortOrderInput | SortOrder
    itemPassedNote?: SortOrderInput | SortOrder
    assignedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    assignedBy?: EmployeeOrderByWithRelationInput
    orderHeader?: OrderHeaderOrderByWithRelationInput
    orderItem?: OrderItemOrderByWithRelationInput
    outlet?: OutletOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
    workStation?: WorkStationOrderByWithRelationInput
  }

  export type EmployeeTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeTaskWhereInput | EmployeeTaskWhereInput[]
    OR?: EmployeeTaskWhereInput[]
    NOT?: EmployeeTaskWhereInput | EmployeeTaskWhereInput[]
    employeeId?: StringFilter<"EmployeeTask"> | string
    orderHeaderId?: StringFilter<"EmployeeTask"> | string
    orderItemId?: StringFilter<"EmployeeTask"> | string
    outletId?: StringFilter<"EmployeeTask"> | string
    shiftId?: StringFilter<"EmployeeTask"> | string
    workStationId?: StringFilter<"EmployeeTask"> | string
    status?: EnumTaskStatusFilter<"EmployeeTask"> | $Enums.TaskStatus
    itemQty?: IntNullableFilter<"EmployeeTask"> | number | null
    itemUnit?: StringNullableFilter<"EmployeeTask"> | string | null
    bypassReqNote?: StringNullableFilter<"EmployeeTask"> | string | null
    bypassReq?: BoolNullableFilter<"EmployeeTask"> | boolean | null
    isReqAprooved?: BoolNullableFilter<"EmployeeTask"> | boolean | null
    itemPassedNote?: StringNullableFilter<"EmployeeTask"> | string | null
    assignedById?: StringNullableFilter<"EmployeeTask"> | string | null
    createdAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    assignedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    orderHeader?: XOR<OrderHeaderNullableScalarRelationFilter, OrderHeaderWhereInput> | null
    orderItem?: XOR<OrderItemNullableScalarRelationFilter, OrderItemWhereInput> | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
    workStation?: XOR<WorkStationScalarRelationFilter, WorkStationWhereInput>
  }, "id">

  export type EmployeeTaskOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    orderHeaderId?: SortOrder
    orderItemId?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    workStationId?: SortOrder
    status?: SortOrder
    itemQty?: SortOrderInput | SortOrder
    itemUnit?: SortOrderInput | SortOrder
    bypassReqNote?: SortOrderInput | SortOrder
    bypassReq?: SortOrderInput | SortOrder
    isReqAprooved?: SortOrderInput | SortOrder
    itemPassedNote?: SortOrderInput | SortOrder
    assignedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EmployeeTaskCountOrderByAggregateInput
    _avg?: EmployeeTaskAvgOrderByAggregateInput
    _max?: EmployeeTaskMaxOrderByAggregateInput
    _min?: EmployeeTaskMinOrderByAggregateInput
    _sum?: EmployeeTaskSumOrderByAggregateInput
  }

  export type EmployeeTaskScalarWhereWithAggregatesInput = {
    AND?: EmployeeTaskScalarWhereWithAggregatesInput | EmployeeTaskScalarWhereWithAggregatesInput[]
    OR?: EmployeeTaskScalarWhereWithAggregatesInput[]
    NOT?: EmployeeTaskScalarWhereWithAggregatesInput | EmployeeTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeTask"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeTask"> | string
    orderHeaderId?: StringWithAggregatesFilter<"EmployeeTask"> | string
    orderItemId?: StringWithAggregatesFilter<"EmployeeTask"> | string
    outletId?: StringWithAggregatesFilter<"EmployeeTask"> | string
    shiftId?: StringWithAggregatesFilter<"EmployeeTask"> | string
    workStationId?: StringWithAggregatesFilter<"EmployeeTask"> | string
    status?: EnumTaskStatusWithAggregatesFilter<"EmployeeTask"> | $Enums.TaskStatus
    itemQty?: IntNullableWithAggregatesFilter<"EmployeeTask"> | number | null
    itemUnit?: StringNullableWithAggregatesFilter<"EmployeeTask"> | string | null
    bypassReqNote?: StringNullableWithAggregatesFilter<"EmployeeTask"> | string | null
    bypassReq?: BoolNullableWithAggregatesFilter<"EmployeeTask"> | boolean | null
    isReqAprooved?: BoolNullableWithAggregatesFilter<"EmployeeTask"> | boolean | null
    itemPassedNote?: StringNullableWithAggregatesFilter<"EmployeeTask"> | string | null
    assignedById?: StringNullableWithAggregatesFilter<"EmployeeTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeTask"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeTask"> | Date | string | null
  }

  export type PickUpTaskWhereInput = {
    AND?: PickUpTaskWhereInput | PickUpTaskWhereInput[]
    OR?: PickUpTaskWhereInput[]
    NOT?: PickUpTaskWhereInput | PickUpTaskWhereInput[]
    id?: StringFilter<"PickUpTask"> | string
    driverId?: StringFilter<"PickUpTask"> | string
    outletId?: StringFilter<"PickUpTask"> | string
    customerAddressId?: StringFilter<"PickUpTask"> | string
    assignedByAdminId?: StringFilter<"PickUpTask"> | string
    orderHeaderId?: StringFilter<"PickUpTask"> | string
    status?: EnumPickupStatusFilter<"PickUpTask"> | $Enums.PickupStatus
    distance?: IntFilter<"PickUpTask"> | number
    price?: IntFilter<"PickUpTask"> | number
    createdAt?: DateTimeFilter<"PickUpTask"> | Date | string
    updatedAt?: DateTimeFilter<"PickUpTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PickUpTask"> | Date | string | null
    driver?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    assignedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    outlets?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    customerAddress?: XOR<CustomerAddressScalarRelationFilter, CustomerAddressWhereInput>
    orderHeader?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
  }

  export type PickUpTaskOrderByWithRelationInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    driver?: EmployeeOrderByWithRelationInput
    assignedBy?: EmployeeOrderByWithRelationInput
    outlets?: OutletOrderByWithRelationInput
    customerAddress?: CustomerAddressOrderByWithRelationInput
    orderHeader?: OrderHeaderOrderByWithRelationInput
  }

  export type PickUpTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PickUpTaskWhereInput | PickUpTaskWhereInput[]
    OR?: PickUpTaskWhereInput[]
    NOT?: PickUpTaskWhereInput | PickUpTaskWhereInput[]
    driverId?: StringFilter<"PickUpTask"> | string
    outletId?: StringFilter<"PickUpTask"> | string
    customerAddressId?: StringFilter<"PickUpTask"> | string
    assignedByAdminId?: StringFilter<"PickUpTask"> | string
    orderHeaderId?: StringFilter<"PickUpTask"> | string
    status?: EnumPickupStatusFilter<"PickUpTask"> | $Enums.PickupStatus
    distance?: IntFilter<"PickUpTask"> | number
    price?: IntFilter<"PickUpTask"> | number
    createdAt?: DateTimeFilter<"PickUpTask"> | Date | string
    updatedAt?: DateTimeFilter<"PickUpTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PickUpTask"> | Date | string | null
    driver?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    assignedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    outlets?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    customerAddress?: XOR<CustomerAddressScalarRelationFilter, CustomerAddressWhereInput>
    orderHeader?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
  }, "id">

  export type PickUpTaskOrderByWithAggregationInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PickUpTaskCountOrderByAggregateInput
    _avg?: PickUpTaskAvgOrderByAggregateInput
    _max?: PickUpTaskMaxOrderByAggregateInput
    _min?: PickUpTaskMinOrderByAggregateInput
    _sum?: PickUpTaskSumOrderByAggregateInput
  }

  export type PickUpTaskScalarWhereWithAggregatesInput = {
    AND?: PickUpTaskScalarWhereWithAggregatesInput | PickUpTaskScalarWhereWithAggregatesInput[]
    OR?: PickUpTaskScalarWhereWithAggregatesInput[]
    NOT?: PickUpTaskScalarWhereWithAggregatesInput | PickUpTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PickUpTask"> | string
    driverId?: StringWithAggregatesFilter<"PickUpTask"> | string
    outletId?: StringWithAggregatesFilter<"PickUpTask"> | string
    customerAddressId?: StringWithAggregatesFilter<"PickUpTask"> | string
    assignedByAdminId?: StringWithAggregatesFilter<"PickUpTask"> | string
    orderHeaderId?: StringWithAggregatesFilter<"PickUpTask"> | string
    status?: EnumPickupStatusWithAggregatesFilter<"PickUpTask"> | $Enums.PickupStatus
    distance?: IntWithAggregatesFilter<"PickUpTask"> | number
    price?: IntWithAggregatesFilter<"PickUpTask"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PickUpTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PickUpTask"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PickUpTask"> | Date | string | null
  }

  export type DeliveryTaskWhereInput = {
    AND?: DeliveryTaskWhereInput | DeliveryTaskWhereInput[]
    OR?: DeliveryTaskWhereInput[]
    NOT?: DeliveryTaskWhereInput | DeliveryTaskWhereInput[]
    id?: StringFilter<"DeliveryTask"> | string
    driverId?: StringFilter<"DeliveryTask"> | string
    outletId?: StringFilter<"DeliveryTask"> | string
    customerAddressId?: StringFilter<"DeliveryTask"> | string
    assignedByAdminId?: StringFilter<"DeliveryTask"> | string
    orderHeaderId?: StringFilter<"DeliveryTask"> | string
    status?: EnumDeilveryStatusFilter<"DeliveryTask"> | $Enums.DeilveryStatus
    distance?: IntFilter<"DeliveryTask"> | number
    price?: IntFilter<"DeliveryTask"> | number
    createdAt?: DateTimeFilter<"DeliveryTask"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DeliveryTask"> | Date | string | null
    driver?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    assignedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    outlets?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    customerAddress?: XOR<CustomerAddressScalarRelationFilter, CustomerAddressWhereInput>
    orderHeader?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
  }

  export type DeliveryTaskOrderByWithRelationInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    driver?: EmployeeOrderByWithRelationInput
    assignedBy?: EmployeeOrderByWithRelationInput
    outlets?: OutletOrderByWithRelationInput
    customerAddress?: CustomerAddressOrderByWithRelationInput
    orderHeader?: OrderHeaderOrderByWithRelationInput
  }

  export type DeliveryTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryTaskWhereInput | DeliveryTaskWhereInput[]
    OR?: DeliveryTaskWhereInput[]
    NOT?: DeliveryTaskWhereInput | DeliveryTaskWhereInput[]
    driverId?: StringFilter<"DeliveryTask"> | string
    outletId?: StringFilter<"DeliveryTask"> | string
    customerAddressId?: StringFilter<"DeliveryTask"> | string
    assignedByAdminId?: StringFilter<"DeliveryTask"> | string
    orderHeaderId?: StringFilter<"DeliveryTask"> | string
    status?: EnumDeilveryStatusFilter<"DeliveryTask"> | $Enums.DeilveryStatus
    distance?: IntFilter<"DeliveryTask"> | number
    price?: IntFilter<"DeliveryTask"> | number
    createdAt?: DateTimeFilter<"DeliveryTask"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DeliveryTask"> | Date | string | null
    driver?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    assignedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    outlets?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    customerAddress?: XOR<CustomerAddressScalarRelationFilter, CustomerAddressWhereInput>
    orderHeader?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
  }, "id">

  export type DeliveryTaskOrderByWithAggregationInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DeliveryTaskCountOrderByAggregateInput
    _avg?: DeliveryTaskAvgOrderByAggregateInput
    _max?: DeliveryTaskMaxOrderByAggregateInput
    _min?: DeliveryTaskMinOrderByAggregateInput
    _sum?: DeliveryTaskSumOrderByAggregateInput
  }

  export type DeliveryTaskScalarWhereWithAggregatesInput = {
    AND?: DeliveryTaskScalarWhereWithAggregatesInput | DeliveryTaskScalarWhereWithAggregatesInput[]
    OR?: DeliveryTaskScalarWhereWithAggregatesInput[]
    NOT?: DeliveryTaskScalarWhereWithAggregatesInput | DeliveryTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryTask"> | string
    driverId?: StringWithAggregatesFilter<"DeliveryTask"> | string
    outletId?: StringWithAggregatesFilter<"DeliveryTask"> | string
    customerAddressId?: StringWithAggregatesFilter<"DeliveryTask"> | string
    assignedByAdminId?: StringWithAggregatesFilter<"DeliveryTask"> | string
    orderHeaderId?: StringWithAggregatesFilter<"DeliveryTask"> | string
    status?: EnumDeilveryStatusWithAggregatesFilter<"DeliveryTask"> | $Enums.DeilveryStatus
    distance?: IntWithAggregatesFilter<"DeliveryTask"> | number
    price?: IntWithAggregatesFilter<"DeliveryTask"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryTask"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"DeliveryTask"> | Date | string | null
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    employeeId?: StringFilter<"Attendance"> | string
    shiftId?: StringFilter<"Attendance"> | string
    outletId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    clockInAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    clockOutAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    workMinutes?: IntNullableFilter<"Attendance"> | number | null
    lateMinutes?: IntNullableFilter<"Attendance"> | number | null
    earlyLeaveMin?: IntNullableFilter<"Attendance"> | number | null
    notes?: StringNullableFilter<"Attendance"> | string | null
    approvedById?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    employees?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    approvedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrderInput | SortOrder
    clockOutAt?: SortOrderInput | SortOrder
    workMinutes?: SortOrderInput | SortOrder
    lateMinutes?: SortOrderInput | SortOrder
    earlyLeaveMin?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    employees?: EmployeeOrderByWithRelationInput
    outlet?: OutletOrderByWithRelationInput
    approvedBy?: EmployeeOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    employeeId?: StringFilter<"Attendance"> | string
    shiftId?: StringFilter<"Attendance"> | string
    outletId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    clockInAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    clockOutAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    workMinutes?: IntNullableFilter<"Attendance"> | number | null
    lateMinutes?: IntNullableFilter<"Attendance"> | number | null
    earlyLeaveMin?: IntNullableFilter<"Attendance"> | number | null
    notes?: StringNullableFilter<"Attendance"> | string | null
    approvedById?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    employees?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    approvedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrderInput | SortOrder
    clockOutAt?: SortOrderInput | SortOrder
    workMinutes?: SortOrderInput | SortOrder
    lateMinutes?: SortOrderInput | SortOrder
    earlyLeaveMin?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    employeeId?: StringWithAggregatesFilter<"Attendance"> | string
    shiftId?: StringWithAggregatesFilter<"Attendance"> | string
    outletId?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    clockInAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    clockOutAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    workMinutes?: IntNullableWithAggregatesFilter<"Attendance"> | number | null
    lateMinutes?: IntNullableWithAggregatesFilter<"Attendance"> | number | null
    earlyLeaveMin?: IntNullableWithAggregatesFilter<"Attendance"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
  }

  export type OutletWhereInput = {
    AND?: OutletWhereInput | OutletWhereInput[]
    OR?: OutletWhereInput[]
    NOT?: OutletWhereInput | OutletWhereInput[]
    id?: StringFilter<"Outlet"> | string
    name?: StringFilter<"Outlet"> | string
    address?: StringFilter<"Outlet"> | string
    phoneNumber?: StringFilter<"Outlet"> | string
    city?: StringFilter<"Outlet"> | string
    postalCode?: StringFilter<"Outlet"> | string
    latitude?: FloatFilter<"Outlet"> | number
    longitude?: FloatFilter<"Outlet"> | number
    coverageArea?: IntFilter<"Outlet"> | number
    isActive?: BoolFilter<"Outlet"> | boolean
    createdAt?: DateTimeFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeFilter<"Outlet"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Outlet"> | Date | string | null
    Employee?: EmployeeListRelationFilter
    Attendance?: AttendanceListRelationFilter
    OutletSchedule?: OutletScheduleListRelationFilter
    orderHeader?: OrderHeaderListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
    PickUpTask?: PickUpTaskListRelationFilter
    DeliveryTask?: DeliveryTaskListRelationFilter
  }

  export type OutletOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Employee?: EmployeeOrderByRelationAggregateInput
    Attendance?: AttendanceOrderByRelationAggregateInput
    OutletSchedule?: OutletScheduleOrderByRelationAggregateInput
    orderHeader?: OrderHeaderOrderByRelationAggregateInput
    workerTasks?: EmployeeTaskOrderByRelationAggregateInput
    PickUpTask?: PickUpTaskOrderByRelationAggregateInput
    DeliveryTask?: DeliveryTaskOrderByRelationAggregateInput
  }

  export type OutletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutletWhereInput | OutletWhereInput[]
    OR?: OutletWhereInput[]
    NOT?: OutletWhereInput | OutletWhereInput[]
    name?: StringFilter<"Outlet"> | string
    address?: StringFilter<"Outlet"> | string
    phoneNumber?: StringFilter<"Outlet"> | string
    city?: StringFilter<"Outlet"> | string
    postalCode?: StringFilter<"Outlet"> | string
    latitude?: FloatFilter<"Outlet"> | number
    longitude?: FloatFilter<"Outlet"> | number
    coverageArea?: IntFilter<"Outlet"> | number
    isActive?: BoolFilter<"Outlet"> | boolean
    createdAt?: DateTimeFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeFilter<"Outlet"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Outlet"> | Date | string | null
    Employee?: EmployeeListRelationFilter
    Attendance?: AttendanceListRelationFilter
    OutletSchedule?: OutletScheduleListRelationFilter
    orderHeader?: OrderHeaderListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
    PickUpTask?: PickUpTaskListRelationFilter
    DeliveryTask?: DeliveryTaskListRelationFilter
  }, "id">

  export type OutletOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OutletCountOrderByAggregateInput
    _avg?: OutletAvgOrderByAggregateInput
    _max?: OutletMaxOrderByAggregateInput
    _min?: OutletMinOrderByAggregateInput
    _sum?: OutletSumOrderByAggregateInput
  }

  export type OutletScalarWhereWithAggregatesInput = {
    AND?: OutletScalarWhereWithAggregatesInput | OutletScalarWhereWithAggregatesInput[]
    OR?: OutletScalarWhereWithAggregatesInput[]
    NOT?: OutletScalarWhereWithAggregatesInput | OutletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Outlet"> | string
    name?: StringWithAggregatesFilter<"Outlet"> | string
    address?: StringWithAggregatesFilter<"Outlet"> | string
    phoneNumber?: StringWithAggregatesFilter<"Outlet"> | string
    city?: StringWithAggregatesFilter<"Outlet"> | string
    postalCode?: StringWithAggregatesFilter<"Outlet"> | string
    latitude?: FloatWithAggregatesFilter<"Outlet"> | number
    longitude?: FloatWithAggregatesFilter<"Outlet"> | number
    coverageArea?: IntWithAggregatesFilter<"Outlet"> | number
    isActive?: BoolWithAggregatesFilter<"Outlet"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Outlet"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Outlet"> | Date | string | null
  }

  export type OutletScheduleWhereInput = {
    AND?: OutletScheduleWhereInput | OutletScheduleWhereInput[]
    OR?: OutletScheduleWhereInput[]
    NOT?: OutletScheduleWhereInput | OutletScheduleWhereInput[]
    id?: StringFilter<"OutletSchedule"> | string
    outletId?: StringFilter<"OutletSchedule"> | string
    detailDays?: StringFilter<"OutletSchedule"> | string
    openHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    closeHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    createdAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OutletSchedule"> | Date | string | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
  }

  export type OutletScheduleOrderByWithRelationInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    outlet?: OutletOrderByWithRelationInput
  }

  export type OutletScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutletScheduleWhereInput | OutletScheduleWhereInput[]
    OR?: OutletScheduleWhereInput[]
    NOT?: OutletScheduleWhereInput | OutletScheduleWhereInput[]
    outletId?: StringFilter<"OutletSchedule"> | string
    detailDays?: StringFilter<"OutletSchedule"> | string
    openHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    closeHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    createdAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OutletSchedule"> | Date | string | null
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
  }, "id">

  export type OutletScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OutletScheduleCountOrderByAggregateInput
    _max?: OutletScheduleMaxOrderByAggregateInput
    _min?: OutletScheduleMinOrderByAggregateInput
  }

  export type OutletScheduleScalarWhereWithAggregatesInput = {
    AND?: OutletScheduleScalarWhereWithAggregatesInput | OutletScheduleScalarWhereWithAggregatesInput[]
    OR?: OutletScheduleScalarWhereWithAggregatesInput[]
    NOT?: OutletScheduleScalarWhereWithAggregatesInput | OutletScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutletSchedule"> | string
    outletId?: StringWithAggregatesFilter<"OutletSchedule"> | string
    detailDays?: StringWithAggregatesFilter<"OutletSchedule"> | string
    openHour?: DateTimeWithAggregatesFilter<"OutletSchedule"> | Date | string
    closeHour?: DateTimeWithAggregatesFilter<"OutletSchedule"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OutletSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutletSchedule"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"OutletSchedule"> | Date | string | null
  }

  export type ServiceCategoryWhereInput = {
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    id?: StringFilter<"ServiceCategory"> | string
    name?: StringFilter<"ServiceCategory"> | string
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ServiceCategory"> | Date | string | null
    Service?: ServiceListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Service?: ServiceOrderByRelationAggregateInput
  }

  export type ServiceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    name?: StringFilter<"ServiceCategory"> | string
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ServiceCategory"> | Date | string | null
    Service?: ServiceListRelationFilter
  }, "id">

  export type ServiceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    OR?: ServiceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCategory"> | string
    name?: StringWithAggregatesFilter<"ServiceCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ServiceCategory"> | Date | string | null
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    serviceCategoryId?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    unit?: StringFilter<"Service"> | string
    basePrice?: IntFilter<"Service"> | number
    minQty?: IntFilter<"Service"> | number
    etaHours?: IntFilter<"Service"> | number
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    serviceCatId?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    OrderItem?: OrderItemListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    serviceCategoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    etaHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    serviceCatId?: ServiceCategoryOrderByWithRelationInput
    OrderItem?: OrderItemOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    serviceCategoryId?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    unit?: StringFilter<"Service"> | string
    basePrice?: IntFilter<"Service"> | number
    minQty?: IntFilter<"Service"> | number
    etaHours?: IntFilter<"Service"> | number
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    serviceCatId?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    OrderItem?: OrderItemListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    serviceCategoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    etaHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    serviceCategoryId?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    unit?: StringWithAggregatesFilter<"Service"> | string
    basePrice?: IntWithAggregatesFilter<"Service"> | number
    minQty?: IntWithAggregatesFilter<"Service"> | number
    etaHours?: IntWithAggregatesFilter<"Service"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
  }

  export type OrderHeaderWhereInput = {
    AND?: OrderHeaderWhereInput | OrderHeaderWhereInput[]
    OR?: OrderHeaderWhereInput[]
    NOT?: OrderHeaderWhereInput | OrderHeaderWhereInput[]
    id?: StringFilter<"OrderHeader"> | string
    customerId?: StringFilter<"OrderHeader"> | string
    handledById?: StringNullableFilter<"OrderHeader"> | string | null
    outletId?: StringFilter<"OrderHeader"> | string
    status?: EnumOrderStatusFilter<"OrderHeader"> | $Enums.OrderStatus
    notes?: StringFilter<"OrderHeader"> | string
    pickupAt?: DateTimeFilter<"OrderHeader"> | Date | string
    deliverAt?: DateTimeFilter<"OrderHeader"> | Date | string
    estHours?: IntFilter<"OrderHeader"> | number
    createdAt?: DateTimeFilter<"OrderHeader"> | Date | string
    updatedAt?: DateTimeFilter<"OrderHeader"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    employees?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    outlets?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    OrderItem?: OrderItemListRelationFilter
    Payment?: PaymentListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
    PickUpTask?: PickUpTaskListRelationFilter
    DeliveryTask?: DeliveryTaskListRelationFilter
  }

  export type OrderHeaderOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    handledById?: SortOrderInput | SortOrder
    outletId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrder
    deliverAt?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    customers?: CustomerOrderByWithRelationInput
    employees?: EmployeeOrderByWithRelationInput
    outlets?: OutletOrderByWithRelationInput
    OrderItem?: OrderItemOrderByRelationAggregateInput
    Payment?: PaymentOrderByRelationAggregateInput
    workerTasks?: EmployeeTaskOrderByRelationAggregateInput
    PickUpTask?: PickUpTaskOrderByRelationAggregateInput
    DeliveryTask?: DeliveryTaskOrderByRelationAggregateInput
  }

  export type OrderHeaderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderHeaderWhereInput | OrderHeaderWhereInput[]
    OR?: OrderHeaderWhereInput[]
    NOT?: OrderHeaderWhereInput | OrderHeaderWhereInput[]
    customerId?: StringFilter<"OrderHeader"> | string
    handledById?: StringNullableFilter<"OrderHeader"> | string | null
    outletId?: StringFilter<"OrderHeader"> | string
    status?: EnumOrderStatusFilter<"OrderHeader"> | $Enums.OrderStatus
    notes?: StringFilter<"OrderHeader"> | string
    pickupAt?: DateTimeFilter<"OrderHeader"> | Date | string
    deliverAt?: DateTimeFilter<"OrderHeader"> | Date | string
    estHours?: IntFilter<"OrderHeader"> | number
    createdAt?: DateTimeFilter<"OrderHeader"> | Date | string
    updatedAt?: DateTimeFilter<"OrderHeader"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    employees?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    outlets?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    OrderItem?: OrderItemListRelationFilter
    Payment?: PaymentListRelationFilter
    workerTasks?: EmployeeTaskListRelationFilter
    PickUpTask?: PickUpTaskListRelationFilter
    DeliveryTask?: DeliveryTaskListRelationFilter
  }, "id">

  export type OrderHeaderOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    handledById?: SortOrderInput | SortOrder
    outletId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrder
    deliverAt?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OrderHeaderCountOrderByAggregateInput
    _avg?: OrderHeaderAvgOrderByAggregateInput
    _max?: OrderHeaderMaxOrderByAggregateInput
    _min?: OrderHeaderMinOrderByAggregateInput
    _sum?: OrderHeaderSumOrderByAggregateInput
  }

  export type OrderHeaderScalarWhereWithAggregatesInput = {
    AND?: OrderHeaderScalarWhereWithAggregatesInput | OrderHeaderScalarWhereWithAggregatesInput[]
    OR?: OrderHeaderScalarWhereWithAggregatesInput[]
    NOT?: OrderHeaderScalarWhereWithAggregatesInput | OrderHeaderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderHeader"> | string
    customerId?: StringWithAggregatesFilter<"OrderHeader"> | string
    handledById?: StringNullableWithAggregatesFilter<"OrderHeader"> | string | null
    outletId?: StringWithAggregatesFilter<"OrderHeader"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"OrderHeader"> | $Enums.OrderStatus
    notes?: StringWithAggregatesFilter<"OrderHeader"> | string
    pickupAt?: DateTimeWithAggregatesFilter<"OrderHeader"> | Date | string
    deliverAt?: DateTimeWithAggregatesFilter<"OrderHeader"> | Date | string
    estHours?: IntWithAggregatesFilter<"OrderHeader"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderHeader"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderHeader"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"OrderHeader"> | Date | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderHeaderId?: StringFilter<"OrderItem"> | string
    serviceId?: StringFilter<"OrderItem"> | string
    qty?: IntFilter<"OrderItem"> | number
    unitPrice?: IntFilter<"OrderItem"> | number
    subTotal?: IntFilter<"OrderItem"> | number
    note?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    orderheader?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    workerTasks?: EmployeeTaskListRelationFilter
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    orderheader?: OrderHeaderOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    workerTasks?: EmployeeTaskOrderByRelationAggregateInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderHeaderId?: StringFilter<"OrderItem"> | string
    serviceId?: StringFilter<"OrderItem"> | string
    qty?: IntFilter<"OrderItem"> | number
    unitPrice?: IntFilter<"OrderItem"> | number
    subTotal?: IntFilter<"OrderItem"> | number
    note?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    orderheader?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    workerTasks?: EmployeeTaskListRelationFilter
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderHeaderId?: StringWithAggregatesFilter<"OrderItem"> | string
    serviceId?: StringWithAggregatesFilter<"OrderItem"> | string
    qty?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: IntWithAggregatesFilter<"OrderItem"> | number
    subTotal?: IntWithAggregatesFilter<"OrderItem"> | number
    note?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderHeaderId?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: IntFilter<"Payment"> | number
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    providerRef?: StringFilter<"Payment"> | string
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    orderheader?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    orderheader?: OrderHeaderOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    orderHeaderId?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: IntFilter<"Payment"> | number
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    providerRef?: StringFilter<"Payment"> | string
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    orderheader?: XOR<OrderHeaderScalarRelationFilter, OrderHeaderWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    orderHeaderId?: StringWithAggregatesFilter<"Payment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    amount?: IntWithAggregatesFilter<"Payment"> | number
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    providerRef?: StringWithAggregatesFilter<"Payment"> | string
    paidAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    role?: $Enums.Role
    name?: string | null
    email: string
    password?: string | null
    phoneNumber?: string | null
    photoUrl?: string | null
    isVerified?: boolean
    selectProvider?: $Enums.OAuthProvider | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiresAt?: Date | string | null
    verifyToken?: string | null
    verifyTokenExpiresAt?: Date | string | null
    pendingEmail?: string | null
    pendingEmailToken?: string | null
    pendingEmailTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerAddress?: CustomerAddressCreateNestedManyWithoutCustomersInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    role?: $Enums.Role
    name?: string | null
    email: string
    password?: string | null
    phoneNumber?: string | null
    photoUrl?: string | null
    isVerified?: boolean
    selectProvider?: $Enums.OAuthProvider | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiresAt?: Date | string | null
    verifyToken?: string | null
    verifyTokenExpiresAt?: Date | string | null
    pendingEmail?: string | null
    pendingEmailToken?: string | null
    pendingEmailTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerAddress?: CustomerAddressUncheckedCreateNestedManyWithoutCustomersInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    selectProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAddress?: CustomerAddressUpdateManyWithoutCustomersNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    selectProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAddress?: CustomerAddressUncheckedUpdateManyWithoutCustomersNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    role?: $Enums.Role
    name?: string | null
    email: string
    password?: string | null
    phoneNumber?: string | null
    photoUrl?: string | null
    isVerified?: boolean
    selectProvider?: $Enums.OAuthProvider | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiresAt?: Date | string | null
    verifyToken?: string | null
    verifyTokenExpiresAt?: Date | string | null
    pendingEmail?: string | null
    pendingEmailToken?: string | null
    pendingEmailTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    selectProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    selectProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerAddressCreateInput = {
    id?: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutCustomerAddressInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutCustomerAddressInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUncheckedCreateInput = {
    id?: string
    customerId: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutCustomerAddressInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutCustomerAddressNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutCustomerAddressNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutCustomerAddressNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressCreateManyInput = {
    id?: string
    customerId: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShiftCreateInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutShiftsInput
    Attendance?: AttendanceCreateNestedManyWithoutShiftInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutShiftsInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutShiftInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutShiftsNestedInput
    Attendance?: AttendanceUpdateManyWithoutShiftNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutShiftsNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutShiftNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftCreateManyInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkStationCreateInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees: EmployeeCreateNestedOneWithoutWorkStationInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutWorkStationInput
  }

  export type WorkStationUncheckedCreateInput = {
    id?: string
    employeeId: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutWorkStationInput
  }

  export type WorkStationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateOneRequiredWithoutWorkStationNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutWorkStationNestedInput
  }

  export type WorkStationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutWorkStationNestedInput
  }

  export type WorkStationCreateManyInput = {
    id?: string
    employeeId: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkStationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkStationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskCreateInput = {
    id?: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutAssignedTasksInput
    orderHeader?: OrderHeaderCreateNestedOneWithoutWorkerTasksInput
    orderItem?: OrderItemCreateNestedOneWithoutWorkerTasksInput
    outlet: OutletCreateNestedOneWithoutWorkerTasksInput
    shift: ShiftCreateNestedOneWithoutWorkerTasksInput
    workStation: WorkStationCreateNestedOneWithoutWorkerTasksInput
  }

  export type EmployeeTaskUncheckedCreateInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutAssignedTasksNestedInput
    orderHeader?: OrderHeaderUpdateOneWithoutWorkerTasksNestedInput
    orderItem?: OrderItemUpdateOneWithoutWorkerTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutWorkerTasksNestedInput
    shift?: ShiftUpdateOneRequiredWithoutWorkerTasksNestedInput
    workStation?: WorkStationUpdateOneRequiredWithoutWorkerTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskCreateManyInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskCreateInput = {
    id?: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutPickUpDriverInput
    assignedBy?: EmployeeCreateNestedOneWithoutPickupAssignedByInput
    outlets: OutletCreateNestedOneWithoutPickUpTaskInput
    customerAddress: CustomerAddressCreateNestedOneWithoutPickUpTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutPickUpTaskInput
  }

  export type PickUpTaskUncheckedCreateInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutPickUpDriverNestedInput
    assignedBy?: EmployeeUpdateOneWithoutPickupAssignedByNestedInput
    outlets?: OutletUpdateOneRequiredWithoutPickUpTaskNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutPickUpTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutPickUpTaskNestedInput
  }

  export type PickUpTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskCreateManyInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskCreateInput = {
    id?: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutDeliveryDriverInput
    assignedBy?: EmployeeCreateNestedOneWithoutDeliveryAssignedByInput
    outlets: OutletCreateNestedOneWithoutDeliveryTaskInput
    customerAddress: CustomerAddressCreateNestedOneWithoutDeliveryTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutDeliveryTaskInput
  }

  export type DeliveryTaskUncheckedCreateInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutDeliveryDriverNestedInput
    assignedBy?: EmployeeUpdateOneWithoutDeliveryAssignedByNestedInput
    outlets?: OutletUpdateOneRequiredWithoutDeliveryTaskNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutDeliveryTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutDeliveryTaskNestedInput
  }

  export type DeliveryTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskCreateManyInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees: EmployeeCreateNestedOneWithoutAttendanceInput
    outlet: OutletCreateNestedOneWithoutAttendanceInput
    approvedBy?: EmployeeCreateNestedOneWithoutApprovedAttendancesInput
    shift: ShiftCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateOneRequiredWithoutAttendanceNestedInput
    outlet?: OutletUpdateOneRequiredWithoutAttendanceNestedInput
    approvedBy?: EmployeeUpdateOneWithoutApprovedAttendancesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateManyInput = {
    id?: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletCreateInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOutletsInput
  }

  export type OutletUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOutletsInput
  }

  export type OutletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOutletsNestedInput
  }

  export type OutletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOutletsNestedInput
  }

  export type OutletCreateManyInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleCreateInput = {
    id?: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutOutletScheduleInput
  }

  export type OutletScheduleUncheckedCreateInput = {
    id?: string
    outletId: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutOutletScheduleNestedInput
  }

  export type OutletScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleCreateManyInput = {
    id?: string
    outletId: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Service?: ServiceCreateNestedManyWithoutServiceCatIdInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Service?: ServiceUncheckedCreateNestedManyWithoutServiceCatIdInput
  }

  export type ServiceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Service?: ServiceUpdateManyWithoutServiceCatIdNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Service?: ServiceUncheckedUpdateManyWithoutServiceCatIdNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    etaHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceCatId: ServiceCategoryCreateNestedOneWithoutServiceInput
    OrderItem?: OrderItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    serviceCategoryId: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    etaHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: IntFieldUpdateOperationsInput | number
    etaHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCatId?: ServiceCategoryUpdateOneRequiredWithoutServiceNestedInput
    OrderItem?: OrderItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: IntFieldUpdateOperationsInput | number
    etaHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    serviceCategoryId: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    etaHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: IntFieldUpdateOperationsInput | number
    etaHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: IntFieldUpdateOperationsInput | number
    etaHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderCreateInput = {
    id?: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutOrderHeaderInput
    employees?: EmployeeCreateNestedOneWithoutOrderHeaderInput
    outlets: OutletCreateNestedOneWithoutOrderHeaderInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUncheckedCreateInput = {
    id?: string
    customerId: string
    handledById?: string | null
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutOrderHeaderNestedInput
    employees?: EmployeeUpdateOneWithoutOrderHeaderNestedInput
    outlets?: OutletUpdateOneRequiredWithoutOrderHeaderNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderCreateManyInput = {
    id?: string
    customerId: string
    handledById?: string | null
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderHeaderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderheader: OrderHeaderCreateNestedOneWithoutOrderItemInput
    service: ServiceCreateNestedOneWithoutOrderItemInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderHeaderId: string
    serviceId: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderheader?: OrderHeaderUpdateOneRequiredWithoutOrderItemNestedInput
    service?: ServiceUpdateOneRequiredWithoutOrderItemNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderHeaderId: string
    serviceId: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: number
    status?: $Enums.PaymentStatus
    providerRef: string
    paidAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderheader: OrderHeaderCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    orderHeaderId: string
    method: $Enums.PaymentMethod
    amount: number
    status?: $Enums.PaymentStatus
    providerRef: string
    paidAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    providerRef?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderheader?: OrderHeaderUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    providerRef?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    orderHeaderId: string
    method: $Enums.PaymentMethod
    amount: number
    status?: $Enums.PaymentStatus
    providerRef: string
    paidAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    providerRef?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    providerRef?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumOAuthProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOAuthProviderNullableFilter<$PrismaModel> | $Enums.OAuthProvider | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CustomerAddressListRelationFilter = {
    every?: CustomerAddressWhereInput
    some?: CustomerAddressWhereInput
    none?: CustomerAddressWhereInput
  }

  export type OrderHeaderListRelationFilter = {
    every?: OrderHeaderWhereInput
    some?: OrderHeaderWhereInput
    none?: OrderHeaderWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CustomerAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderHeaderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    photoUrl?: SortOrder
    isVerified?: SortOrder
    selectProvider?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordTokenExpiresAt?: SortOrder
    verifyToken?: SortOrder
    verifyTokenExpiresAt?: SortOrder
    pendingEmail?: SortOrder
    pendingEmailToken?: SortOrder
    pendingEmailTokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    photoUrl?: SortOrder
    isVerified?: SortOrder
    selectProvider?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordTokenExpiresAt?: SortOrder
    verifyToken?: SortOrder
    verifyTokenExpiresAt?: SortOrder
    pendingEmail?: SortOrder
    pendingEmailToken?: SortOrder
    pendingEmailTokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    photoUrl?: SortOrder
    isVerified?: SortOrder
    selectProvider?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordTokenExpiresAt?: SortOrder
    verifyToken?: SortOrder
    verifyTokenExpiresAt?: SortOrder
    pendingEmail?: SortOrder
    pendingEmailToken?: SortOrder
    pendingEmailTokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumOAuthProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOAuthProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.OAuthProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOAuthProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumOAuthProviderNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumLabelFilter<$PrismaModel = never> = {
    equals?: $Enums.Label | EnumLabelFieldRefInput<$PrismaModel>
    in?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelFilter<$PrismaModel> | $Enums.Label
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type PickUpTaskListRelationFilter = {
    every?: PickUpTaskWhereInput
    some?: PickUpTaskWhereInput
    none?: PickUpTaskWhereInput
  }

  export type DeliveryTaskListRelationFilter = {
    every?: DeliveryTaskWhereInput
    some?: DeliveryTaskWhereInput
    none?: DeliveryTaskWhereInput
  }

  export type PickUpTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerAddressCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerAddressAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type CustomerAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerAddressMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    label?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerAddressSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumLabelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Label | EnumLabelFieldRefInput<$PrismaModel>
    in?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelWithAggregatesFilter<$PrismaModel> | $Enums.Label
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabelFilter<$PrismaModel>
    _max?: NestedEnumLabelFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ShiftScalarRelationFilter = {
    is?: ShiftWhereInput
    isNot?: ShiftWhereInput
  }

  export type OutletScalarRelationFilter = {
    is?: OutletWhereInput
    isNot?: OutletWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type WorkStationListRelationFilter = {
    every?: WorkStationWhereInput
    some?: WorkStationWhereInput
    none?: WorkStationWhereInput
  }

  export type EmployeeTaskListRelationFilter = {
    every?: EmployeeTaskWhereInput
    some?: EmployeeTaskWhereInput
    none?: EmployeeTaskWhereInput
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkStationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    photoUrl?: SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    photoUrl?: SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    photoUrl?: SortOrder
    isActive?: SortOrder
    resetPasswordToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumStationFilter<$PrismaModel = never> = {
    equals?: $Enums.Station | EnumStationFieldRefInput<$PrismaModel>
    in?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    not?: NestedEnumStationFilter<$PrismaModel> | $Enums.Station
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type WorkStationCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkStationMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkStationMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    station?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumStationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Station | EnumStationFieldRefInput<$PrismaModel>
    in?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    not?: NestedEnumStationWithAggregatesFilter<$PrismaModel> | $Enums.Station
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStationFilter<$PrismaModel>
    _max?: NestedEnumStationFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type OrderHeaderNullableScalarRelationFilter = {
    is?: OrderHeaderWhereInput | null
    isNot?: OrderHeaderWhereInput | null
  }

  export type OrderItemNullableScalarRelationFilter = {
    is?: OrderItemWhereInput | null
    isNot?: OrderItemWhereInput | null
  }

  export type WorkStationScalarRelationFilter = {
    is?: WorkStationWhereInput
    isNot?: WorkStationWhereInput
  }

  export type EmployeeTaskCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    orderHeaderId?: SortOrder
    orderItemId?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    workStationId?: SortOrder
    status?: SortOrder
    itemQty?: SortOrder
    itemUnit?: SortOrder
    bypassReqNote?: SortOrder
    bypassReq?: SortOrder
    isReqAprooved?: SortOrder
    itemPassedNote?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeTaskAvgOrderByAggregateInput = {
    itemQty?: SortOrder
  }

  export type EmployeeTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    orderHeaderId?: SortOrder
    orderItemId?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    workStationId?: SortOrder
    status?: SortOrder
    itemQty?: SortOrder
    itemUnit?: SortOrder
    bypassReqNote?: SortOrder
    bypassReq?: SortOrder
    isReqAprooved?: SortOrder
    itemPassedNote?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeTaskMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    orderHeaderId?: SortOrder
    orderItemId?: SortOrder
    outletId?: SortOrder
    shiftId?: SortOrder
    workStationId?: SortOrder
    status?: SortOrder
    itemQty?: SortOrder
    itemUnit?: SortOrder
    bypassReqNote?: SortOrder
    bypassReq?: SortOrder
    isReqAprooved?: SortOrder
    itemPassedNote?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeTaskSumOrderByAggregateInput = {
    itemQty?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumPickupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PickupStatus | EnumPickupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PickupStatus[] | ListEnumPickupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PickupStatus[] | ListEnumPickupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPickupStatusFilter<$PrismaModel> | $Enums.PickupStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CustomerAddressScalarRelationFilter = {
    is?: CustomerAddressWhereInput
    isNot?: CustomerAddressWhereInput
  }

  export type OrderHeaderScalarRelationFilter = {
    is?: OrderHeaderWhereInput
    isNot?: OrderHeaderWhereInput
  }

  export type PickUpTaskCountOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PickUpTaskAvgOrderByAggregateInput = {
    distance?: SortOrder
    price?: SortOrder
  }

  export type PickUpTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PickUpTaskMinOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PickUpTaskSumOrderByAggregateInput = {
    distance?: SortOrder
    price?: SortOrder
  }

  export type EnumPickupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PickupStatus | EnumPickupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PickupStatus[] | ListEnumPickupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PickupStatus[] | ListEnumPickupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPickupStatusWithAggregatesFilter<$PrismaModel> | $Enums.PickupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPickupStatusFilter<$PrismaModel>
    _max?: NestedEnumPickupStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumDeilveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeilveryStatus | EnumDeilveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeilveryStatus[] | ListEnumDeilveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeilveryStatus[] | ListEnumDeilveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeilveryStatusFilter<$PrismaModel> | $Enums.DeilveryStatus
  }

  export type DeliveryTaskCountOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeliveryTaskAvgOrderByAggregateInput = {
    distance?: SortOrder
    price?: SortOrder
  }

  export type DeliveryTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeliveryTaskMinOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    outletId?: SortOrder
    customerAddressId?: SortOrder
    assignedByAdminId?: SortOrder
    orderHeaderId?: SortOrder
    status?: SortOrder
    distance?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeliveryTaskSumOrderByAggregateInput = {
    distance?: SortOrder
    price?: SortOrder
  }

  export type EnumDeilveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeilveryStatus | EnumDeilveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeilveryStatus[] | ListEnumDeilveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeilveryStatus[] | ListEnumDeilveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeilveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeilveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeilveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeilveryStatusFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrder
    clockOutAt?: SortOrder
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
    notes?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrder
    clockOutAt?: SortOrder
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
    notes?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    outletId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    clockInAt?: SortOrder
    clockOutAt?: SortOrder
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
    notes?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    workMinutes?: SortOrder
    lateMinutes?: SortOrder
    earlyLeaveMin?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type OutletScheduleListRelationFilter = {
    every?: OutletScheduleWhereInput
    some?: OutletScheduleWhereInput
    none?: OutletScheduleWhereInput
  }

  export type OutletScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutletCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
  }

  export type OutletMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    coverageArea?: SortOrder
  }

  export type OutletScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OutletScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    outletId?: SortOrder
    detailDays?: SortOrder
    openHour?: SortOrder
    closeHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceCategoryScalarRelationFilter = {
    is?: ServiceCategoryWhereInput
    isNot?: ServiceCategoryWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    serviceCategoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    etaHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    minQty?: SortOrder
    etaHours?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceCategoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    etaHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    serviceCategoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    basePrice?: SortOrder
    minQty?: SortOrder
    etaHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    basePrice?: SortOrder
    minQty?: SortOrder
    etaHours?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderHeaderCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    handledById?: SortOrder
    outletId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrder
    deliverAt?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderHeaderAvgOrderByAggregateInput = {
    estHours?: SortOrder
  }

  export type OrderHeaderMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    handledById?: SortOrder
    outletId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrder
    deliverAt?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderHeaderMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    handledById?: SortOrder
    outletId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    pickupAt?: SortOrder
    deliverAt?: SortOrder
    estHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderHeaderSumOrderByAggregateInput = {
    estHours?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    serviceId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderHeaderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    providerRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type CustomerAddressCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomersInput, CustomerAddressUncheckedCreateWithoutCustomersInput> | CustomerAddressCreateWithoutCustomersInput[] | CustomerAddressUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomersInput | CustomerAddressCreateOrConnectWithoutCustomersInput[]
    createMany?: CustomerAddressCreateManyCustomersInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type OrderHeaderCreateNestedManyWithoutCustomersInput = {
    create?: XOR<OrderHeaderCreateWithoutCustomersInput, OrderHeaderUncheckedCreateWithoutCustomersInput> | OrderHeaderCreateWithoutCustomersInput[] | OrderHeaderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutCustomersInput | OrderHeaderCreateOrConnectWithoutCustomersInput[]
    createMany?: OrderHeaderCreateManyCustomersInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type CustomerAddressUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomersInput, CustomerAddressUncheckedCreateWithoutCustomersInput> | CustomerAddressCreateWithoutCustomersInput[] | CustomerAddressUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomersInput | CustomerAddressCreateOrConnectWithoutCustomersInput[]
    createMany?: CustomerAddressCreateManyCustomersInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type OrderHeaderUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<OrderHeaderCreateWithoutCustomersInput, OrderHeaderUncheckedCreateWithoutCustomersInput> | OrderHeaderCreateWithoutCustomersInput[] | OrderHeaderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutCustomersInput | OrderHeaderCreateOrConnectWithoutCustomersInput[]
    createMany?: OrderHeaderCreateManyCustomersInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumOAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.OAuthProvider | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CustomerAddressUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomersInput, CustomerAddressUncheckedCreateWithoutCustomersInput> | CustomerAddressCreateWithoutCustomersInput[] | CustomerAddressUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomersInput | CustomerAddressCreateOrConnectWithoutCustomersInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomersInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CustomerAddressCreateManyCustomersInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomersInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomersInput | CustomerAddressUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type OrderHeaderUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutCustomersInput, OrderHeaderUncheckedCreateWithoutCustomersInput> | OrderHeaderCreateWithoutCustomersInput[] | OrderHeaderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutCustomersInput | OrderHeaderCreateOrConnectWithoutCustomersInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutCustomersInput | OrderHeaderUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: OrderHeaderCreateManyCustomersInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutCustomersInput | OrderHeaderUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutCustomersInput | OrderHeaderUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomersInput, CustomerAddressUncheckedCreateWithoutCustomersInput> | CustomerAddressCreateWithoutCustomersInput[] | CustomerAddressUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomersInput | CustomerAddressCreateOrConnectWithoutCustomersInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomersInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CustomerAddressCreateManyCustomersInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomersInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomersInput | CustomerAddressUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type OrderHeaderUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutCustomersInput, OrderHeaderUncheckedCreateWithoutCustomersInput> | OrderHeaderCreateWithoutCustomersInput[] | OrderHeaderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutCustomersInput | OrderHeaderCreateOrConnectWithoutCustomersInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutCustomersInput | OrderHeaderUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: OrderHeaderCreateManyCustomersInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutCustomersInput | OrderHeaderUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutCustomersInput | OrderHeaderUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutCustomerAddressInput = {
    create?: XOR<CustomerCreateWithoutCustomerAddressInput, CustomerUncheckedCreateWithoutCustomerAddressInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerAddressInput
    connect?: CustomerWhereUniqueInput
  }

  export type PickUpTaskCreateNestedManyWithoutCustomerAddressInput = {
    create?: XOR<PickUpTaskCreateWithoutCustomerAddressInput, PickUpTaskUncheckedCreateWithoutCustomerAddressInput> | PickUpTaskCreateWithoutCustomerAddressInput[] | PickUpTaskUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutCustomerAddressInput | PickUpTaskCreateOrConnectWithoutCustomerAddressInput[]
    createMany?: PickUpTaskCreateManyCustomerAddressInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type DeliveryTaskCreateNestedManyWithoutCustomerAddressInput = {
    create?: XOR<DeliveryTaskCreateWithoutCustomerAddressInput, DeliveryTaskUncheckedCreateWithoutCustomerAddressInput> | DeliveryTaskCreateWithoutCustomerAddressInput[] | DeliveryTaskUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutCustomerAddressInput | DeliveryTaskCreateOrConnectWithoutCustomerAddressInput[]
    createMany?: DeliveryTaskCreateManyCustomerAddressInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type PickUpTaskUncheckedCreateNestedManyWithoutCustomerAddressInput = {
    create?: XOR<PickUpTaskCreateWithoutCustomerAddressInput, PickUpTaskUncheckedCreateWithoutCustomerAddressInput> | PickUpTaskCreateWithoutCustomerAddressInput[] | PickUpTaskUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutCustomerAddressInput | PickUpTaskCreateOrConnectWithoutCustomerAddressInput[]
    createMany?: PickUpTaskCreateManyCustomerAddressInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type DeliveryTaskUncheckedCreateNestedManyWithoutCustomerAddressInput = {
    create?: XOR<DeliveryTaskCreateWithoutCustomerAddressInput, DeliveryTaskUncheckedCreateWithoutCustomerAddressInput> | DeliveryTaskCreateWithoutCustomerAddressInput[] | DeliveryTaskUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutCustomerAddressInput | DeliveryTaskCreateOrConnectWithoutCustomerAddressInput[]
    createMany?: DeliveryTaskCreateManyCustomerAddressInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type EnumLabelFieldUpdateOperationsInput = {
    set?: $Enums.Label
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutCustomerAddressNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerAddressInput, CustomerUncheckedCreateWithoutCustomerAddressInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerAddressInput
    upsert?: CustomerUpsertWithoutCustomerAddressInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerAddressInput, CustomerUpdateWithoutCustomerAddressInput>, CustomerUncheckedUpdateWithoutCustomerAddressInput>
  }

  export type PickUpTaskUpdateManyWithoutCustomerAddressNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutCustomerAddressInput, PickUpTaskUncheckedCreateWithoutCustomerAddressInput> | PickUpTaskCreateWithoutCustomerAddressInput[] | PickUpTaskUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutCustomerAddressInput | PickUpTaskCreateOrConnectWithoutCustomerAddressInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutCustomerAddressInput | PickUpTaskUpsertWithWhereUniqueWithoutCustomerAddressInput[]
    createMany?: PickUpTaskCreateManyCustomerAddressInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutCustomerAddressInput | PickUpTaskUpdateWithWhereUniqueWithoutCustomerAddressInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutCustomerAddressInput | PickUpTaskUpdateManyWithWhereWithoutCustomerAddressInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type DeliveryTaskUpdateManyWithoutCustomerAddressNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutCustomerAddressInput, DeliveryTaskUncheckedCreateWithoutCustomerAddressInput> | DeliveryTaskCreateWithoutCustomerAddressInput[] | DeliveryTaskUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutCustomerAddressInput | DeliveryTaskCreateOrConnectWithoutCustomerAddressInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutCustomerAddressInput | DeliveryTaskUpsertWithWhereUniqueWithoutCustomerAddressInput[]
    createMany?: DeliveryTaskCreateManyCustomerAddressInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutCustomerAddressInput | DeliveryTaskUpdateWithWhereUniqueWithoutCustomerAddressInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutCustomerAddressInput | DeliveryTaskUpdateManyWithWhereWithoutCustomerAddressInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type PickUpTaskUncheckedUpdateManyWithoutCustomerAddressNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutCustomerAddressInput, PickUpTaskUncheckedCreateWithoutCustomerAddressInput> | PickUpTaskCreateWithoutCustomerAddressInput[] | PickUpTaskUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutCustomerAddressInput | PickUpTaskCreateOrConnectWithoutCustomerAddressInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutCustomerAddressInput | PickUpTaskUpsertWithWhereUniqueWithoutCustomerAddressInput[]
    createMany?: PickUpTaskCreateManyCustomerAddressInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutCustomerAddressInput | PickUpTaskUpdateWithWhereUniqueWithoutCustomerAddressInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutCustomerAddressInput | PickUpTaskUpdateManyWithWhereWithoutCustomerAddressInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutCustomerAddressNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutCustomerAddressInput, DeliveryTaskUncheckedCreateWithoutCustomerAddressInput> | DeliveryTaskCreateWithoutCustomerAddressInput[] | DeliveryTaskUncheckedCreateWithoutCustomerAddressInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutCustomerAddressInput | DeliveryTaskCreateOrConnectWithoutCustomerAddressInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutCustomerAddressInput | DeliveryTaskUpsertWithWhereUniqueWithoutCustomerAddressInput[]
    createMany?: DeliveryTaskCreateManyCustomerAddressInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutCustomerAddressInput | DeliveryTaskUpdateWithWhereUniqueWithoutCustomerAddressInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutCustomerAddressInput | DeliveryTaskUpdateManyWithWhereWithoutCustomerAddressInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type ShiftCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput
    connect?: ShiftWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<OutletCreateWithoutEmployeeInput, OutletUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: OutletCreateOrConnectWithoutEmployeeInput
    connect?: OutletWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<AttendanceCreateWithoutEmployeesInput, AttendanceUncheckedCreateWithoutEmployeesInput> | AttendanceCreateWithoutEmployeesInput[] | AttendanceUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeesInput | AttendanceCreateOrConnectWithoutEmployeesInput[]
    createMany?: AttendanceCreateManyEmployeesInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type OrderHeaderCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<OrderHeaderCreateWithoutEmployeesInput, OrderHeaderUncheckedCreateWithoutEmployeesInput> | OrderHeaderCreateWithoutEmployeesInput[] | OrderHeaderUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutEmployeesInput | OrderHeaderCreateOrConnectWithoutEmployeesInput[]
    createMany?: OrderHeaderCreateManyEmployeesInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type WorkStationCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<WorkStationCreateWithoutEmployeesInput, WorkStationUncheckedCreateWithoutEmployeesInput> | WorkStationCreateWithoutEmployeesInput[] | WorkStationUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: WorkStationCreateOrConnectWithoutEmployeesInput | WorkStationCreateOrConnectWithoutEmployeesInput[]
    createMany?: WorkStationCreateManyEmployeesInputEnvelope
    connect?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
  }

  export type EmployeeTaskCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeTaskCreateWithoutEmployeeInput, EmployeeTaskUncheckedCreateWithoutEmployeeInput> | EmployeeTaskCreateWithoutEmployeeInput[] | EmployeeTaskUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutEmployeeInput | EmployeeTaskCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeTaskCreateManyEmployeeInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EmployeeTaskCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput> | EmployeeTaskCreateWithoutAssignedByInput[] | EmployeeTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssignedByInput | EmployeeTaskCreateOrConnectWithoutAssignedByInput[]
    createMany?: EmployeeTaskCreateManyAssignedByInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput> | AttendanceCreateWithoutApprovedByInput[] | AttendanceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutApprovedByInput | AttendanceCreateOrConnectWithoutApprovedByInput[]
    createMany?: AttendanceCreateManyApprovedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type PickUpTaskCreateNestedManyWithoutDriverInput = {
    create?: XOR<PickUpTaskCreateWithoutDriverInput, PickUpTaskUncheckedCreateWithoutDriverInput> | PickUpTaskCreateWithoutDriverInput[] | PickUpTaskUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutDriverInput | PickUpTaskCreateOrConnectWithoutDriverInput[]
    createMany?: PickUpTaskCreateManyDriverInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type PickUpTaskCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<PickUpTaskCreateWithoutAssignedByInput, PickUpTaskUncheckedCreateWithoutAssignedByInput> | PickUpTaskCreateWithoutAssignedByInput[] | PickUpTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutAssignedByInput | PickUpTaskCreateOrConnectWithoutAssignedByInput[]
    createMany?: PickUpTaskCreateManyAssignedByInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type DeliveryTaskCreateNestedManyWithoutDriverInput = {
    create?: XOR<DeliveryTaskCreateWithoutDriverInput, DeliveryTaskUncheckedCreateWithoutDriverInput> | DeliveryTaskCreateWithoutDriverInput[] | DeliveryTaskUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutDriverInput | DeliveryTaskCreateOrConnectWithoutDriverInput[]
    createMany?: DeliveryTaskCreateManyDriverInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type DeliveryTaskCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<DeliveryTaskCreateWithoutAssignedByInput, DeliveryTaskUncheckedCreateWithoutAssignedByInput> | DeliveryTaskCreateWithoutAssignedByInput[] | DeliveryTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutAssignedByInput | DeliveryTaskCreateOrConnectWithoutAssignedByInput[]
    createMany?: DeliveryTaskCreateManyAssignedByInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<AttendanceCreateWithoutEmployeesInput, AttendanceUncheckedCreateWithoutEmployeesInput> | AttendanceCreateWithoutEmployeesInput[] | AttendanceUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeesInput | AttendanceCreateOrConnectWithoutEmployeesInput[]
    createMany?: AttendanceCreateManyEmployeesInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<OrderHeaderCreateWithoutEmployeesInput, OrderHeaderUncheckedCreateWithoutEmployeesInput> | OrderHeaderCreateWithoutEmployeesInput[] | OrderHeaderUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutEmployeesInput | OrderHeaderCreateOrConnectWithoutEmployeesInput[]
    createMany?: OrderHeaderCreateManyEmployeesInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type WorkStationUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<WorkStationCreateWithoutEmployeesInput, WorkStationUncheckedCreateWithoutEmployeesInput> | WorkStationCreateWithoutEmployeesInput[] | WorkStationUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: WorkStationCreateOrConnectWithoutEmployeesInput | WorkStationCreateOrConnectWithoutEmployeesInput[]
    createMany?: WorkStationCreateManyEmployeesInputEnvelope
    connect?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeTaskCreateWithoutEmployeeInput, EmployeeTaskUncheckedCreateWithoutEmployeeInput> | EmployeeTaskCreateWithoutEmployeeInput[] | EmployeeTaskUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutEmployeeInput | EmployeeTaskCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeTaskCreateManyEmployeeInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput> | EmployeeTaskCreateWithoutAssignedByInput[] | EmployeeTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssignedByInput | EmployeeTaskCreateOrConnectWithoutAssignedByInput[]
    createMany?: EmployeeTaskCreateManyAssignedByInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput> | AttendanceCreateWithoutApprovedByInput[] | AttendanceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutApprovedByInput | AttendanceCreateOrConnectWithoutApprovedByInput[]
    createMany?: AttendanceCreateManyApprovedByInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type PickUpTaskUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<PickUpTaskCreateWithoutDriverInput, PickUpTaskUncheckedCreateWithoutDriverInput> | PickUpTaskCreateWithoutDriverInput[] | PickUpTaskUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutDriverInput | PickUpTaskCreateOrConnectWithoutDriverInput[]
    createMany?: PickUpTaskCreateManyDriverInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<PickUpTaskCreateWithoutAssignedByInput, PickUpTaskUncheckedCreateWithoutAssignedByInput> | PickUpTaskCreateWithoutAssignedByInput[] | PickUpTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutAssignedByInput | PickUpTaskCreateOrConnectWithoutAssignedByInput[]
    createMany?: PickUpTaskCreateManyAssignedByInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<DeliveryTaskCreateWithoutDriverInput, DeliveryTaskUncheckedCreateWithoutDriverInput> | DeliveryTaskCreateWithoutDriverInput[] | DeliveryTaskUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutDriverInput | DeliveryTaskCreateOrConnectWithoutDriverInput[]
    createMany?: DeliveryTaskCreateManyDriverInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<DeliveryTaskCreateWithoutAssignedByInput, DeliveryTaskUncheckedCreateWithoutAssignedByInput> | DeliveryTaskCreateWithoutAssignedByInput[] | DeliveryTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutAssignedByInput | DeliveryTaskCreateOrConnectWithoutAssignedByInput[]
    createMany?: DeliveryTaskCreateManyAssignedByInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type ShiftUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput
    upsert?: ShiftUpsertWithoutEmployeeInput
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutEmployeeInput, ShiftUpdateWithoutEmployeeInput>, ShiftUncheckedUpdateWithoutEmployeeInput>
  }

  export type OutletUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<OutletCreateWithoutEmployeeInput, OutletUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: OutletCreateOrConnectWithoutEmployeeInput
    upsert?: OutletUpsertWithoutEmployeeInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutEmployeeInput, OutletUpdateWithoutEmployeeInput>, OutletUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeesInput, AttendanceUncheckedCreateWithoutEmployeesInput> | AttendanceCreateWithoutEmployeesInput[] | AttendanceUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeesInput | AttendanceCreateOrConnectWithoutEmployeesInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeesInput | AttendanceUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: AttendanceCreateManyEmployeesInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeesInput | AttendanceUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeesInput | AttendanceUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type OrderHeaderUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutEmployeesInput, OrderHeaderUncheckedCreateWithoutEmployeesInput> | OrderHeaderCreateWithoutEmployeesInput[] | OrderHeaderUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutEmployeesInput | OrderHeaderCreateOrConnectWithoutEmployeesInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutEmployeesInput | OrderHeaderUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: OrderHeaderCreateManyEmployeesInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutEmployeesInput | OrderHeaderUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutEmployeesInput | OrderHeaderUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type WorkStationUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<WorkStationCreateWithoutEmployeesInput, WorkStationUncheckedCreateWithoutEmployeesInput> | WorkStationCreateWithoutEmployeesInput[] | WorkStationUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: WorkStationCreateOrConnectWithoutEmployeesInput | WorkStationCreateOrConnectWithoutEmployeesInput[]
    upsert?: WorkStationUpsertWithWhereUniqueWithoutEmployeesInput | WorkStationUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: WorkStationCreateManyEmployeesInputEnvelope
    set?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
    disconnect?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
    delete?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
    connect?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
    update?: WorkStationUpdateWithWhereUniqueWithoutEmployeesInput | WorkStationUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: WorkStationUpdateManyWithWhereWithoutEmployeesInput | WorkStationUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: WorkStationScalarWhereInput | WorkStationScalarWhereInput[]
  }

  export type EmployeeTaskUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutEmployeeInput, EmployeeTaskUncheckedCreateWithoutEmployeeInput> | EmployeeTaskCreateWithoutEmployeeInput[] | EmployeeTaskUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutEmployeeInput | EmployeeTaskCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeTaskUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeTaskCreateManyEmployeeInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeTaskUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutEmployeeInput | EmployeeTaskUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeTaskUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput> | EmployeeTaskCreateWithoutAssignedByInput[] | EmployeeTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssignedByInput | EmployeeTaskCreateOrConnectWithoutAssignedByInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput | EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: EmployeeTaskCreateManyAssignedByInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput | EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput | EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput> | AttendanceCreateWithoutApprovedByInput[] | AttendanceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutApprovedByInput | AttendanceCreateOrConnectWithoutApprovedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutApprovedByInput | AttendanceUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: AttendanceCreateManyApprovedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutApprovedByInput | AttendanceUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutApprovedByInput | AttendanceUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type PickUpTaskUpdateManyWithoutDriverNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutDriverInput, PickUpTaskUncheckedCreateWithoutDriverInput> | PickUpTaskCreateWithoutDriverInput[] | PickUpTaskUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutDriverInput | PickUpTaskCreateOrConnectWithoutDriverInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutDriverInput | PickUpTaskUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: PickUpTaskCreateManyDriverInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutDriverInput | PickUpTaskUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutDriverInput | PickUpTaskUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type PickUpTaskUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutAssignedByInput, PickUpTaskUncheckedCreateWithoutAssignedByInput> | PickUpTaskCreateWithoutAssignedByInput[] | PickUpTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutAssignedByInput | PickUpTaskCreateOrConnectWithoutAssignedByInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutAssignedByInput | PickUpTaskUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: PickUpTaskCreateManyAssignedByInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutAssignedByInput | PickUpTaskUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutAssignedByInput | PickUpTaskUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type DeliveryTaskUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutDriverInput, DeliveryTaskUncheckedCreateWithoutDriverInput> | DeliveryTaskCreateWithoutDriverInput[] | DeliveryTaskUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutDriverInput | DeliveryTaskCreateOrConnectWithoutDriverInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutDriverInput | DeliveryTaskUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DeliveryTaskCreateManyDriverInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutDriverInput | DeliveryTaskUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutDriverInput | DeliveryTaskUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type DeliveryTaskUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutAssignedByInput, DeliveryTaskUncheckedCreateWithoutAssignedByInput> | DeliveryTaskCreateWithoutAssignedByInput[] | DeliveryTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutAssignedByInput | DeliveryTaskCreateOrConnectWithoutAssignedByInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutAssignedByInput | DeliveryTaskUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: DeliveryTaskCreateManyAssignedByInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutAssignedByInput | DeliveryTaskUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutAssignedByInput | DeliveryTaskUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeesInput, AttendanceUncheckedCreateWithoutEmployeesInput> | AttendanceCreateWithoutEmployeesInput[] | AttendanceUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeesInput | AttendanceCreateOrConnectWithoutEmployeesInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeesInput | AttendanceUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: AttendanceCreateManyEmployeesInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeesInput | AttendanceUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeesInput | AttendanceUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutEmployeesInput, OrderHeaderUncheckedCreateWithoutEmployeesInput> | OrderHeaderCreateWithoutEmployeesInput[] | OrderHeaderUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutEmployeesInput | OrderHeaderCreateOrConnectWithoutEmployeesInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutEmployeesInput | OrderHeaderUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: OrderHeaderCreateManyEmployeesInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutEmployeesInput | OrderHeaderUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutEmployeesInput | OrderHeaderUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<WorkStationCreateWithoutEmployeesInput, WorkStationUncheckedCreateWithoutEmployeesInput> | WorkStationCreateWithoutEmployeesInput[] | WorkStationUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: WorkStationCreateOrConnectWithoutEmployeesInput | WorkStationCreateOrConnectWithoutEmployeesInput[]
    upsert?: WorkStationUpsertWithWhereUniqueWithoutEmployeesInput | WorkStationUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: WorkStationCreateManyEmployeesInputEnvelope
    set?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
    disconnect?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
    delete?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
    connect?: WorkStationWhereUniqueInput | WorkStationWhereUniqueInput[]
    update?: WorkStationUpdateWithWhereUniqueWithoutEmployeesInput | WorkStationUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: WorkStationUpdateManyWithWhereWithoutEmployeesInput | WorkStationUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: WorkStationScalarWhereInput | WorkStationScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutEmployeeInput, EmployeeTaskUncheckedCreateWithoutEmployeeInput> | EmployeeTaskCreateWithoutEmployeeInput[] | EmployeeTaskUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutEmployeeInput | EmployeeTaskCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeTaskUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeTaskCreateManyEmployeeInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeTaskUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutEmployeeInput | EmployeeTaskUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput> | EmployeeTaskCreateWithoutAssignedByInput[] | EmployeeTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutAssignedByInput | EmployeeTaskCreateOrConnectWithoutAssignedByInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput | EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: EmployeeTaskCreateManyAssignedByInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput | EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput | EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput> | AttendanceCreateWithoutApprovedByInput[] | AttendanceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutApprovedByInput | AttendanceCreateOrConnectWithoutApprovedByInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutApprovedByInput | AttendanceUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: AttendanceCreateManyApprovedByInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutApprovedByInput | AttendanceUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutApprovedByInput | AttendanceUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutDriverInput, PickUpTaskUncheckedCreateWithoutDriverInput> | PickUpTaskCreateWithoutDriverInput[] | PickUpTaskUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutDriverInput | PickUpTaskCreateOrConnectWithoutDriverInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutDriverInput | PickUpTaskUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: PickUpTaskCreateManyDriverInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutDriverInput | PickUpTaskUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutDriverInput | PickUpTaskUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutAssignedByInput, PickUpTaskUncheckedCreateWithoutAssignedByInput> | PickUpTaskCreateWithoutAssignedByInput[] | PickUpTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutAssignedByInput | PickUpTaskCreateOrConnectWithoutAssignedByInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutAssignedByInput | PickUpTaskUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: PickUpTaskCreateManyAssignedByInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutAssignedByInput | PickUpTaskUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutAssignedByInput | PickUpTaskUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutDriverInput, DeliveryTaskUncheckedCreateWithoutDriverInput> | DeliveryTaskCreateWithoutDriverInput[] | DeliveryTaskUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutDriverInput | DeliveryTaskCreateOrConnectWithoutDriverInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutDriverInput | DeliveryTaskUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DeliveryTaskCreateManyDriverInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutDriverInput | DeliveryTaskUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutDriverInput | DeliveryTaskUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutAssignedByInput, DeliveryTaskUncheckedCreateWithoutAssignedByInput> | DeliveryTaskCreateWithoutAssignedByInput[] | DeliveryTaskUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutAssignedByInput | DeliveryTaskCreateOrConnectWithoutAssignedByInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutAssignedByInput | DeliveryTaskUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: DeliveryTaskCreateManyAssignedByInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutAssignedByInput | DeliveryTaskUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutAssignedByInput | DeliveryTaskUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutShiftsInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput> | EmployeeCreateWithoutShiftsInput[] | EmployeeUncheckedCreateWithoutShiftsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput | EmployeeCreateOrConnectWithoutShiftsInput[]
    createMany?: EmployeeCreateManyShiftsInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutShiftInput = {
    create?: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput> | AttendanceCreateWithoutShiftInput[] | AttendanceUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutShiftInput | AttendanceCreateOrConnectWithoutShiftInput[]
    createMany?: AttendanceCreateManyShiftInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EmployeeTaskCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeTaskCreateWithoutShiftInput, EmployeeTaskUncheckedCreateWithoutShiftInput> | EmployeeTaskCreateWithoutShiftInput[] | EmployeeTaskUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutShiftInput | EmployeeTaskCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeTaskCreateManyShiftInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutShiftsInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput> | EmployeeCreateWithoutShiftsInput[] | EmployeeUncheckedCreateWithoutShiftsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput | EmployeeCreateOrConnectWithoutShiftsInput[]
    createMany?: EmployeeCreateManyShiftsInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput> | AttendanceCreateWithoutShiftInput[] | AttendanceUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutShiftInput | AttendanceCreateOrConnectWithoutShiftInput[]
    createMany?: AttendanceCreateManyShiftInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeTaskCreateWithoutShiftInput, EmployeeTaskUncheckedCreateWithoutShiftInput> | EmployeeTaskCreateWithoutShiftInput[] | EmployeeTaskUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutShiftInput | EmployeeTaskCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeTaskCreateManyShiftInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutShiftsNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput> | EmployeeCreateWithoutShiftsInput[] | EmployeeUncheckedCreateWithoutShiftsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput | EmployeeCreateOrConnectWithoutShiftsInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShiftsInput | EmployeeUpsertWithWhereUniqueWithoutShiftsInput[]
    createMany?: EmployeeCreateManyShiftsInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShiftsInput | EmployeeUpdateWithWhereUniqueWithoutShiftsInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShiftsInput | EmployeeUpdateManyWithWhereWithoutShiftsInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutShiftNestedInput = {
    create?: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput> | AttendanceCreateWithoutShiftInput[] | AttendanceUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutShiftInput | AttendanceCreateOrConnectWithoutShiftInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutShiftInput | AttendanceUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: AttendanceCreateManyShiftInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutShiftInput | AttendanceUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutShiftInput | AttendanceUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EmployeeTaskUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutShiftInput, EmployeeTaskUncheckedCreateWithoutShiftInput> | EmployeeTaskCreateWithoutShiftInput[] | EmployeeTaskUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutShiftInput | EmployeeTaskCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutShiftInput | EmployeeTaskUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeTaskCreateManyShiftInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutShiftInput | EmployeeTaskUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutShiftInput | EmployeeTaskUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutShiftsNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput> | EmployeeCreateWithoutShiftsInput[] | EmployeeUncheckedCreateWithoutShiftsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput | EmployeeCreateOrConnectWithoutShiftsInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShiftsInput | EmployeeUpsertWithWhereUniqueWithoutShiftsInput[]
    createMany?: EmployeeCreateManyShiftsInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShiftsInput | EmployeeUpdateWithWhereUniqueWithoutShiftsInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShiftsInput | EmployeeUpdateManyWithWhereWithoutShiftsInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput> | AttendanceCreateWithoutShiftInput[] | AttendanceUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutShiftInput | AttendanceCreateOrConnectWithoutShiftInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutShiftInput | AttendanceUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: AttendanceCreateManyShiftInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutShiftInput | AttendanceUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutShiftInput | AttendanceUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutShiftInput, EmployeeTaskUncheckedCreateWithoutShiftInput> | EmployeeTaskCreateWithoutShiftInput[] | EmployeeTaskUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutShiftInput | EmployeeTaskCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutShiftInput | EmployeeTaskUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeTaskCreateManyShiftInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutShiftInput | EmployeeTaskUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutShiftInput | EmployeeTaskUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutWorkStationInput = {
    create?: XOR<EmployeeCreateWithoutWorkStationInput, EmployeeUncheckedCreateWithoutWorkStationInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkStationInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeTaskCreateNestedManyWithoutWorkStationInput = {
    create?: XOR<EmployeeTaskCreateWithoutWorkStationInput, EmployeeTaskUncheckedCreateWithoutWorkStationInput> | EmployeeTaskCreateWithoutWorkStationInput[] | EmployeeTaskUncheckedCreateWithoutWorkStationInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutWorkStationInput | EmployeeTaskCreateOrConnectWithoutWorkStationInput[]
    createMany?: EmployeeTaskCreateManyWorkStationInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutWorkStationInput = {
    create?: XOR<EmployeeTaskCreateWithoutWorkStationInput, EmployeeTaskUncheckedCreateWithoutWorkStationInput> | EmployeeTaskCreateWithoutWorkStationInput[] | EmployeeTaskUncheckedCreateWithoutWorkStationInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutWorkStationInput | EmployeeTaskCreateOrConnectWithoutWorkStationInput[]
    createMany?: EmployeeTaskCreateManyWorkStationInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EnumStationFieldUpdateOperationsInput = {
    set?: $Enums.Station
  }

  export type EmployeeUpdateOneRequiredWithoutWorkStationNestedInput = {
    create?: XOR<EmployeeCreateWithoutWorkStationInput, EmployeeUncheckedCreateWithoutWorkStationInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkStationInput
    upsert?: EmployeeUpsertWithoutWorkStationInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWorkStationInput, EmployeeUpdateWithoutWorkStationInput>, EmployeeUncheckedUpdateWithoutWorkStationInput>
  }

  export type EmployeeTaskUpdateManyWithoutWorkStationNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutWorkStationInput, EmployeeTaskUncheckedCreateWithoutWorkStationInput> | EmployeeTaskCreateWithoutWorkStationInput[] | EmployeeTaskUncheckedCreateWithoutWorkStationInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutWorkStationInput | EmployeeTaskCreateOrConnectWithoutWorkStationInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutWorkStationInput | EmployeeTaskUpsertWithWhereUniqueWithoutWorkStationInput[]
    createMany?: EmployeeTaskCreateManyWorkStationInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutWorkStationInput | EmployeeTaskUpdateWithWhereUniqueWithoutWorkStationInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutWorkStationInput | EmployeeTaskUpdateManyWithWhereWithoutWorkStationInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutWorkStationNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutWorkStationInput, EmployeeTaskUncheckedCreateWithoutWorkStationInput> | EmployeeTaskCreateWithoutWorkStationInput[] | EmployeeTaskUncheckedCreateWithoutWorkStationInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutWorkStationInput | EmployeeTaskCreateOrConnectWithoutWorkStationInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutWorkStationInput | EmployeeTaskUpsertWithWhereUniqueWithoutWorkStationInput[]
    createMany?: EmployeeTaskCreateManyWorkStationInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutWorkStationInput | EmployeeTaskUpdateWithWhereUniqueWithoutWorkStationInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutWorkStationInput | EmployeeTaskUpdateManyWithWhereWithoutWorkStationInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutWorkerTasksInput = {
    create?: XOR<EmployeeCreateWithoutWorkerTasksInput, EmployeeUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkerTasksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<EmployeeCreateWithoutAssignedTasksInput, EmployeeUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAssignedTasksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OrderHeaderCreateNestedOneWithoutWorkerTasksInput = {
    create?: XOR<OrderHeaderCreateWithoutWorkerTasksInput, OrderHeaderUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutWorkerTasksInput
    connect?: OrderHeaderWhereUniqueInput
  }

  export type OrderItemCreateNestedOneWithoutWorkerTasksInput = {
    create?: XOR<OrderItemCreateWithoutWorkerTasksInput, OrderItemUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutWorkerTasksInput
    connect?: OrderItemWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutWorkerTasksInput = {
    create?: XOR<OutletCreateWithoutWorkerTasksInput, OutletUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: OutletCreateOrConnectWithoutWorkerTasksInput
    connect?: OutletWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutWorkerTasksInput = {
    create?: XOR<ShiftCreateWithoutWorkerTasksInput, ShiftUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutWorkerTasksInput
    connect?: ShiftWhereUniqueInput
  }

  export type WorkStationCreateNestedOneWithoutWorkerTasksInput = {
    create?: XOR<WorkStationCreateWithoutWorkerTasksInput, WorkStationUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: WorkStationCreateOrConnectWithoutWorkerTasksInput
    connect?: WorkStationWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EmployeeUpdateOneRequiredWithoutWorkerTasksNestedInput = {
    create?: XOR<EmployeeCreateWithoutWorkerTasksInput, EmployeeUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkerTasksInput
    upsert?: EmployeeUpsertWithoutWorkerTasksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWorkerTasksInput, EmployeeUpdateWithoutWorkerTasksInput>, EmployeeUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type EmployeeUpdateOneWithoutAssignedTasksNestedInput = {
    create?: XOR<EmployeeCreateWithoutAssignedTasksInput, EmployeeUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAssignedTasksInput
    upsert?: EmployeeUpsertWithoutAssignedTasksInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAssignedTasksInput, EmployeeUpdateWithoutAssignedTasksInput>, EmployeeUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type OrderHeaderUpdateOneWithoutWorkerTasksNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutWorkerTasksInput, OrderHeaderUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutWorkerTasksInput
    upsert?: OrderHeaderUpsertWithoutWorkerTasksInput
    disconnect?: OrderHeaderWhereInput | boolean
    delete?: OrderHeaderWhereInput | boolean
    connect?: OrderHeaderWhereUniqueInput
    update?: XOR<XOR<OrderHeaderUpdateToOneWithWhereWithoutWorkerTasksInput, OrderHeaderUpdateWithoutWorkerTasksInput>, OrderHeaderUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type OrderItemUpdateOneWithoutWorkerTasksNestedInput = {
    create?: XOR<OrderItemCreateWithoutWorkerTasksInput, OrderItemUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutWorkerTasksInput
    upsert?: OrderItemUpsertWithoutWorkerTasksInput
    disconnect?: OrderItemWhereInput | boolean
    delete?: OrderItemWhereInput | boolean
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutWorkerTasksInput, OrderItemUpdateWithoutWorkerTasksInput>, OrderItemUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type OutletUpdateOneRequiredWithoutWorkerTasksNestedInput = {
    create?: XOR<OutletCreateWithoutWorkerTasksInput, OutletUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: OutletCreateOrConnectWithoutWorkerTasksInput
    upsert?: OutletUpsertWithoutWorkerTasksInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutWorkerTasksInput, OutletUpdateWithoutWorkerTasksInput>, OutletUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type ShiftUpdateOneRequiredWithoutWorkerTasksNestedInput = {
    create?: XOR<ShiftCreateWithoutWorkerTasksInput, ShiftUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutWorkerTasksInput
    upsert?: ShiftUpsertWithoutWorkerTasksInput
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutWorkerTasksInput, ShiftUpdateWithoutWorkerTasksInput>, ShiftUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type WorkStationUpdateOneRequiredWithoutWorkerTasksNestedInput = {
    create?: XOR<WorkStationCreateWithoutWorkerTasksInput, WorkStationUncheckedCreateWithoutWorkerTasksInput>
    connectOrCreate?: WorkStationCreateOrConnectWithoutWorkerTasksInput
    upsert?: WorkStationUpsertWithoutWorkerTasksInput
    connect?: WorkStationWhereUniqueInput
    update?: XOR<XOR<WorkStationUpdateToOneWithWhereWithoutWorkerTasksInput, WorkStationUpdateWithoutWorkerTasksInput>, WorkStationUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type EmployeeCreateNestedOneWithoutPickUpDriverInput = {
    create?: XOR<EmployeeCreateWithoutPickUpDriverInput, EmployeeUncheckedCreateWithoutPickUpDriverInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPickUpDriverInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPickupAssignedByInput = {
    create?: XOR<EmployeeCreateWithoutPickupAssignedByInput, EmployeeUncheckedCreateWithoutPickupAssignedByInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPickupAssignedByInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutPickUpTaskInput = {
    create?: XOR<OutletCreateWithoutPickUpTaskInput, OutletUncheckedCreateWithoutPickUpTaskInput>
    connectOrCreate?: OutletCreateOrConnectWithoutPickUpTaskInput
    connect?: OutletWhereUniqueInput
  }

  export type CustomerAddressCreateNestedOneWithoutPickUpTaskInput = {
    create?: XOR<CustomerAddressCreateWithoutPickUpTaskInput, CustomerAddressUncheckedCreateWithoutPickUpTaskInput>
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutPickUpTaskInput
    connect?: CustomerAddressWhereUniqueInput
  }

  export type OrderHeaderCreateNestedOneWithoutPickUpTaskInput = {
    create?: XOR<OrderHeaderCreateWithoutPickUpTaskInput, OrderHeaderUncheckedCreateWithoutPickUpTaskInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutPickUpTaskInput
    connect?: OrderHeaderWhereUniqueInput
  }

  export type EnumPickupStatusFieldUpdateOperationsInput = {
    set?: $Enums.PickupStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateOneRequiredWithoutPickUpDriverNestedInput = {
    create?: XOR<EmployeeCreateWithoutPickUpDriverInput, EmployeeUncheckedCreateWithoutPickUpDriverInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPickUpDriverInput
    upsert?: EmployeeUpsertWithoutPickUpDriverInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPickUpDriverInput, EmployeeUpdateWithoutPickUpDriverInput>, EmployeeUncheckedUpdateWithoutPickUpDriverInput>
  }

  export type EmployeeUpdateOneWithoutPickupAssignedByNestedInput = {
    create?: XOR<EmployeeCreateWithoutPickupAssignedByInput, EmployeeUncheckedCreateWithoutPickupAssignedByInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPickupAssignedByInput
    upsert?: EmployeeUpsertWithoutPickupAssignedByInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPickupAssignedByInput, EmployeeUpdateWithoutPickupAssignedByInput>, EmployeeUncheckedUpdateWithoutPickupAssignedByInput>
  }

  export type OutletUpdateOneRequiredWithoutPickUpTaskNestedInput = {
    create?: XOR<OutletCreateWithoutPickUpTaskInput, OutletUncheckedCreateWithoutPickUpTaskInput>
    connectOrCreate?: OutletCreateOrConnectWithoutPickUpTaskInput
    upsert?: OutletUpsertWithoutPickUpTaskInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutPickUpTaskInput, OutletUpdateWithoutPickUpTaskInput>, OutletUncheckedUpdateWithoutPickUpTaskInput>
  }

  export type CustomerAddressUpdateOneRequiredWithoutPickUpTaskNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutPickUpTaskInput, CustomerAddressUncheckedCreateWithoutPickUpTaskInput>
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutPickUpTaskInput
    upsert?: CustomerAddressUpsertWithoutPickUpTaskInput
    connect?: CustomerAddressWhereUniqueInput
    update?: XOR<XOR<CustomerAddressUpdateToOneWithWhereWithoutPickUpTaskInput, CustomerAddressUpdateWithoutPickUpTaskInput>, CustomerAddressUncheckedUpdateWithoutPickUpTaskInput>
  }

  export type OrderHeaderUpdateOneRequiredWithoutPickUpTaskNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutPickUpTaskInput, OrderHeaderUncheckedCreateWithoutPickUpTaskInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutPickUpTaskInput
    upsert?: OrderHeaderUpsertWithoutPickUpTaskInput
    connect?: OrderHeaderWhereUniqueInput
    update?: XOR<XOR<OrderHeaderUpdateToOneWithWhereWithoutPickUpTaskInput, OrderHeaderUpdateWithoutPickUpTaskInput>, OrderHeaderUncheckedUpdateWithoutPickUpTaskInput>
  }

  export type EmployeeCreateNestedOneWithoutDeliveryDriverInput = {
    create?: XOR<EmployeeCreateWithoutDeliveryDriverInput, EmployeeUncheckedCreateWithoutDeliveryDriverInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDeliveryDriverInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutDeliveryAssignedByInput = {
    create?: XOR<EmployeeCreateWithoutDeliveryAssignedByInput, EmployeeUncheckedCreateWithoutDeliveryAssignedByInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDeliveryAssignedByInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutDeliveryTaskInput = {
    create?: XOR<OutletCreateWithoutDeliveryTaskInput, OutletUncheckedCreateWithoutDeliveryTaskInput>
    connectOrCreate?: OutletCreateOrConnectWithoutDeliveryTaskInput
    connect?: OutletWhereUniqueInput
  }

  export type CustomerAddressCreateNestedOneWithoutDeliveryTaskInput = {
    create?: XOR<CustomerAddressCreateWithoutDeliveryTaskInput, CustomerAddressUncheckedCreateWithoutDeliveryTaskInput>
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutDeliveryTaskInput
    connect?: CustomerAddressWhereUniqueInput
  }

  export type OrderHeaderCreateNestedOneWithoutDeliveryTaskInput = {
    create?: XOR<OrderHeaderCreateWithoutDeliveryTaskInput, OrderHeaderUncheckedCreateWithoutDeliveryTaskInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutDeliveryTaskInput
    connect?: OrderHeaderWhereUniqueInput
  }

  export type EnumDeilveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeilveryStatus
  }

  export type EmployeeUpdateOneRequiredWithoutDeliveryDriverNestedInput = {
    create?: XOR<EmployeeCreateWithoutDeliveryDriverInput, EmployeeUncheckedCreateWithoutDeliveryDriverInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDeliveryDriverInput
    upsert?: EmployeeUpsertWithoutDeliveryDriverInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDeliveryDriverInput, EmployeeUpdateWithoutDeliveryDriverInput>, EmployeeUncheckedUpdateWithoutDeliveryDriverInput>
  }

  export type EmployeeUpdateOneWithoutDeliveryAssignedByNestedInput = {
    create?: XOR<EmployeeCreateWithoutDeliveryAssignedByInput, EmployeeUncheckedCreateWithoutDeliveryAssignedByInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDeliveryAssignedByInput
    upsert?: EmployeeUpsertWithoutDeliveryAssignedByInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDeliveryAssignedByInput, EmployeeUpdateWithoutDeliveryAssignedByInput>, EmployeeUncheckedUpdateWithoutDeliveryAssignedByInput>
  }

  export type OutletUpdateOneRequiredWithoutDeliveryTaskNestedInput = {
    create?: XOR<OutletCreateWithoutDeliveryTaskInput, OutletUncheckedCreateWithoutDeliveryTaskInput>
    connectOrCreate?: OutletCreateOrConnectWithoutDeliveryTaskInput
    upsert?: OutletUpsertWithoutDeliveryTaskInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutDeliveryTaskInput, OutletUpdateWithoutDeliveryTaskInput>, OutletUncheckedUpdateWithoutDeliveryTaskInput>
  }

  export type CustomerAddressUpdateOneRequiredWithoutDeliveryTaskNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutDeliveryTaskInput, CustomerAddressUncheckedCreateWithoutDeliveryTaskInput>
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutDeliveryTaskInput
    upsert?: CustomerAddressUpsertWithoutDeliveryTaskInput
    connect?: CustomerAddressWhereUniqueInput
    update?: XOR<XOR<CustomerAddressUpdateToOneWithWhereWithoutDeliveryTaskInput, CustomerAddressUpdateWithoutDeliveryTaskInput>, CustomerAddressUncheckedUpdateWithoutDeliveryTaskInput>
  }

  export type OrderHeaderUpdateOneRequiredWithoutDeliveryTaskNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutDeliveryTaskInput, OrderHeaderUncheckedCreateWithoutDeliveryTaskInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutDeliveryTaskInput
    upsert?: OrderHeaderUpsertWithoutDeliveryTaskInput
    connect?: OrderHeaderWhereUniqueInput
    update?: XOR<XOR<OrderHeaderUpdateToOneWithWhereWithoutDeliveryTaskInput, OrderHeaderUpdateWithoutDeliveryTaskInput>, OrderHeaderUncheckedUpdateWithoutDeliveryTaskInput>
  }

  export type EmployeeCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<OutletCreateWithoutAttendanceInput, OutletUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: OutletCreateOrConnectWithoutAttendanceInput
    connect?: OutletWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutApprovedAttendancesInput = {
    create?: XOR<EmployeeCreateWithoutApprovedAttendancesInput, EmployeeUncheckedCreateWithoutApprovedAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutApprovedAttendancesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<ShiftCreateWithoutAttendanceInput, ShiftUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutAttendanceInput
    connect?: ShiftWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type EmployeeUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceInput
    upsert?: EmployeeUpsertWithoutAttendanceInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendanceInput, EmployeeUpdateWithoutAttendanceInput>, EmployeeUncheckedUpdateWithoutAttendanceInput>
  }

  export type OutletUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<OutletCreateWithoutAttendanceInput, OutletUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: OutletCreateOrConnectWithoutAttendanceInput
    upsert?: OutletUpsertWithoutAttendanceInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutAttendanceInput, OutletUpdateWithoutAttendanceInput>, OutletUncheckedUpdateWithoutAttendanceInput>
  }

  export type EmployeeUpdateOneWithoutApprovedAttendancesNestedInput = {
    create?: XOR<EmployeeCreateWithoutApprovedAttendancesInput, EmployeeUncheckedCreateWithoutApprovedAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutApprovedAttendancesInput
    upsert?: EmployeeUpsertWithoutApprovedAttendancesInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutApprovedAttendancesInput, EmployeeUpdateWithoutApprovedAttendancesInput>, EmployeeUncheckedUpdateWithoutApprovedAttendancesInput>
  }

  export type ShiftUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<ShiftCreateWithoutAttendanceInput, ShiftUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutAttendanceInput
    upsert?: ShiftUpsertWithoutAttendanceInput
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutAttendanceInput, ShiftUpdateWithoutAttendanceInput>, ShiftUncheckedUpdateWithoutAttendanceInput>
  }

  export type EmployeeCreateNestedManyWithoutOutletsInput = {
    create?: XOR<EmployeeCreateWithoutOutletsInput, EmployeeUncheckedCreateWithoutOutletsInput> | EmployeeCreateWithoutOutletsInput[] | EmployeeUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutOutletsInput | EmployeeCreateOrConnectWithoutOutletsInput[]
    createMany?: EmployeeCreateManyOutletsInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutOutletInput = {
    create?: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput> | AttendanceCreateWithoutOutletInput[] | AttendanceUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOutletInput | AttendanceCreateOrConnectWithoutOutletInput[]
    createMany?: AttendanceCreateManyOutletInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type OutletScheduleCreateNestedManyWithoutOutletInput = {
    create?: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput> | OutletScheduleCreateWithoutOutletInput[] | OutletScheduleUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OutletScheduleCreateOrConnectWithoutOutletInput | OutletScheduleCreateOrConnectWithoutOutletInput[]
    createMany?: OutletScheduleCreateManyOutletInputEnvelope
    connect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
  }

  export type OrderHeaderCreateNestedManyWithoutOutletsInput = {
    create?: XOR<OrderHeaderCreateWithoutOutletsInput, OrderHeaderUncheckedCreateWithoutOutletsInput> | OrderHeaderCreateWithoutOutletsInput[] | OrderHeaderUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOutletsInput | OrderHeaderCreateOrConnectWithoutOutletsInput[]
    createMany?: OrderHeaderCreateManyOutletsInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type EmployeeTaskCreateNestedManyWithoutOutletInput = {
    create?: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput> | EmployeeTaskCreateWithoutOutletInput[] | EmployeeTaskUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOutletInput | EmployeeTaskCreateOrConnectWithoutOutletInput[]
    createMany?: EmployeeTaskCreateManyOutletInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type PickUpTaskCreateNestedManyWithoutOutletsInput = {
    create?: XOR<PickUpTaskCreateWithoutOutletsInput, PickUpTaskUncheckedCreateWithoutOutletsInput> | PickUpTaskCreateWithoutOutletsInput[] | PickUpTaskUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutOutletsInput | PickUpTaskCreateOrConnectWithoutOutletsInput[]
    createMany?: PickUpTaskCreateManyOutletsInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type DeliveryTaskCreateNestedManyWithoutOutletsInput = {
    create?: XOR<DeliveryTaskCreateWithoutOutletsInput, DeliveryTaskUncheckedCreateWithoutOutletsInput> | DeliveryTaskCreateWithoutOutletsInput[] | DeliveryTaskUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutOutletsInput | DeliveryTaskCreateOrConnectWithoutOutletsInput[]
    createMany?: DeliveryTaskCreateManyOutletsInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutOutletsInput = {
    create?: XOR<EmployeeCreateWithoutOutletsInput, EmployeeUncheckedCreateWithoutOutletsInput> | EmployeeCreateWithoutOutletsInput[] | EmployeeUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutOutletsInput | EmployeeCreateOrConnectWithoutOutletsInput[]
    createMany?: EmployeeCreateManyOutletsInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput> | AttendanceCreateWithoutOutletInput[] | AttendanceUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOutletInput | AttendanceCreateOrConnectWithoutOutletInput[]
    createMany?: AttendanceCreateManyOutletInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type OutletScheduleUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput> | OutletScheduleCreateWithoutOutletInput[] | OutletScheduleUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OutletScheduleCreateOrConnectWithoutOutletInput | OutletScheduleCreateOrConnectWithoutOutletInput[]
    createMany?: OutletScheduleCreateManyOutletInputEnvelope
    connect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
  }

  export type OrderHeaderUncheckedCreateNestedManyWithoutOutletsInput = {
    create?: XOR<OrderHeaderCreateWithoutOutletsInput, OrderHeaderUncheckedCreateWithoutOutletsInput> | OrderHeaderCreateWithoutOutletsInput[] | OrderHeaderUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOutletsInput | OrderHeaderCreateOrConnectWithoutOutletsInput[]
    createMany?: OrderHeaderCreateManyOutletsInputEnvelope
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput> | EmployeeTaskCreateWithoutOutletInput[] | EmployeeTaskUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOutletInput | EmployeeTaskCreateOrConnectWithoutOutletInput[]
    createMany?: EmployeeTaskCreateManyOutletInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type PickUpTaskUncheckedCreateNestedManyWithoutOutletsInput = {
    create?: XOR<PickUpTaskCreateWithoutOutletsInput, PickUpTaskUncheckedCreateWithoutOutletsInput> | PickUpTaskCreateWithoutOutletsInput[] | PickUpTaskUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutOutletsInput | PickUpTaskCreateOrConnectWithoutOutletsInput[]
    createMany?: PickUpTaskCreateManyOutletsInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type DeliveryTaskUncheckedCreateNestedManyWithoutOutletsInput = {
    create?: XOR<DeliveryTaskCreateWithoutOutletsInput, DeliveryTaskUncheckedCreateWithoutOutletsInput> | DeliveryTaskCreateWithoutOutletsInput[] | DeliveryTaskUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutOutletsInput | DeliveryTaskCreateOrConnectWithoutOutletsInput[]
    createMany?: DeliveryTaskCreateManyOutletsInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutOutletsNestedInput = {
    create?: XOR<EmployeeCreateWithoutOutletsInput, EmployeeUncheckedCreateWithoutOutletsInput> | EmployeeCreateWithoutOutletsInput[] | EmployeeUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutOutletsInput | EmployeeCreateOrConnectWithoutOutletsInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutOutletsInput | EmployeeUpsertWithWhereUniqueWithoutOutletsInput[]
    createMany?: EmployeeCreateManyOutletsInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutOutletsInput | EmployeeUpdateWithWhereUniqueWithoutOutletsInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutOutletsInput | EmployeeUpdateManyWithWhereWithoutOutletsInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutOutletNestedInput = {
    create?: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput> | AttendanceCreateWithoutOutletInput[] | AttendanceUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOutletInput | AttendanceCreateOrConnectWithoutOutletInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutOutletInput | AttendanceUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: AttendanceCreateManyOutletInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutOutletInput | AttendanceUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutOutletInput | AttendanceUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type OutletScheduleUpdateManyWithoutOutletNestedInput = {
    create?: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput> | OutletScheduleCreateWithoutOutletInput[] | OutletScheduleUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OutletScheduleCreateOrConnectWithoutOutletInput | OutletScheduleCreateOrConnectWithoutOutletInput[]
    upsert?: OutletScheduleUpsertWithWhereUniqueWithoutOutletInput | OutletScheduleUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: OutletScheduleCreateManyOutletInputEnvelope
    set?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    disconnect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    delete?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    connect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    update?: OutletScheduleUpdateWithWhereUniqueWithoutOutletInput | OutletScheduleUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: OutletScheduleUpdateManyWithWhereWithoutOutletInput | OutletScheduleUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: OutletScheduleScalarWhereInput | OutletScheduleScalarWhereInput[]
  }

  export type OrderHeaderUpdateManyWithoutOutletsNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutOutletsInput, OrderHeaderUncheckedCreateWithoutOutletsInput> | OrderHeaderCreateWithoutOutletsInput[] | OrderHeaderUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOutletsInput | OrderHeaderCreateOrConnectWithoutOutletsInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutOutletsInput | OrderHeaderUpsertWithWhereUniqueWithoutOutletsInput[]
    createMany?: OrderHeaderCreateManyOutletsInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutOutletsInput | OrderHeaderUpdateWithWhereUniqueWithoutOutletsInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutOutletsInput | OrderHeaderUpdateManyWithWhereWithoutOutletsInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type EmployeeTaskUpdateManyWithoutOutletNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput> | EmployeeTaskCreateWithoutOutletInput[] | EmployeeTaskUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOutletInput | EmployeeTaskCreateOrConnectWithoutOutletInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput | EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: EmployeeTaskCreateManyOutletInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput | EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOutletInput | EmployeeTaskUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type PickUpTaskUpdateManyWithoutOutletsNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutOutletsInput, PickUpTaskUncheckedCreateWithoutOutletsInput> | PickUpTaskCreateWithoutOutletsInput[] | PickUpTaskUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutOutletsInput | PickUpTaskCreateOrConnectWithoutOutletsInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutOutletsInput | PickUpTaskUpsertWithWhereUniqueWithoutOutletsInput[]
    createMany?: PickUpTaskCreateManyOutletsInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutOutletsInput | PickUpTaskUpdateWithWhereUniqueWithoutOutletsInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutOutletsInput | PickUpTaskUpdateManyWithWhereWithoutOutletsInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type DeliveryTaskUpdateManyWithoutOutletsNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutOutletsInput, DeliveryTaskUncheckedCreateWithoutOutletsInput> | DeliveryTaskCreateWithoutOutletsInput[] | DeliveryTaskUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutOutletsInput | DeliveryTaskCreateOrConnectWithoutOutletsInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutOutletsInput | DeliveryTaskUpsertWithWhereUniqueWithoutOutletsInput[]
    createMany?: DeliveryTaskCreateManyOutletsInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutOutletsInput | DeliveryTaskUpdateWithWhereUniqueWithoutOutletsInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutOutletsInput | DeliveryTaskUpdateManyWithWhereWithoutOutletsInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutOutletsNestedInput = {
    create?: XOR<EmployeeCreateWithoutOutletsInput, EmployeeUncheckedCreateWithoutOutletsInput> | EmployeeCreateWithoutOutletsInput[] | EmployeeUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutOutletsInput | EmployeeCreateOrConnectWithoutOutletsInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutOutletsInput | EmployeeUpsertWithWhereUniqueWithoutOutletsInput[]
    createMany?: EmployeeCreateManyOutletsInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutOutletsInput | EmployeeUpdateWithWhereUniqueWithoutOutletsInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutOutletsInput | EmployeeUpdateManyWithWhereWithoutOutletsInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput> | AttendanceCreateWithoutOutletInput[] | AttendanceUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOutletInput | AttendanceCreateOrConnectWithoutOutletInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutOutletInput | AttendanceUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: AttendanceCreateManyOutletInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutOutletInput | AttendanceUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutOutletInput | AttendanceUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput> | OutletScheduleCreateWithoutOutletInput[] | OutletScheduleUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OutletScheduleCreateOrConnectWithoutOutletInput | OutletScheduleCreateOrConnectWithoutOutletInput[]
    upsert?: OutletScheduleUpsertWithWhereUniqueWithoutOutletInput | OutletScheduleUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: OutletScheduleCreateManyOutletInputEnvelope
    set?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    disconnect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    delete?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    connect?: OutletScheduleWhereUniqueInput | OutletScheduleWhereUniqueInput[]
    update?: OutletScheduleUpdateWithWhereUniqueWithoutOutletInput | OutletScheduleUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: OutletScheduleUpdateManyWithWhereWithoutOutletInput | OutletScheduleUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: OutletScheduleScalarWhereInput | OutletScheduleScalarWhereInput[]
  }

  export type OrderHeaderUncheckedUpdateManyWithoutOutletsNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutOutletsInput, OrderHeaderUncheckedCreateWithoutOutletsInput> | OrderHeaderCreateWithoutOutletsInput[] | OrderHeaderUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOutletsInput | OrderHeaderCreateOrConnectWithoutOutletsInput[]
    upsert?: OrderHeaderUpsertWithWhereUniqueWithoutOutletsInput | OrderHeaderUpsertWithWhereUniqueWithoutOutletsInput[]
    createMany?: OrderHeaderCreateManyOutletsInputEnvelope
    set?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    disconnect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    delete?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    connect?: OrderHeaderWhereUniqueInput | OrderHeaderWhereUniqueInput[]
    update?: OrderHeaderUpdateWithWhereUniqueWithoutOutletsInput | OrderHeaderUpdateWithWhereUniqueWithoutOutletsInput[]
    updateMany?: OrderHeaderUpdateManyWithWhereWithoutOutletsInput | OrderHeaderUpdateManyWithWhereWithoutOutletsInput[]
    deleteMany?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput> | EmployeeTaskCreateWithoutOutletInput[] | EmployeeTaskUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOutletInput | EmployeeTaskCreateOrConnectWithoutOutletInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput | EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: EmployeeTaskCreateManyOutletInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput | EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOutletInput | EmployeeTaskUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type PickUpTaskUncheckedUpdateManyWithoutOutletsNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutOutletsInput, PickUpTaskUncheckedCreateWithoutOutletsInput> | PickUpTaskCreateWithoutOutletsInput[] | PickUpTaskUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutOutletsInput | PickUpTaskCreateOrConnectWithoutOutletsInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutOutletsInput | PickUpTaskUpsertWithWhereUniqueWithoutOutletsInput[]
    createMany?: PickUpTaskCreateManyOutletsInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutOutletsInput | PickUpTaskUpdateWithWhereUniqueWithoutOutletsInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutOutletsInput | PickUpTaskUpdateManyWithWhereWithoutOutletsInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutOutletsNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutOutletsInput, DeliveryTaskUncheckedCreateWithoutOutletsInput> | DeliveryTaskCreateWithoutOutletsInput[] | DeliveryTaskUncheckedCreateWithoutOutletsInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutOutletsInput | DeliveryTaskCreateOrConnectWithoutOutletsInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutOutletsInput | DeliveryTaskUpsertWithWhereUniqueWithoutOutletsInput[]
    createMany?: DeliveryTaskCreateManyOutletsInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutOutletsInput | DeliveryTaskUpdateWithWhereUniqueWithoutOutletsInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutOutletsInput | DeliveryTaskUpdateManyWithWhereWithoutOutletsInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type OutletCreateNestedOneWithoutOutletScheduleInput = {
    create?: XOR<OutletCreateWithoutOutletScheduleInput, OutletUncheckedCreateWithoutOutletScheduleInput>
    connectOrCreate?: OutletCreateOrConnectWithoutOutletScheduleInput
    connect?: OutletWhereUniqueInput
  }

  export type OutletUpdateOneRequiredWithoutOutletScheduleNestedInput = {
    create?: XOR<OutletCreateWithoutOutletScheduleInput, OutletUncheckedCreateWithoutOutletScheduleInput>
    connectOrCreate?: OutletCreateOrConnectWithoutOutletScheduleInput
    upsert?: OutletUpsertWithoutOutletScheduleInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutOutletScheduleInput, OutletUpdateWithoutOutletScheduleInput>, OutletUncheckedUpdateWithoutOutletScheduleInput>
  }

  export type ServiceCreateNestedManyWithoutServiceCatIdInput = {
    create?: XOR<ServiceCreateWithoutServiceCatIdInput, ServiceUncheckedCreateWithoutServiceCatIdInput> | ServiceCreateWithoutServiceCatIdInput[] | ServiceUncheckedCreateWithoutServiceCatIdInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceCatIdInput | ServiceCreateOrConnectWithoutServiceCatIdInput[]
    createMany?: ServiceCreateManyServiceCatIdInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutServiceCatIdInput = {
    create?: XOR<ServiceCreateWithoutServiceCatIdInput, ServiceUncheckedCreateWithoutServiceCatIdInput> | ServiceCreateWithoutServiceCatIdInput[] | ServiceUncheckedCreateWithoutServiceCatIdInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceCatIdInput | ServiceCreateOrConnectWithoutServiceCatIdInput[]
    createMany?: ServiceCreateManyServiceCatIdInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutServiceCatIdNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceCatIdInput, ServiceUncheckedCreateWithoutServiceCatIdInput> | ServiceCreateWithoutServiceCatIdInput[] | ServiceUncheckedCreateWithoutServiceCatIdInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceCatIdInput | ServiceCreateOrConnectWithoutServiceCatIdInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceCatIdInput | ServiceUpsertWithWhereUniqueWithoutServiceCatIdInput[]
    createMany?: ServiceCreateManyServiceCatIdInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceCatIdInput | ServiceUpdateWithWhereUniqueWithoutServiceCatIdInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceCatIdInput | ServiceUpdateManyWithWhereWithoutServiceCatIdInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutServiceCatIdNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceCatIdInput, ServiceUncheckedCreateWithoutServiceCatIdInput> | ServiceCreateWithoutServiceCatIdInput[] | ServiceUncheckedCreateWithoutServiceCatIdInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceCatIdInput | ServiceCreateOrConnectWithoutServiceCatIdInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceCatIdInput | ServiceUpsertWithWhereUniqueWithoutServiceCatIdInput[]
    createMany?: ServiceCreateManyServiceCatIdInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceCatIdInput | ServiceUpdateWithWhereUniqueWithoutServiceCatIdInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceCatIdInput | ServiceUpdateManyWithWhereWithoutServiceCatIdInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCategoryCreateNestedOneWithoutServiceInput = {
    create?: XOR<ServiceCategoryCreateWithoutServiceInput, ServiceCategoryUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServiceInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ServiceCategoryUpdateOneRequiredWithoutServiceNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutServiceInput, ServiceCategoryUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServiceInput
    upsert?: ServiceCategoryUpsertWithoutServiceInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutServiceInput, ServiceCategoryUpdateWithoutServiceInput>, ServiceCategoryUncheckedUpdateWithoutServiceInput>
  }

  export type OrderItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutServiceInput | OrderItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutServiceInput | OrderItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutServiceInput | OrderItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutServiceInput | OrderItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutServiceInput | OrderItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutServiceInput | OrderItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutOrderHeaderInput = {
    create?: XOR<CustomerCreateWithoutOrderHeaderInput, CustomerUncheckedCreateWithoutOrderHeaderInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrderHeaderInput
    connect?: CustomerWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutOrderHeaderInput = {
    create?: XOR<EmployeeCreateWithoutOrderHeaderInput, EmployeeUncheckedCreateWithoutOrderHeaderInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOrderHeaderInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutOrderHeaderInput = {
    create?: XOR<OutletCreateWithoutOrderHeaderInput, OutletUncheckedCreateWithoutOrderHeaderInput>
    connectOrCreate?: OutletCreateOrConnectWithoutOrderHeaderInput
    connect?: OutletWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderheaderInput = {
    create?: XOR<OrderItemCreateWithoutOrderheaderInput, OrderItemUncheckedCreateWithoutOrderheaderInput> | OrderItemCreateWithoutOrderheaderInput[] | OrderItemUncheckedCreateWithoutOrderheaderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderheaderInput | OrderItemCreateOrConnectWithoutOrderheaderInput[]
    createMany?: OrderItemCreateManyOrderheaderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderheaderInput = {
    create?: XOR<PaymentCreateWithoutOrderheaderInput, PaymentUncheckedCreateWithoutOrderheaderInput> | PaymentCreateWithoutOrderheaderInput[] | PaymentUncheckedCreateWithoutOrderheaderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderheaderInput | PaymentCreateOrConnectWithoutOrderheaderInput[]
    createMany?: PaymentCreateManyOrderheaderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EmployeeTaskCreateNestedManyWithoutOrderHeaderInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderHeaderInput, EmployeeTaskUncheckedCreateWithoutOrderHeaderInput> | EmployeeTaskCreateWithoutOrderHeaderInput[] | EmployeeTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderHeaderInput | EmployeeTaskCreateOrConnectWithoutOrderHeaderInput[]
    createMany?: EmployeeTaskCreateManyOrderHeaderInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type PickUpTaskCreateNestedManyWithoutOrderHeaderInput = {
    create?: XOR<PickUpTaskCreateWithoutOrderHeaderInput, PickUpTaskUncheckedCreateWithoutOrderHeaderInput> | PickUpTaskCreateWithoutOrderHeaderInput[] | PickUpTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutOrderHeaderInput | PickUpTaskCreateOrConnectWithoutOrderHeaderInput[]
    createMany?: PickUpTaskCreateManyOrderHeaderInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type DeliveryTaskCreateNestedManyWithoutOrderHeaderInput = {
    create?: XOR<DeliveryTaskCreateWithoutOrderHeaderInput, DeliveryTaskUncheckedCreateWithoutOrderHeaderInput> | DeliveryTaskCreateWithoutOrderHeaderInput[] | DeliveryTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutOrderHeaderInput | DeliveryTaskCreateOrConnectWithoutOrderHeaderInput[]
    createMany?: DeliveryTaskCreateManyOrderHeaderInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderheaderInput = {
    create?: XOR<OrderItemCreateWithoutOrderheaderInput, OrderItemUncheckedCreateWithoutOrderheaderInput> | OrderItemCreateWithoutOrderheaderInput[] | OrderItemUncheckedCreateWithoutOrderheaderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderheaderInput | OrderItemCreateOrConnectWithoutOrderheaderInput[]
    createMany?: OrderItemCreateManyOrderheaderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderheaderInput = {
    create?: XOR<PaymentCreateWithoutOrderheaderInput, PaymentUncheckedCreateWithoutOrderheaderInput> | PaymentCreateWithoutOrderheaderInput[] | PaymentUncheckedCreateWithoutOrderheaderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderheaderInput | PaymentCreateOrConnectWithoutOrderheaderInput[]
    createMany?: PaymentCreateManyOrderheaderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutOrderHeaderInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderHeaderInput, EmployeeTaskUncheckedCreateWithoutOrderHeaderInput> | EmployeeTaskCreateWithoutOrderHeaderInput[] | EmployeeTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderHeaderInput | EmployeeTaskCreateOrConnectWithoutOrderHeaderInput[]
    createMany?: EmployeeTaskCreateManyOrderHeaderInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type PickUpTaskUncheckedCreateNestedManyWithoutOrderHeaderInput = {
    create?: XOR<PickUpTaskCreateWithoutOrderHeaderInput, PickUpTaskUncheckedCreateWithoutOrderHeaderInput> | PickUpTaskCreateWithoutOrderHeaderInput[] | PickUpTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutOrderHeaderInput | PickUpTaskCreateOrConnectWithoutOrderHeaderInput[]
    createMany?: PickUpTaskCreateManyOrderHeaderInputEnvelope
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
  }

  export type DeliveryTaskUncheckedCreateNestedManyWithoutOrderHeaderInput = {
    create?: XOR<DeliveryTaskCreateWithoutOrderHeaderInput, DeliveryTaskUncheckedCreateWithoutOrderHeaderInput> | DeliveryTaskCreateWithoutOrderHeaderInput[] | DeliveryTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutOrderHeaderInput | DeliveryTaskCreateOrConnectWithoutOrderHeaderInput[]
    createMany?: DeliveryTaskCreateManyOrderHeaderInputEnvelope
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type CustomerUpdateOneRequiredWithoutOrderHeaderNestedInput = {
    create?: XOR<CustomerCreateWithoutOrderHeaderInput, CustomerUncheckedCreateWithoutOrderHeaderInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrderHeaderInput
    upsert?: CustomerUpsertWithoutOrderHeaderInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrderHeaderInput, CustomerUpdateWithoutOrderHeaderInput>, CustomerUncheckedUpdateWithoutOrderHeaderInput>
  }

  export type EmployeeUpdateOneWithoutOrderHeaderNestedInput = {
    create?: XOR<EmployeeCreateWithoutOrderHeaderInput, EmployeeUncheckedCreateWithoutOrderHeaderInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOrderHeaderInput
    upsert?: EmployeeUpsertWithoutOrderHeaderInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutOrderHeaderInput, EmployeeUpdateWithoutOrderHeaderInput>, EmployeeUncheckedUpdateWithoutOrderHeaderInput>
  }

  export type OutletUpdateOneRequiredWithoutOrderHeaderNestedInput = {
    create?: XOR<OutletCreateWithoutOrderHeaderInput, OutletUncheckedCreateWithoutOrderHeaderInput>
    connectOrCreate?: OutletCreateOrConnectWithoutOrderHeaderInput
    upsert?: OutletUpsertWithoutOrderHeaderInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutOrderHeaderInput, OutletUpdateWithoutOrderHeaderInput>, OutletUncheckedUpdateWithoutOrderHeaderInput>
  }

  export type OrderItemUpdateManyWithoutOrderheaderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderheaderInput, OrderItemUncheckedCreateWithoutOrderheaderInput> | OrderItemCreateWithoutOrderheaderInput[] | OrderItemUncheckedCreateWithoutOrderheaderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderheaderInput | OrderItemCreateOrConnectWithoutOrderheaderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderheaderInput | OrderItemUpsertWithWhereUniqueWithoutOrderheaderInput[]
    createMany?: OrderItemCreateManyOrderheaderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderheaderInput | OrderItemUpdateWithWhereUniqueWithoutOrderheaderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderheaderInput | OrderItemUpdateManyWithWhereWithoutOrderheaderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderheaderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderheaderInput, PaymentUncheckedCreateWithoutOrderheaderInput> | PaymentCreateWithoutOrderheaderInput[] | PaymentUncheckedCreateWithoutOrderheaderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderheaderInput | PaymentCreateOrConnectWithoutOrderheaderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderheaderInput | PaymentUpsertWithWhereUniqueWithoutOrderheaderInput[]
    createMany?: PaymentCreateManyOrderheaderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderheaderInput | PaymentUpdateWithWhereUniqueWithoutOrderheaderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderheaderInput | PaymentUpdateManyWithWhereWithoutOrderheaderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type EmployeeTaskUpdateManyWithoutOrderHeaderNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderHeaderInput, EmployeeTaskUncheckedCreateWithoutOrderHeaderInput> | EmployeeTaskCreateWithoutOrderHeaderInput[] | EmployeeTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderHeaderInput | EmployeeTaskCreateOrConnectWithoutOrderHeaderInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOrderHeaderInput | EmployeeTaskUpsertWithWhereUniqueWithoutOrderHeaderInput[]
    createMany?: EmployeeTaskCreateManyOrderHeaderInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOrderHeaderInput | EmployeeTaskUpdateWithWhereUniqueWithoutOrderHeaderInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOrderHeaderInput | EmployeeTaskUpdateManyWithWhereWithoutOrderHeaderInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type PickUpTaskUpdateManyWithoutOrderHeaderNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutOrderHeaderInput, PickUpTaskUncheckedCreateWithoutOrderHeaderInput> | PickUpTaskCreateWithoutOrderHeaderInput[] | PickUpTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutOrderHeaderInput | PickUpTaskCreateOrConnectWithoutOrderHeaderInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutOrderHeaderInput | PickUpTaskUpsertWithWhereUniqueWithoutOrderHeaderInput[]
    createMany?: PickUpTaskCreateManyOrderHeaderInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutOrderHeaderInput | PickUpTaskUpdateWithWhereUniqueWithoutOrderHeaderInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutOrderHeaderInput | PickUpTaskUpdateManyWithWhereWithoutOrderHeaderInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type DeliveryTaskUpdateManyWithoutOrderHeaderNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutOrderHeaderInput, DeliveryTaskUncheckedCreateWithoutOrderHeaderInput> | DeliveryTaskCreateWithoutOrderHeaderInput[] | DeliveryTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutOrderHeaderInput | DeliveryTaskCreateOrConnectWithoutOrderHeaderInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutOrderHeaderInput | DeliveryTaskUpsertWithWhereUniqueWithoutOrderHeaderInput[]
    createMany?: DeliveryTaskCreateManyOrderHeaderInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutOrderHeaderInput | DeliveryTaskUpdateWithWhereUniqueWithoutOrderHeaderInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutOrderHeaderInput | DeliveryTaskUpdateManyWithWhereWithoutOrderHeaderInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderheaderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderheaderInput, OrderItemUncheckedCreateWithoutOrderheaderInput> | OrderItemCreateWithoutOrderheaderInput[] | OrderItemUncheckedCreateWithoutOrderheaderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderheaderInput | OrderItemCreateOrConnectWithoutOrderheaderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderheaderInput | OrderItemUpsertWithWhereUniqueWithoutOrderheaderInput[]
    createMany?: OrderItemCreateManyOrderheaderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderheaderInput | OrderItemUpdateWithWhereUniqueWithoutOrderheaderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderheaderInput | OrderItemUpdateManyWithWhereWithoutOrderheaderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderheaderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderheaderInput, PaymentUncheckedCreateWithoutOrderheaderInput> | PaymentCreateWithoutOrderheaderInput[] | PaymentUncheckedCreateWithoutOrderheaderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderheaderInput | PaymentCreateOrConnectWithoutOrderheaderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderheaderInput | PaymentUpsertWithWhereUniqueWithoutOrderheaderInput[]
    createMany?: PaymentCreateManyOrderheaderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderheaderInput | PaymentUpdateWithWhereUniqueWithoutOrderheaderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderheaderInput | PaymentUpdateManyWithWhereWithoutOrderheaderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderHeaderInput, EmployeeTaskUncheckedCreateWithoutOrderHeaderInput> | EmployeeTaskCreateWithoutOrderHeaderInput[] | EmployeeTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderHeaderInput | EmployeeTaskCreateOrConnectWithoutOrderHeaderInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOrderHeaderInput | EmployeeTaskUpsertWithWhereUniqueWithoutOrderHeaderInput[]
    createMany?: EmployeeTaskCreateManyOrderHeaderInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOrderHeaderInput | EmployeeTaskUpdateWithWhereUniqueWithoutOrderHeaderInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOrderHeaderInput | EmployeeTaskUpdateManyWithWhereWithoutOrderHeaderInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type PickUpTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput = {
    create?: XOR<PickUpTaskCreateWithoutOrderHeaderInput, PickUpTaskUncheckedCreateWithoutOrderHeaderInput> | PickUpTaskCreateWithoutOrderHeaderInput[] | PickUpTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: PickUpTaskCreateOrConnectWithoutOrderHeaderInput | PickUpTaskCreateOrConnectWithoutOrderHeaderInput[]
    upsert?: PickUpTaskUpsertWithWhereUniqueWithoutOrderHeaderInput | PickUpTaskUpsertWithWhereUniqueWithoutOrderHeaderInput[]
    createMany?: PickUpTaskCreateManyOrderHeaderInputEnvelope
    set?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    disconnect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    delete?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    connect?: PickUpTaskWhereUniqueInput | PickUpTaskWhereUniqueInput[]
    update?: PickUpTaskUpdateWithWhereUniqueWithoutOrderHeaderInput | PickUpTaskUpdateWithWhereUniqueWithoutOrderHeaderInput[]
    updateMany?: PickUpTaskUpdateManyWithWhereWithoutOrderHeaderInput | PickUpTaskUpdateManyWithWhereWithoutOrderHeaderInput[]
    deleteMany?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput = {
    create?: XOR<DeliveryTaskCreateWithoutOrderHeaderInput, DeliveryTaskUncheckedCreateWithoutOrderHeaderInput> | DeliveryTaskCreateWithoutOrderHeaderInput[] | DeliveryTaskUncheckedCreateWithoutOrderHeaderInput[]
    connectOrCreate?: DeliveryTaskCreateOrConnectWithoutOrderHeaderInput | DeliveryTaskCreateOrConnectWithoutOrderHeaderInput[]
    upsert?: DeliveryTaskUpsertWithWhereUniqueWithoutOrderHeaderInput | DeliveryTaskUpsertWithWhereUniqueWithoutOrderHeaderInput[]
    createMany?: DeliveryTaskCreateManyOrderHeaderInputEnvelope
    set?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    disconnect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    delete?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    connect?: DeliveryTaskWhereUniqueInput | DeliveryTaskWhereUniqueInput[]
    update?: DeliveryTaskUpdateWithWhereUniqueWithoutOrderHeaderInput | DeliveryTaskUpdateWithWhereUniqueWithoutOrderHeaderInput[]
    updateMany?: DeliveryTaskUpdateManyWithWhereWithoutOrderHeaderInput | DeliveryTaskUpdateManyWithWhereWithoutOrderHeaderInput[]
    deleteMany?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
  }

  export type OrderHeaderCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<OrderHeaderCreateWithoutOrderItemInput, OrderHeaderUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOrderItemInput
    connect?: OrderHeaderWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ServiceCreateWithoutOrderItemInput, ServiceUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrderItemInput
    connect?: ServiceWhereUniqueInput
  }

  export type EmployeeTaskCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderItemInput, EmployeeTaskUncheckedCreateWithoutOrderItemInput> | EmployeeTaskCreateWithoutOrderItemInput[] | EmployeeTaskUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderItemInput | EmployeeTaskCreateOrConnectWithoutOrderItemInput[]
    createMany?: EmployeeTaskCreateManyOrderItemInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type EmployeeTaskUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderItemInput, EmployeeTaskUncheckedCreateWithoutOrderItemInput> | EmployeeTaskCreateWithoutOrderItemInput[] | EmployeeTaskUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderItemInput | EmployeeTaskCreateOrConnectWithoutOrderItemInput[]
    createMany?: EmployeeTaskCreateManyOrderItemInputEnvelope
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
  }

  export type OrderHeaderUpdateOneRequiredWithoutOrderItemNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutOrderItemInput, OrderHeaderUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutOrderItemInput
    upsert?: OrderHeaderUpsertWithoutOrderItemInput
    connect?: OrderHeaderWhereUniqueInput
    update?: XOR<XOR<OrderHeaderUpdateToOneWithWhereWithoutOrderItemInput, OrderHeaderUpdateWithoutOrderItemInput>, OrderHeaderUncheckedUpdateWithoutOrderItemInput>
  }

  export type ServiceUpdateOneRequiredWithoutOrderItemNestedInput = {
    create?: XOR<ServiceCreateWithoutOrderItemInput, ServiceUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrderItemInput
    upsert?: ServiceUpsertWithoutOrderItemInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutOrderItemInput, ServiceUpdateWithoutOrderItemInput>, ServiceUncheckedUpdateWithoutOrderItemInput>
  }

  export type EmployeeTaskUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderItemInput, EmployeeTaskUncheckedCreateWithoutOrderItemInput> | EmployeeTaskCreateWithoutOrderItemInput[] | EmployeeTaskUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderItemInput | EmployeeTaskCreateOrConnectWithoutOrderItemInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOrderItemInput | EmployeeTaskUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: EmployeeTaskCreateManyOrderItemInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOrderItemInput | EmployeeTaskUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOrderItemInput | EmployeeTaskUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<EmployeeTaskCreateWithoutOrderItemInput, EmployeeTaskUncheckedCreateWithoutOrderItemInput> | EmployeeTaskCreateWithoutOrderItemInput[] | EmployeeTaskUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: EmployeeTaskCreateOrConnectWithoutOrderItemInput | EmployeeTaskCreateOrConnectWithoutOrderItemInput[]
    upsert?: EmployeeTaskUpsertWithWhereUniqueWithoutOrderItemInput | EmployeeTaskUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: EmployeeTaskCreateManyOrderItemInputEnvelope
    set?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    disconnect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    delete?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    connect?: EmployeeTaskWhereUniqueInput | EmployeeTaskWhereUniqueInput[]
    update?: EmployeeTaskUpdateWithWhereUniqueWithoutOrderItemInput | EmployeeTaskUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: EmployeeTaskUpdateManyWithWhereWithoutOrderItemInput | EmployeeTaskUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
  }

  export type OrderHeaderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrderHeaderCreateWithoutPaymentInput, OrderHeaderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutPaymentInput
    connect?: OrderHeaderWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type OrderHeaderUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<OrderHeaderCreateWithoutPaymentInput, OrderHeaderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderHeaderCreateOrConnectWithoutPaymentInput
    upsert?: OrderHeaderUpsertWithoutPaymentInput
    connect?: OrderHeaderWhereUniqueInput
    update?: XOR<XOR<OrderHeaderUpdateToOneWithWhereWithoutPaymentInput, OrderHeaderUpdateWithoutPaymentInput>, OrderHeaderUncheckedUpdateWithoutPaymentInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumOAuthProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOAuthProviderNullableFilter<$PrismaModel> | $Enums.OAuthProvider | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumOAuthProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOAuthProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.OAuthProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOAuthProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumOAuthProviderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumLabelFilter<$PrismaModel = never> = {
    equals?: $Enums.Label | EnumLabelFieldRefInput<$PrismaModel>
    in?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelFilter<$PrismaModel> | $Enums.Label
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLabelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Label | EnumLabelFieldRefInput<$PrismaModel>
    in?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Label[] | ListEnumLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelWithAggregatesFilter<$PrismaModel> | $Enums.Label
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabelFilter<$PrismaModel>
    _max?: NestedEnumLabelFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStationFilter<$PrismaModel = never> = {
    equals?: $Enums.Station | EnumStationFieldRefInput<$PrismaModel>
    in?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    not?: NestedEnumStationFilter<$PrismaModel> | $Enums.Station
  }

  export type NestedEnumStationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Station | EnumStationFieldRefInput<$PrismaModel>
    in?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Station[] | ListEnumStationFieldRefInput<$PrismaModel>
    not?: NestedEnumStationWithAggregatesFilter<$PrismaModel> | $Enums.Station
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStationFilter<$PrismaModel>
    _max?: NestedEnumStationFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumPickupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PickupStatus | EnumPickupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PickupStatus[] | ListEnumPickupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PickupStatus[] | ListEnumPickupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPickupStatusFilter<$PrismaModel> | $Enums.PickupStatus
  }

  export type NestedEnumPickupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PickupStatus | EnumPickupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PickupStatus[] | ListEnumPickupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PickupStatus[] | ListEnumPickupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPickupStatusWithAggregatesFilter<$PrismaModel> | $Enums.PickupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPickupStatusFilter<$PrismaModel>
    _max?: NestedEnumPickupStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumDeilveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeilveryStatus | EnumDeilveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeilveryStatus[] | ListEnumDeilveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeilveryStatus[] | ListEnumDeilveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeilveryStatusFilter<$PrismaModel> | $Enums.DeilveryStatus
  }

  export type NestedEnumDeilveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeilveryStatus | EnumDeilveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeilveryStatus[] | ListEnumDeilveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeilveryStatus[] | ListEnumDeilveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeilveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeilveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeilveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeilveryStatusFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type CustomerAddressCreateWithoutCustomersInput = {
    id?: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    PickUpTask?: PickUpTaskCreateNestedManyWithoutCustomerAddressInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUncheckedCreateWithoutCustomersInput = {
    id?: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutCustomerAddressInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressCreateOrConnectWithoutCustomersInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutCustomersInput, CustomerAddressUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerAddressCreateManyCustomersInputEnvelope = {
    data: CustomerAddressCreateManyCustomersInput | CustomerAddressCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type OrderHeaderCreateWithoutCustomersInput = {
    id?: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeCreateNestedOneWithoutOrderHeaderInput
    outlets: OutletCreateNestedOneWithoutOrderHeaderInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUncheckedCreateWithoutCustomersInput = {
    id?: string
    handledById?: string | null
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderCreateOrConnectWithoutCustomersInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutCustomersInput, OrderHeaderUncheckedCreateWithoutCustomersInput>
  }

  export type OrderHeaderCreateManyCustomersInputEnvelope = {
    data: OrderHeaderCreateManyCustomersInput | OrderHeaderCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type CustomerAddressUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CustomerAddressWhereUniqueInput
    update: XOR<CustomerAddressUpdateWithoutCustomersInput, CustomerAddressUncheckedUpdateWithoutCustomersInput>
    create: XOR<CustomerAddressCreateWithoutCustomersInput, CustomerAddressUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerAddressUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CustomerAddressWhereUniqueInput
    data: XOR<CustomerAddressUpdateWithoutCustomersInput, CustomerAddressUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerAddressUpdateManyWithWhereWithoutCustomersInput = {
    where: CustomerAddressScalarWhereInput
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyWithoutCustomersInput>
  }

  export type CustomerAddressScalarWhereInput = {
    AND?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    OR?: CustomerAddressScalarWhereInput[]
    NOT?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    label?: EnumLabelFilter<"CustomerAddress"> | $Enums.Label
    address?: StringFilter<"CustomerAddress"> | string
    city?: StringFilter<"CustomerAddress"> | string
    postalCode?: StringFilter<"CustomerAddress"> | string
    latitude?: FloatFilter<"CustomerAddress"> | number
    longitude?: FloatFilter<"CustomerAddress"> | number
    notes?: StringNullableFilter<"CustomerAddress"> | string | null
    isPrimary?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CustomerAddress"> | Date | string | null
  }

  export type OrderHeaderUpsertWithWhereUniqueWithoutCustomersInput = {
    where: OrderHeaderWhereUniqueInput
    update: XOR<OrderHeaderUpdateWithoutCustomersInput, OrderHeaderUncheckedUpdateWithoutCustomersInput>
    create: XOR<OrderHeaderCreateWithoutCustomersInput, OrderHeaderUncheckedCreateWithoutCustomersInput>
  }

  export type OrderHeaderUpdateWithWhereUniqueWithoutCustomersInput = {
    where: OrderHeaderWhereUniqueInput
    data: XOR<OrderHeaderUpdateWithoutCustomersInput, OrderHeaderUncheckedUpdateWithoutCustomersInput>
  }

  export type OrderHeaderUpdateManyWithWhereWithoutCustomersInput = {
    where: OrderHeaderScalarWhereInput
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyWithoutCustomersInput>
  }

  export type OrderHeaderScalarWhereInput = {
    AND?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
    OR?: OrderHeaderScalarWhereInput[]
    NOT?: OrderHeaderScalarWhereInput | OrderHeaderScalarWhereInput[]
    id?: StringFilter<"OrderHeader"> | string
    customerId?: StringFilter<"OrderHeader"> | string
    handledById?: StringNullableFilter<"OrderHeader"> | string | null
    outletId?: StringFilter<"OrderHeader"> | string
    status?: EnumOrderStatusFilter<"OrderHeader"> | $Enums.OrderStatus
    notes?: StringFilter<"OrderHeader"> | string
    pickupAt?: DateTimeFilter<"OrderHeader"> | Date | string
    deliverAt?: DateTimeFilter<"OrderHeader"> | Date | string
    estHours?: IntFilter<"OrderHeader"> | number
    createdAt?: DateTimeFilter<"OrderHeader"> | Date | string
    updatedAt?: DateTimeFilter<"OrderHeader"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderHeader"> | Date | string | null
  }

  export type CustomerCreateWithoutCustomerAddressInput = {
    id?: string
    role?: $Enums.Role
    name?: string | null
    email: string
    password?: string | null
    phoneNumber?: string | null
    photoUrl?: string | null
    isVerified?: boolean
    selectProvider?: $Enums.OAuthProvider | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiresAt?: Date | string | null
    verifyToken?: string | null
    verifyTokenExpiresAt?: Date | string | null
    pendingEmail?: string | null
    pendingEmailToken?: string | null
    pendingEmailTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderHeader?: OrderHeaderCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutCustomerAddressInput = {
    id?: string
    role?: $Enums.Role
    name?: string | null
    email: string
    password?: string | null
    phoneNumber?: string | null
    photoUrl?: string | null
    isVerified?: boolean
    selectProvider?: $Enums.OAuthProvider | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiresAt?: Date | string | null
    verifyToken?: string | null
    verifyTokenExpiresAt?: Date | string | null
    pendingEmail?: string | null
    pendingEmailToken?: string | null
    pendingEmailTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutCustomerAddressInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerAddressInput, CustomerUncheckedCreateWithoutCustomerAddressInput>
  }

  export type PickUpTaskCreateWithoutCustomerAddressInput = {
    id?: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutPickUpDriverInput
    assignedBy?: EmployeeCreateNestedOneWithoutPickupAssignedByInput
    outlets: OutletCreateNestedOneWithoutPickUpTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutPickUpTaskInput
  }

  export type PickUpTaskUncheckedCreateWithoutCustomerAddressInput = {
    id?: string
    driverId: string
    outletId: string
    assignedByAdminId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskCreateOrConnectWithoutCustomerAddressInput = {
    where: PickUpTaskWhereUniqueInput
    create: XOR<PickUpTaskCreateWithoutCustomerAddressInput, PickUpTaskUncheckedCreateWithoutCustomerAddressInput>
  }

  export type PickUpTaskCreateManyCustomerAddressInputEnvelope = {
    data: PickUpTaskCreateManyCustomerAddressInput | PickUpTaskCreateManyCustomerAddressInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryTaskCreateWithoutCustomerAddressInput = {
    id?: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutDeliveryDriverInput
    assignedBy?: EmployeeCreateNestedOneWithoutDeliveryAssignedByInput
    outlets: OutletCreateNestedOneWithoutDeliveryTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutDeliveryTaskInput
  }

  export type DeliveryTaskUncheckedCreateWithoutCustomerAddressInput = {
    id?: string
    driverId: string
    outletId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateOrConnectWithoutCustomerAddressInput = {
    where: DeliveryTaskWhereUniqueInput
    create: XOR<DeliveryTaskCreateWithoutCustomerAddressInput, DeliveryTaskUncheckedCreateWithoutCustomerAddressInput>
  }

  export type DeliveryTaskCreateManyCustomerAddressInputEnvelope = {
    data: DeliveryTaskCreateManyCustomerAddressInput | DeliveryTaskCreateManyCustomerAddressInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutCustomerAddressInput = {
    update: XOR<CustomerUpdateWithoutCustomerAddressInput, CustomerUncheckedUpdateWithoutCustomerAddressInput>
    create: XOR<CustomerCreateWithoutCustomerAddressInput, CustomerUncheckedCreateWithoutCustomerAddressInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerAddressInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerAddressInput, CustomerUncheckedUpdateWithoutCustomerAddressInput>
  }

  export type CustomerUpdateWithoutCustomerAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    selectProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderHeader?: OrderHeaderUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    selectProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type PickUpTaskUpsertWithWhereUniqueWithoutCustomerAddressInput = {
    where: PickUpTaskWhereUniqueInput
    update: XOR<PickUpTaskUpdateWithoutCustomerAddressInput, PickUpTaskUncheckedUpdateWithoutCustomerAddressInput>
    create: XOR<PickUpTaskCreateWithoutCustomerAddressInput, PickUpTaskUncheckedCreateWithoutCustomerAddressInput>
  }

  export type PickUpTaskUpdateWithWhereUniqueWithoutCustomerAddressInput = {
    where: PickUpTaskWhereUniqueInput
    data: XOR<PickUpTaskUpdateWithoutCustomerAddressInput, PickUpTaskUncheckedUpdateWithoutCustomerAddressInput>
  }

  export type PickUpTaskUpdateManyWithWhereWithoutCustomerAddressInput = {
    where: PickUpTaskScalarWhereInput
    data: XOR<PickUpTaskUpdateManyMutationInput, PickUpTaskUncheckedUpdateManyWithoutCustomerAddressInput>
  }

  export type PickUpTaskScalarWhereInput = {
    AND?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
    OR?: PickUpTaskScalarWhereInput[]
    NOT?: PickUpTaskScalarWhereInput | PickUpTaskScalarWhereInput[]
    id?: StringFilter<"PickUpTask"> | string
    driverId?: StringFilter<"PickUpTask"> | string
    outletId?: StringFilter<"PickUpTask"> | string
    customerAddressId?: StringFilter<"PickUpTask"> | string
    assignedByAdminId?: StringFilter<"PickUpTask"> | string
    orderHeaderId?: StringFilter<"PickUpTask"> | string
    status?: EnumPickupStatusFilter<"PickUpTask"> | $Enums.PickupStatus
    distance?: IntFilter<"PickUpTask"> | number
    price?: IntFilter<"PickUpTask"> | number
    createdAt?: DateTimeFilter<"PickUpTask"> | Date | string
    updatedAt?: DateTimeFilter<"PickUpTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PickUpTask"> | Date | string | null
  }

  export type DeliveryTaskUpsertWithWhereUniqueWithoutCustomerAddressInput = {
    where: DeliveryTaskWhereUniqueInput
    update: XOR<DeliveryTaskUpdateWithoutCustomerAddressInput, DeliveryTaskUncheckedUpdateWithoutCustomerAddressInput>
    create: XOR<DeliveryTaskCreateWithoutCustomerAddressInput, DeliveryTaskUncheckedCreateWithoutCustomerAddressInput>
  }

  export type DeliveryTaskUpdateWithWhereUniqueWithoutCustomerAddressInput = {
    where: DeliveryTaskWhereUniqueInput
    data: XOR<DeliveryTaskUpdateWithoutCustomerAddressInput, DeliveryTaskUncheckedUpdateWithoutCustomerAddressInput>
  }

  export type DeliveryTaskUpdateManyWithWhereWithoutCustomerAddressInput = {
    where: DeliveryTaskScalarWhereInput
    data: XOR<DeliveryTaskUpdateManyMutationInput, DeliveryTaskUncheckedUpdateManyWithoutCustomerAddressInput>
  }

  export type DeliveryTaskScalarWhereInput = {
    AND?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
    OR?: DeliveryTaskScalarWhereInput[]
    NOT?: DeliveryTaskScalarWhereInput | DeliveryTaskScalarWhereInput[]
    id?: StringFilter<"DeliveryTask"> | string
    driverId?: StringFilter<"DeliveryTask"> | string
    outletId?: StringFilter<"DeliveryTask"> | string
    customerAddressId?: StringFilter<"DeliveryTask"> | string
    assignedByAdminId?: StringFilter<"DeliveryTask"> | string
    orderHeaderId?: StringFilter<"DeliveryTask"> | string
    status?: EnumDeilveryStatusFilter<"DeliveryTask"> | $Enums.DeilveryStatus
    distance?: IntFilter<"DeliveryTask"> | number
    price?: IntFilter<"DeliveryTask"> | number
    createdAt?: DateTimeFilter<"DeliveryTask"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DeliveryTask"> | Date | string | null
  }

  export type ShiftCreateWithoutEmployeeInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceCreateNestedManyWithoutShiftInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutEmployeeInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutShiftInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutEmployeeInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput>
  }

  export type OutletCreateWithoutEmployeeInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOutletsInput
  }

  export type OutletUncheckedCreateWithoutEmployeeInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOutletsInput
  }

  export type OutletCreateOrConnectWithoutEmployeeInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutEmployeeInput, OutletUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceCreateWithoutEmployeesInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlet: OutletCreateNestedOneWithoutAttendanceInput
    approvedBy?: EmployeeCreateNestedOneWithoutApprovedAttendancesInput
    shift: ShiftCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutEmployeesInput = {
    id?: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutEmployeesInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutEmployeesInput, AttendanceUncheckedCreateWithoutEmployeesInput>
  }

  export type AttendanceCreateManyEmployeesInputEnvelope = {
    data: AttendanceCreateManyEmployeesInput | AttendanceCreateManyEmployeesInput[]
    skipDuplicates?: boolean
  }

  export type OrderHeaderCreateWithoutEmployeesInput = {
    id?: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutOrderHeaderInput
    outlets: OutletCreateNestedOneWithoutOrderHeaderInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUncheckedCreateWithoutEmployeesInput = {
    id?: string
    customerId: string
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderCreateOrConnectWithoutEmployeesInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutEmployeesInput, OrderHeaderUncheckedCreateWithoutEmployeesInput>
  }

  export type OrderHeaderCreateManyEmployeesInputEnvelope = {
    data: OrderHeaderCreateManyEmployeesInput | OrderHeaderCreateManyEmployeesInput[]
    skipDuplicates?: boolean
  }

  export type WorkStationCreateWithoutEmployeesInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workerTasks?: EmployeeTaskCreateNestedManyWithoutWorkStationInput
  }

  export type WorkStationUncheckedCreateWithoutEmployeesInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutWorkStationInput
  }

  export type WorkStationCreateOrConnectWithoutEmployeesInput = {
    where: WorkStationWhereUniqueInput
    create: XOR<WorkStationCreateWithoutEmployeesInput, WorkStationUncheckedCreateWithoutEmployeesInput>
  }

  export type WorkStationCreateManyEmployeesInputEnvelope = {
    data: WorkStationCreateManyEmployeesInput | WorkStationCreateManyEmployeesInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskCreateWithoutEmployeeInput = {
    id?: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignedBy?: EmployeeCreateNestedOneWithoutAssignedTasksInput
    orderHeader?: OrderHeaderCreateNestedOneWithoutWorkerTasksInput
    orderItem?: OrderItemCreateNestedOneWithoutWorkerTasksInput
    outlet: OutletCreateNestedOneWithoutWorkerTasksInput
    shift: ShiftCreateNestedOneWithoutWorkerTasksInput
    workStation: WorkStationCreateNestedOneWithoutWorkerTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutEmployeeInput = {
    id?: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutEmployeeInput, EmployeeTaskUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeTaskCreateManyEmployeeInputEnvelope = {
    data: EmployeeTaskCreateManyEmployeeInput | EmployeeTaskCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskCreateWithoutAssignedByInput = {
    id?: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutWorkerTasksInput
    orderHeader?: OrderHeaderCreateNestedOneWithoutWorkerTasksInput
    orderItem?: OrderItemCreateNestedOneWithoutWorkerTasksInput
    outlet: OutletCreateNestedOneWithoutWorkerTasksInput
    shift: ShiftCreateNestedOneWithoutWorkerTasksInput
    workStation: WorkStationCreateNestedOneWithoutWorkerTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutAssignedByInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutAssignedByInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput>
  }

  export type EmployeeTaskCreateManyAssignedByInputEnvelope = {
    data: EmployeeTaskCreateManyAssignedByInput | EmployeeTaskCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutApprovedByInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees: EmployeeCreateNestedOneWithoutAttendanceInput
    outlet: OutletCreateNestedOneWithoutAttendanceInput
    shift: ShiftCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutApprovedByInput = {
    id?: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutApprovedByInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput>
  }

  export type AttendanceCreateManyApprovedByInputEnvelope = {
    data: AttendanceCreateManyApprovedByInput | AttendanceCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type PickUpTaskCreateWithoutDriverInput = {
    id?: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignedBy?: EmployeeCreateNestedOneWithoutPickupAssignedByInput
    outlets: OutletCreateNestedOneWithoutPickUpTaskInput
    customerAddress: CustomerAddressCreateNestedOneWithoutPickUpTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutPickUpTaskInput
  }

  export type PickUpTaskUncheckedCreateWithoutDriverInput = {
    id?: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskCreateOrConnectWithoutDriverInput = {
    where: PickUpTaskWhereUniqueInput
    create: XOR<PickUpTaskCreateWithoutDriverInput, PickUpTaskUncheckedCreateWithoutDriverInput>
  }

  export type PickUpTaskCreateManyDriverInputEnvelope = {
    data: PickUpTaskCreateManyDriverInput | PickUpTaskCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type PickUpTaskCreateWithoutAssignedByInput = {
    id?: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutPickUpDriverInput
    outlets: OutletCreateNestedOneWithoutPickUpTaskInput
    customerAddress: CustomerAddressCreateNestedOneWithoutPickUpTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutPickUpTaskInput
  }

  export type PickUpTaskUncheckedCreateWithoutAssignedByInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskCreateOrConnectWithoutAssignedByInput = {
    where: PickUpTaskWhereUniqueInput
    create: XOR<PickUpTaskCreateWithoutAssignedByInput, PickUpTaskUncheckedCreateWithoutAssignedByInput>
  }

  export type PickUpTaskCreateManyAssignedByInputEnvelope = {
    data: PickUpTaskCreateManyAssignedByInput | PickUpTaskCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryTaskCreateWithoutDriverInput = {
    id?: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignedBy?: EmployeeCreateNestedOneWithoutDeliveryAssignedByInput
    outlets: OutletCreateNestedOneWithoutDeliveryTaskInput
    customerAddress: CustomerAddressCreateNestedOneWithoutDeliveryTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutDeliveryTaskInput
  }

  export type DeliveryTaskUncheckedCreateWithoutDriverInput = {
    id?: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateOrConnectWithoutDriverInput = {
    where: DeliveryTaskWhereUniqueInput
    create: XOR<DeliveryTaskCreateWithoutDriverInput, DeliveryTaskUncheckedCreateWithoutDriverInput>
  }

  export type DeliveryTaskCreateManyDriverInputEnvelope = {
    data: DeliveryTaskCreateManyDriverInput | DeliveryTaskCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryTaskCreateWithoutAssignedByInput = {
    id?: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutDeliveryDriverInput
    outlets: OutletCreateNestedOneWithoutDeliveryTaskInput
    customerAddress: CustomerAddressCreateNestedOneWithoutDeliveryTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutDeliveryTaskInput
  }

  export type DeliveryTaskUncheckedCreateWithoutAssignedByInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateOrConnectWithoutAssignedByInput = {
    where: DeliveryTaskWhereUniqueInput
    create: XOR<DeliveryTaskCreateWithoutAssignedByInput, DeliveryTaskUncheckedCreateWithoutAssignedByInput>
  }

  export type DeliveryTaskCreateManyAssignedByInputEnvelope = {
    data: DeliveryTaskCreateManyAssignedByInput | DeliveryTaskCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type ShiftUpsertWithoutEmployeeInput = {
    update: XOR<ShiftUpdateWithoutEmployeeInput, ShiftUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutEmployeeInput, ShiftUncheckedUpdateWithoutEmployeeInput>
  }

  export type ShiftUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUpdateManyWithoutShiftNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutShiftNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type OutletUpsertWithoutEmployeeInput = {
    update: XOR<OutletUpdateWithoutEmployeeInput, OutletUncheckedUpdateWithoutEmployeeInput>
    create: XOR<OutletCreateWithoutEmployeeInput, OutletUncheckedCreateWithoutEmployeeInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutEmployeeInput, OutletUncheckedUpdateWithoutEmployeeInput>
  }

  export type OutletUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOutletsNestedInput
  }

  export type OutletUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOutletsNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutEmployeesInput, AttendanceUncheckedUpdateWithoutEmployeesInput>
    create: XOR<AttendanceCreateWithoutEmployeesInput, AttendanceUncheckedCreateWithoutEmployeesInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutEmployeesInput, AttendanceUncheckedUpdateWithoutEmployeesInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutEmployeesInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    employeeId?: StringFilter<"Attendance"> | string
    shiftId?: StringFilter<"Attendance"> | string
    outletId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    clockInAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    clockOutAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    workMinutes?: IntNullableFilter<"Attendance"> | number | null
    lateMinutes?: IntNullableFilter<"Attendance"> | number | null
    earlyLeaveMin?: IntNullableFilter<"Attendance"> | number | null
    notes?: StringNullableFilter<"Attendance"> | string | null
    approvedById?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
  }

  export type OrderHeaderUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: OrderHeaderWhereUniqueInput
    update: XOR<OrderHeaderUpdateWithoutEmployeesInput, OrderHeaderUncheckedUpdateWithoutEmployeesInput>
    create: XOR<OrderHeaderCreateWithoutEmployeesInput, OrderHeaderUncheckedCreateWithoutEmployeesInput>
  }

  export type OrderHeaderUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: OrderHeaderWhereUniqueInput
    data: XOR<OrderHeaderUpdateWithoutEmployeesInput, OrderHeaderUncheckedUpdateWithoutEmployeesInput>
  }

  export type OrderHeaderUpdateManyWithWhereWithoutEmployeesInput = {
    where: OrderHeaderScalarWhereInput
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type WorkStationUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: WorkStationWhereUniqueInput
    update: XOR<WorkStationUpdateWithoutEmployeesInput, WorkStationUncheckedUpdateWithoutEmployeesInput>
    create: XOR<WorkStationCreateWithoutEmployeesInput, WorkStationUncheckedCreateWithoutEmployeesInput>
  }

  export type WorkStationUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: WorkStationWhereUniqueInput
    data: XOR<WorkStationUpdateWithoutEmployeesInput, WorkStationUncheckedUpdateWithoutEmployeesInput>
  }

  export type WorkStationUpdateManyWithWhereWithoutEmployeesInput = {
    where: WorkStationScalarWhereInput
    data: XOR<WorkStationUpdateManyMutationInput, WorkStationUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type WorkStationScalarWhereInput = {
    AND?: WorkStationScalarWhereInput | WorkStationScalarWhereInput[]
    OR?: WorkStationScalarWhereInput[]
    NOT?: WorkStationScalarWhereInput | WorkStationScalarWhereInput[]
    id?: StringFilter<"WorkStation"> | string
    employeeId?: StringFilter<"WorkStation"> | string
    station?: EnumStationFilter<"WorkStation"> | $Enums.Station
    createdAt?: DateTimeFilter<"WorkStation"> | Date | string
    updatedAt?: DateTimeFilter<"WorkStation"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkStation"> | Date | string | null
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutEmployeeInput, EmployeeTaskUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeTaskCreateWithoutEmployeeInput, EmployeeTaskUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutEmployeeInput, EmployeeTaskUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeTaskScalarWhereInput = {
    AND?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
    OR?: EmployeeTaskScalarWhereInput[]
    NOT?: EmployeeTaskScalarWhereInput | EmployeeTaskScalarWhereInput[]
    id?: StringFilter<"EmployeeTask"> | string
    employeeId?: StringFilter<"EmployeeTask"> | string
    orderHeaderId?: StringFilter<"EmployeeTask"> | string
    orderItemId?: StringFilter<"EmployeeTask"> | string
    outletId?: StringFilter<"EmployeeTask"> | string
    shiftId?: StringFilter<"EmployeeTask"> | string
    workStationId?: StringFilter<"EmployeeTask"> | string
    status?: EnumTaskStatusFilter<"EmployeeTask"> | $Enums.TaskStatus
    itemQty?: IntNullableFilter<"EmployeeTask"> | number | null
    itemUnit?: StringNullableFilter<"EmployeeTask"> | string | null
    bypassReqNote?: StringNullableFilter<"EmployeeTask"> | string | null
    bypassReq?: BoolNullableFilter<"EmployeeTask"> | boolean | null
    isReqAprooved?: BoolNullableFilter<"EmployeeTask"> | boolean | null
    itemPassedNote?: StringNullableFilter<"EmployeeTask"> | string | null
    assignedById?: StringNullableFilter<"EmployeeTask"> | string | null
    createdAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeTask"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmployeeTask"> | Date | string | null
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutAssignedByInput, EmployeeTaskUncheckedUpdateWithoutAssignedByInput>
    create: XOR<EmployeeTaskCreateWithoutAssignedByInput, EmployeeTaskUncheckedCreateWithoutAssignedByInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutAssignedByInput, EmployeeTaskUncheckedUpdateWithoutAssignedByInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutAssignedByInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutApprovedByInput, AttendanceUncheckedUpdateWithoutApprovedByInput>
    create: XOR<AttendanceCreateWithoutApprovedByInput, AttendanceUncheckedCreateWithoutApprovedByInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutApprovedByInput, AttendanceUncheckedUpdateWithoutApprovedByInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutApprovedByInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type PickUpTaskUpsertWithWhereUniqueWithoutDriverInput = {
    where: PickUpTaskWhereUniqueInput
    update: XOR<PickUpTaskUpdateWithoutDriverInput, PickUpTaskUncheckedUpdateWithoutDriverInput>
    create: XOR<PickUpTaskCreateWithoutDriverInput, PickUpTaskUncheckedCreateWithoutDriverInput>
  }

  export type PickUpTaskUpdateWithWhereUniqueWithoutDriverInput = {
    where: PickUpTaskWhereUniqueInput
    data: XOR<PickUpTaskUpdateWithoutDriverInput, PickUpTaskUncheckedUpdateWithoutDriverInput>
  }

  export type PickUpTaskUpdateManyWithWhereWithoutDriverInput = {
    where: PickUpTaskScalarWhereInput
    data: XOR<PickUpTaskUpdateManyMutationInput, PickUpTaskUncheckedUpdateManyWithoutDriverInput>
  }

  export type PickUpTaskUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: PickUpTaskWhereUniqueInput
    update: XOR<PickUpTaskUpdateWithoutAssignedByInput, PickUpTaskUncheckedUpdateWithoutAssignedByInput>
    create: XOR<PickUpTaskCreateWithoutAssignedByInput, PickUpTaskUncheckedCreateWithoutAssignedByInput>
  }

  export type PickUpTaskUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: PickUpTaskWhereUniqueInput
    data: XOR<PickUpTaskUpdateWithoutAssignedByInput, PickUpTaskUncheckedUpdateWithoutAssignedByInput>
  }

  export type PickUpTaskUpdateManyWithWhereWithoutAssignedByInput = {
    where: PickUpTaskScalarWhereInput
    data: XOR<PickUpTaskUpdateManyMutationInput, PickUpTaskUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type DeliveryTaskUpsertWithWhereUniqueWithoutDriverInput = {
    where: DeliveryTaskWhereUniqueInput
    update: XOR<DeliveryTaskUpdateWithoutDriverInput, DeliveryTaskUncheckedUpdateWithoutDriverInput>
    create: XOR<DeliveryTaskCreateWithoutDriverInput, DeliveryTaskUncheckedCreateWithoutDriverInput>
  }

  export type DeliveryTaskUpdateWithWhereUniqueWithoutDriverInput = {
    where: DeliveryTaskWhereUniqueInput
    data: XOR<DeliveryTaskUpdateWithoutDriverInput, DeliveryTaskUncheckedUpdateWithoutDriverInput>
  }

  export type DeliveryTaskUpdateManyWithWhereWithoutDriverInput = {
    where: DeliveryTaskScalarWhereInput
    data: XOR<DeliveryTaskUpdateManyMutationInput, DeliveryTaskUncheckedUpdateManyWithoutDriverInput>
  }

  export type DeliveryTaskUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: DeliveryTaskWhereUniqueInput
    update: XOR<DeliveryTaskUpdateWithoutAssignedByInput, DeliveryTaskUncheckedUpdateWithoutAssignedByInput>
    create: XOR<DeliveryTaskCreateWithoutAssignedByInput, DeliveryTaskUncheckedCreateWithoutAssignedByInput>
  }

  export type DeliveryTaskUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: DeliveryTaskWhereUniqueInput
    data: XOR<DeliveryTaskUpdateWithoutAssignedByInput, DeliveryTaskUncheckedUpdateWithoutAssignedByInput>
  }

  export type DeliveryTaskUpdateManyWithWhereWithoutAssignedByInput = {
    where: DeliveryTaskScalarWhereInput
    data: XOR<DeliveryTaskUpdateManyMutationInput, DeliveryTaskUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type EmployeeCreateWithoutShiftsInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutShiftsInput = {
    id?: string
    outletId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutShiftsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
  }

  export type EmployeeCreateManyShiftsInputEnvelope = {
    data: EmployeeCreateManyShiftsInput | EmployeeCreateManyShiftsInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutShiftInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees: EmployeeCreateNestedOneWithoutAttendanceInput
    outlet: OutletCreateNestedOneWithoutAttendanceInput
    approvedBy?: EmployeeCreateNestedOneWithoutApprovedAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutShiftInput = {
    id?: string
    employeeId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutShiftInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput>
  }

  export type AttendanceCreateManyShiftInputEnvelope = {
    data: AttendanceCreateManyShiftInput | AttendanceCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskCreateWithoutShiftInput = {
    id?: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutAssignedTasksInput
    orderHeader?: OrderHeaderCreateNestedOneWithoutWorkerTasksInput
    orderItem?: OrderItemCreateNestedOneWithoutWorkerTasksInput
    outlet: OutletCreateNestedOneWithoutWorkerTasksInput
    workStation: WorkStationCreateNestedOneWithoutWorkerTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutShiftInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutShiftInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutShiftInput, EmployeeTaskUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeTaskCreateManyShiftInputEnvelope = {
    data: EmployeeTaskCreateManyShiftInput | EmployeeTaskCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutShiftsInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutShiftsInput, EmployeeUncheckedUpdateWithoutShiftsInput>
    create: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutShiftsInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutShiftsInput, EmployeeUncheckedUpdateWithoutShiftsInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutShiftsInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutShiftsInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    outletId?: StringFilter<"Employee"> | string
    shiftId?: StringFilter<"Employee"> | string
    role?: EnumRoleFilter<"Employee"> | $Enums.Role
    name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    password?: StringNullableFilter<"Employee"> | string | null
    phoneNumber?: StringFilter<"Employee"> | string
    address?: StringFilter<"Employee"> | string
    photoUrl?: StringNullableFilter<"Employee"> | string | null
    isActive?: BoolFilter<"Employee"> | boolean
    resetPasswordToken?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
  }

  export type AttendanceUpsertWithWhereUniqueWithoutShiftInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutShiftInput, AttendanceUncheckedUpdateWithoutShiftInput>
    create: XOR<AttendanceCreateWithoutShiftInput, AttendanceUncheckedCreateWithoutShiftInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutShiftInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutShiftInput, AttendanceUncheckedUpdateWithoutShiftInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutShiftInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutShiftInput>
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutShiftInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutShiftInput, EmployeeTaskUncheckedUpdateWithoutShiftInput>
    create: XOR<EmployeeTaskCreateWithoutShiftInput, EmployeeTaskUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutShiftInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutShiftInput, EmployeeTaskUncheckedUpdateWithoutShiftInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutShiftInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutShiftInput>
  }

  export type EmployeeCreateWithoutWorkStationInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutWorkStationInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutWorkStationInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWorkStationInput, EmployeeUncheckedCreateWithoutWorkStationInput>
  }

  export type EmployeeTaskCreateWithoutWorkStationInput = {
    id?: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutAssignedTasksInput
    orderHeader?: OrderHeaderCreateNestedOneWithoutWorkerTasksInput
    orderItem?: OrderItemCreateNestedOneWithoutWorkerTasksInput
    outlet: OutletCreateNestedOneWithoutWorkerTasksInput
    shift: ShiftCreateNestedOneWithoutWorkerTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutWorkStationInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    shiftId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutWorkStationInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutWorkStationInput, EmployeeTaskUncheckedCreateWithoutWorkStationInput>
  }

  export type EmployeeTaskCreateManyWorkStationInputEnvelope = {
    data: EmployeeTaskCreateManyWorkStationInput | EmployeeTaskCreateManyWorkStationInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithoutWorkStationInput = {
    update: XOR<EmployeeUpdateWithoutWorkStationInput, EmployeeUncheckedUpdateWithoutWorkStationInput>
    create: XOR<EmployeeCreateWithoutWorkStationInput, EmployeeUncheckedCreateWithoutWorkStationInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWorkStationInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWorkStationInput, EmployeeUncheckedUpdateWithoutWorkStationInput>
  }

  export type EmployeeUpdateWithoutWorkStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWorkStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutWorkStationInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutWorkStationInput, EmployeeTaskUncheckedUpdateWithoutWorkStationInput>
    create: XOR<EmployeeTaskCreateWithoutWorkStationInput, EmployeeTaskUncheckedCreateWithoutWorkStationInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutWorkStationInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutWorkStationInput, EmployeeTaskUncheckedUpdateWithoutWorkStationInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutWorkStationInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutWorkStationInput>
  }

  export type EmployeeCreateWithoutWorkerTasksInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutWorkerTasksInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutWorkerTasksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWorkerTasksInput, EmployeeUncheckedCreateWithoutWorkerTasksInput>
  }

  export type EmployeeCreateWithoutAssignedTasksInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutAssignedTasksInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutAssignedTasksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAssignedTasksInput, EmployeeUncheckedCreateWithoutAssignedTasksInput>
  }

  export type OrderHeaderCreateWithoutWorkerTasksInput = {
    id?: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutOrderHeaderInput
    employees?: EmployeeCreateNestedOneWithoutOrderHeaderInput
    outlets: OutletCreateNestedOneWithoutOrderHeaderInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentCreateNestedManyWithoutOrderheaderInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUncheckedCreateWithoutWorkerTasksInput = {
    id?: string
    customerId: string
    handledById?: string | null
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutOrderheaderInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderCreateOrConnectWithoutWorkerTasksInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutWorkerTasksInput, OrderHeaderUncheckedCreateWithoutWorkerTasksInput>
  }

  export type OrderItemCreateWithoutWorkerTasksInput = {
    id?: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderheader: OrderHeaderCreateNestedOneWithoutOrderItemInput
    service: ServiceCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutWorkerTasksInput = {
    id?: string
    orderHeaderId: string
    serviceId: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemCreateOrConnectWithoutWorkerTasksInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutWorkerTasksInput, OrderItemUncheckedCreateWithoutWorkerTasksInput>
  }

  export type OutletCreateWithoutWorkerTasksInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutOutletsInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOutletsInput
  }

  export type OutletUncheckedCreateWithoutWorkerTasksInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutOutletsInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOutletsInput
  }

  export type OutletCreateOrConnectWithoutWorkerTasksInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutWorkerTasksInput, OutletUncheckedCreateWithoutWorkerTasksInput>
  }

  export type ShiftCreateWithoutWorkerTasksInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutShiftsInput
    Attendance?: AttendanceCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutWorkerTasksInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutShiftsInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutWorkerTasksInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutWorkerTasksInput, ShiftUncheckedCreateWithoutWorkerTasksInput>
  }

  export type WorkStationCreateWithoutWorkerTasksInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees: EmployeeCreateNestedOneWithoutWorkStationInput
  }

  export type WorkStationUncheckedCreateWithoutWorkerTasksInput = {
    id?: string
    employeeId: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkStationCreateOrConnectWithoutWorkerTasksInput = {
    where: WorkStationWhereUniqueInput
    create: XOR<WorkStationCreateWithoutWorkerTasksInput, WorkStationUncheckedCreateWithoutWorkerTasksInput>
  }

  export type EmployeeUpsertWithoutWorkerTasksInput = {
    update: XOR<EmployeeUpdateWithoutWorkerTasksInput, EmployeeUncheckedUpdateWithoutWorkerTasksInput>
    create: XOR<EmployeeCreateWithoutWorkerTasksInput, EmployeeUncheckedCreateWithoutWorkerTasksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWorkerTasksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWorkerTasksInput, EmployeeUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type EmployeeUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUpsertWithoutAssignedTasksInput = {
    update: XOR<EmployeeUpdateWithoutAssignedTasksInput, EmployeeUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<EmployeeCreateWithoutAssignedTasksInput, EmployeeUncheckedCreateWithoutAssignedTasksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAssignedTasksInput, EmployeeUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type EmployeeUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type OrderHeaderUpsertWithoutWorkerTasksInput = {
    update: XOR<OrderHeaderUpdateWithoutWorkerTasksInput, OrderHeaderUncheckedUpdateWithoutWorkerTasksInput>
    create: XOR<OrderHeaderCreateWithoutWorkerTasksInput, OrderHeaderUncheckedCreateWithoutWorkerTasksInput>
    where?: OrderHeaderWhereInput
  }

  export type OrderHeaderUpdateToOneWithWhereWithoutWorkerTasksInput = {
    where?: OrderHeaderWhereInput
    data: XOR<OrderHeaderUpdateWithoutWorkerTasksInput, OrderHeaderUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type OrderHeaderUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutOrderHeaderNestedInput
    employees?: EmployeeUpdateOneWithoutOrderHeaderNestedInput
    outlets?: OutletUpdateOneRequiredWithoutOrderHeaderNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUpdateManyWithoutOrderheaderNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutOrderheaderNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderItemUpsertWithoutWorkerTasksInput = {
    update: XOR<OrderItemUpdateWithoutWorkerTasksInput, OrderItemUncheckedUpdateWithoutWorkerTasksInput>
    create: XOR<OrderItemCreateWithoutWorkerTasksInput, OrderItemUncheckedCreateWithoutWorkerTasksInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutWorkerTasksInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutWorkerTasksInput, OrderItemUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type OrderItemUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderheader?: OrderHeaderUpdateOneRequiredWithoutOrderItemNestedInput
    service?: ServiceUpdateOneRequiredWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletUpsertWithoutWorkerTasksInput = {
    update: XOR<OutletUpdateWithoutWorkerTasksInput, OutletUncheckedUpdateWithoutWorkerTasksInput>
    create: XOR<OutletCreateWithoutWorkerTasksInput, OutletUncheckedCreateWithoutWorkerTasksInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutWorkerTasksInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutWorkerTasksInput, OutletUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type OutletUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutOutletsNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOutletsNestedInput
  }

  export type OutletUncheckedUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutOutletsNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOutletsNestedInput
  }

  export type ShiftUpsertWithoutWorkerTasksInput = {
    update: XOR<ShiftUpdateWithoutWorkerTasksInput, ShiftUncheckedUpdateWithoutWorkerTasksInput>
    create: XOR<ShiftCreateWithoutWorkerTasksInput, ShiftUncheckedCreateWithoutWorkerTasksInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutWorkerTasksInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutWorkerTasksInput, ShiftUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type ShiftUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutShiftsNestedInput
    Attendance?: AttendanceUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutShiftsNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type WorkStationUpsertWithoutWorkerTasksInput = {
    update: XOR<WorkStationUpdateWithoutWorkerTasksInput, WorkStationUncheckedUpdateWithoutWorkerTasksInput>
    create: XOR<WorkStationCreateWithoutWorkerTasksInput, WorkStationUncheckedCreateWithoutWorkerTasksInput>
    where?: WorkStationWhereInput
  }

  export type WorkStationUpdateToOneWithWhereWithoutWorkerTasksInput = {
    where?: WorkStationWhereInput
    data: XOR<WorkStationUpdateWithoutWorkerTasksInput, WorkStationUncheckedUpdateWithoutWorkerTasksInput>
  }

  export type WorkStationUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateOneRequiredWithoutWorkStationNestedInput
  }

  export type WorkStationUncheckedUpdateWithoutWorkerTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateWithoutPickUpDriverInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutPickUpDriverInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutPickUpDriverInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPickUpDriverInput, EmployeeUncheckedCreateWithoutPickUpDriverInput>
  }

  export type EmployeeCreateWithoutPickupAssignedByInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutPickupAssignedByInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutPickupAssignedByInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPickupAssignedByInput, EmployeeUncheckedCreateWithoutPickupAssignedByInput>
  }

  export type OutletCreateWithoutPickUpTaskInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOutletsInput
  }

  export type OutletUncheckedCreateWithoutPickUpTaskInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOutletsInput
  }

  export type OutletCreateOrConnectWithoutPickUpTaskInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutPickUpTaskInput, OutletUncheckedCreateWithoutPickUpTaskInput>
  }

  export type CustomerAddressCreateWithoutPickUpTaskInput = {
    id?: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutCustomerAddressInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUncheckedCreateWithoutPickUpTaskInput = {
    id?: string
    customerId: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressCreateOrConnectWithoutPickUpTaskInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutPickUpTaskInput, CustomerAddressUncheckedCreateWithoutPickUpTaskInput>
  }

  export type OrderHeaderCreateWithoutPickUpTaskInput = {
    id?: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutOrderHeaderInput
    employees?: EmployeeCreateNestedOneWithoutOrderHeaderInput
    outlets: OutletCreateNestedOneWithoutOrderHeaderInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUncheckedCreateWithoutPickUpTaskInput = {
    id?: string
    customerId: string
    handledById?: string | null
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderCreateOrConnectWithoutPickUpTaskInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutPickUpTaskInput, OrderHeaderUncheckedCreateWithoutPickUpTaskInput>
  }

  export type EmployeeUpsertWithoutPickUpDriverInput = {
    update: XOR<EmployeeUpdateWithoutPickUpDriverInput, EmployeeUncheckedUpdateWithoutPickUpDriverInput>
    create: XOR<EmployeeCreateWithoutPickUpDriverInput, EmployeeUncheckedCreateWithoutPickUpDriverInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPickUpDriverInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPickUpDriverInput, EmployeeUncheckedUpdateWithoutPickUpDriverInput>
  }

  export type EmployeeUpdateWithoutPickUpDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPickUpDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUpsertWithoutPickupAssignedByInput = {
    update: XOR<EmployeeUpdateWithoutPickupAssignedByInput, EmployeeUncheckedUpdateWithoutPickupAssignedByInput>
    create: XOR<EmployeeCreateWithoutPickupAssignedByInput, EmployeeUncheckedCreateWithoutPickupAssignedByInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPickupAssignedByInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPickupAssignedByInput, EmployeeUncheckedUpdateWithoutPickupAssignedByInput>
  }

  export type EmployeeUpdateWithoutPickupAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPickupAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type OutletUpsertWithoutPickUpTaskInput = {
    update: XOR<OutletUpdateWithoutPickUpTaskInput, OutletUncheckedUpdateWithoutPickUpTaskInput>
    create: XOR<OutletCreateWithoutPickUpTaskInput, OutletUncheckedCreateWithoutPickUpTaskInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutPickUpTaskInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutPickUpTaskInput, OutletUncheckedUpdateWithoutPickUpTaskInput>
  }

  export type OutletUpdateWithoutPickUpTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOutletsNestedInput
  }

  export type OutletUncheckedUpdateWithoutPickUpTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOutletsNestedInput
  }

  export type CustomerAddressUpsertWithoutPickUpTaskInput = {
    update: XOR<CustomerAddressUpdateWithoutPickUpTaskInput, CustomerAddressUncheckedUpdateWithoutPickUpTaskInput>
    create: XOR<CustomerAddressCreateWithoutPickUpTaskInput, CustomerAddressUncheckedCreateWithoutPickUpTaskInput>
    where?: CustomerAddressWhereInput
  }

  export type CustomerAddressUpdateToOneWithWhereWithoutPickUpTaskInput = {
    where?: CustomerAddressWhereInput
    data: XOR<CustomerAddressUpdateWithoutPickUpTaskInput, CustomerAddressUncheckedUpdateWithoutPickUpTaskInput>
  }

  export type CustomerAddressUpdateWithoutPickUpTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutCustomerAddressNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateWithoutPickUpTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutCustomerAddressNestedInput
  }

  export type OrderHeaderUpsertWithoutPickUpTaskInput = {
    update: XOR<OrderHeaderUpdateWithoutPickUpTaskInput, OrderHeaderUncheckedUpdateWithoutPickUpTaskInput>
    create: XOR<OrderHeaderCreateWithoutPickUpTaskInput, OrderHeaderUncheckedCreateWithoutPickUpTaskInput>
    where?: OrderHeaderWhereInput
  }

  export type OrderHeaderUpdateToOneWithWhereWithoutPickUpTaskInput = {
    where?: OrderHeaderWhereInput
    data: XOR<OrderHeaderUpdateWithoutPickUpTaskInput, OrderHeaderUncheckedUpdateWithoutPickUpTaskInput>
  }

  export type OrderHeaderUpdateWithoutPickUpTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutOrderHeaderNestedInput
    employees?: EmployeeUpdateOneWithoutOrderHeaderNestedInput
    outlets?: OutletUpdateOneRequiredWithoutOrderHeaderNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutPickUpTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
  }

  export type EmployeeCreateWithoutDeliveryDriverInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutDeliveryDriverInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutDeliveryDriverInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDeliveryDriverInput, EmployeeUncheckedCreateWithoutDeliveryDriverInput>
  }

  export type EmployeeCreateWithoutDeliveryAssignedByInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
  }

  export type EmployeeUncheckedCreateWithoutDeliveryAssignedByInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
  }

  export type EmployeeCreateOrConnectWithoutDeliveryAssignedByInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDeliveryAssignedByInput, EmployeeUncheckedCreateWithoutDeliveryAssignedByInput>
  }

  export type OutletCreateWithoutDeliveryTaskInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOutletsInput
  }

  export type OutletUncheckedCreateWithoutDeliveryTaskInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOutletsInput
  }

  export type OutletCreateOrConnectWithoutDeliveryTaskInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutDeliveryTaskInput, OutletUncheckedCreateWithoutDeliveryTaskInput>
  }

  export type CustomerAddressCreateWithoutDeliveryTaskInput = {
    id?: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutCustomerAddressInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressUncheckedCreateWithoutDeliveryTaskInput = {
    id?: string
    customerId: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutCustomerAddressInput
  }

  export type CustomerAddressCreateOrConnectWithoutDeliveryTaskInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutDeliveryTaskInput, CustomerAddressUncheckedCreateWithoutDeliveryTaskInput>
  }

  export type OrderHeaderCreateWithoutDeliveryTaskInput = {
    id?: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutOrderHeaderInput
    employees?: EmployeeCreateNestedOneWithoutOrderHeaderInput
    outlets: OutletCreateNestedOneWithoutOrderHeaderInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUncheckedCreateWithoutDeliveryTaskInput = {
    id?: string
    customerId: string
    handledById?: string | null
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderCreateOrConnectWithoutDeliveryTaskInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutDeliveryTaskInput, OrderHeaderUncheckedCreateWithoutDeliveryTaskInput>
  }

  export type EmployeeUpsertWithoutDeliveryDriverInput = {
    update: XOR<EmployeeUpdateWithoutDeliveryDriverInput, EmployeeUncheckedUpdateWithoutDeliveryDriverInput>
    create: XOR<EmployeeCreateWithoutDeliveryDriverInput, EmployeeUncheckedCreateWithoutDeliveryDriverInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDeliveryDriverInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDeliveryDriverInput, EmployeeUncheckedUpdateWithoutDeliveryDriverInput>
  }

  export type EmployeeUpdateWithoutDeliveryDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDeliveryDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUpsertWithoutDeliveryAssignedByInput = {
    update: XOR<EmployeeUpdateWithoutDeliveryAssignedByInput, EmployeeUncheckedUpdateWithoutDeliveryAssignedByInput>
    create: XOR<EmployeeCreateWithoutDeliveryAssignedByInput, EmployeeUncheckedCreateWithoutDeliveryAssignedByInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDeliveryAssignedByInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDeliveryAssignedByInput, EmployeeUncheckedUpdateWithoutDeliveryAssignedByInput>
  }

  export type EmployeeUpdateWithoutDeliveryAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDeliveryAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type OutletUpsertWithoutDeliveryTaskInput = {
    update: XOR<OutletUpdateWithoutDeliveryTaskInput, OutletUncheckedUpdateWithoutDeliveryTaskInput>
    create: XOR<OutletCreateWithoutDeliveryTaskInput, OutletUncheckedCreateWithoutDeliveryTaskInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutDeliveryTaskInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutDeliveryTaskInput, OutletUncheckedUpdateWithoutDeliveryTaskInput>
  }

  export type OutletUpdateWithoutDeliveryTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOutletsNestedInput
  }

  export type OutletUncheckedUpdateWithoutDeliveryTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOutletsNestedInput
  }

  export type CustomerAddressUpsertWithoutDeliveryTaskInput = {
    update: XOR<CustomerAddressUpdateWithoutDeliveryTaskInput, CustomerAddressUncheckedUpdateWithoutDeliveryTaskInput>
    create: XOR<CustomerAddressCreateWithoutDeliveryTaskInput, CustomerAddressUncheckedCreateWithoutDeliveryTaskInput>
    where?: CustomerAddressWhereInput
  }

  export type CustomerAddressUpdateToOneWithWhereWithoutDeliveryTaskInput = {
    where?: CustomerAddressWhereInput
    data: XOR<CustomerAddressUpdateWithoutDeliveryTaskInput, CustomerAddressUncheckedUpdateWithoutDeliveryTaskInput>
  }

  export type CustomerAddressUpdateWithoutDeliveryTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutCustomerAddressNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateWithoutDeliveryTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutCustomerAddressNestedInput
  }

  export type OrderHeaderUpsertWithoutDeliveryTaskInput = {
    update: XOR<OrderHeaderUpdateWithoutDeliveryTaskInput, OrderHeaderUncheckedUpdateWithoutDeliveryTaskInput>
    create: XOR<OrderHeaderCreateWithoutDeliveryTaskInput, OrderHeaderUncheckedCreateWithoutDeliveryTaskInput>
    where?: OrderHeaderWhereInput
  }

  export type OrderHeaderUpdateToOneWithWhereWithoutDeliveryTaskInput = {
    where?: OrderHeaderWhereInput
    data: XOR<OrderHeaderUpdateWithoutDeliveryTaskInput, OrderHeaderUncheckedUpdateWithoutDeliveryTaskInput>
  }

  export type OrderHeaderUpdateWithoutDeliveryTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutOrderHeaderNestedInput
    employees?: EmployeeUpdateOneWithoutOrderHeaderNestedInput
    outlets?: OutletUpdateOneRequiredWithoutOrderHeaderNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutDeliveryTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
  }

  export type EmployeeCreateWithoutAttendanceInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutAttendanceInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutAttendanceInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
  }

  export type OutletCreateWithoutAttendanceInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutOutletsInput
    OutletSchedule?: OutletScheduleCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOutletsInput
  }

  export type OutletUncheckedCreateWithoutAttendanceInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutOutletsInput
    OutletSchedule?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOutletsInput
  }

  export type OutletCreateOrConnectWithoutAttendanceInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutAttendanceInput, OutletUncheckedCreateWithoutAttendanceInput>
  }

  export type EmployeeCreateWithoutApprovedAttendancesInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutApprovedAttendancesInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutApprovedAttendancesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutApprovedAttendancesInput, EmployeeUncheckedCreateWithoutApprovedAttendancesInput>
  }

  export type ShiftCreateWithoutAttendanceInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutShiftsInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutAttendanceInput = {
    id?: string
    name: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutShiftsInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutAttendanceInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutAttendanceInput, ShiftUncheckedCreateWithoutAttendanceInput>
  }

  export type EmployeeUpsertWithoutAttendanceInput = {
    update: XOR<EmployeeUpdateWithoutAttendanceInput, EmployeeUncheckedUpdateWithoutAttendanceInput>
    create: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendanceInput, EmployeeUncheckedUpdateWithoutAttendanceInput>
  }

  export type EmployeeUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type OutletUpsertWithoutAttendanceInput = {
    update: XOR<OutletUpdateWithoutAttendanceInput, OutletUncheckedUpdateWithoutAttendanceInput>
    create: XOR<OutletCreateWithoutAttendanceInput, OutletUncheckedCreateWithoutAttendanceInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutAttendanceInput, OutletUncheckedUpdateWithoutAttendanceInput>
  }

  export type OutletUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutOutletsNestedInput
    OutletSchedule?: OutletScheduleUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOutletsNestedInput
  }

  export type OutletUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutOutletsNestedInput
    OutletSchedule?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOutletsNestedInput
  }

  export type EmployeeUpsertWithoutApprovedAttendancesInput = {
    update: XOR<EmployeeUpdateWithoutApprovedAttendancesInput, EmployeeUncheckedUpdateWithoutApprovedAttendancesInput>
    create: XOR<EmployeeCreateWithoutApprovedAttendancesInput, EmployeeUncheckedCreateWithoutApprovedAttendancesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutApprovedAttendancesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutApprovedAttendancesInput, EmployeeUncheckedUpdateWithoutApprovedAttendancesInput>
  }

  export type EmployeeUpdateWithoutApprovedAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutApprovedAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type ShiftUpsertWithoutAttendanceInput = {
    update: XOR<ShiftUpdateWithoutAttendanceInput, ShiftUncheckedUpdateWithoutAttendanceInput>
    create: XOR<ShiftCreateWithoutAttendanceInput, ShiftUncheckedCreateWithoutAttendanceInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutAttendanceInput, ShiftUncheckedUpdateWithoutAttendanceInput>
  }

  export type ShiftUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutShiftsNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutShiftsNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type EmployeeCreateWithoutOutletsInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutOutletsInput = {
    id?: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutOutletsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutOutletsInput, EmployeeUncheckedCreateWithoutOutletsInput>
  }

  export type EmployeeCreateManyOutletsInputEnvelope = {
    data: EmployeeCreateManyOutletsInput | EmployeeCreateManyOutletsInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutOutletInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees: EmployeeCreateNestedOneWithoutAttendanceInput
    approvedBy?: EmployeeCreateNestedOneWithoutApprovedAttendancesInput
    shift: ShiftCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutOutletInput = {
    id?: string
    employeeId: string
    shiftId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutOutletInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput>
  }

  export type AttendanceCreateManyOutletInputEnvelope = {
    data: AttendanceCreateManyOutletInput | AttendanceCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type OutletScheduleCreateWithoutOutletInput = {
    id?: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleUncheckedCreateWithoutOutletInput = {
    id?: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleCreateOrConnectWithoutOutletInput = {
    where: OutletScheduleWhereUniqueInput
    create: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput>
  }

  export type OutletScheduleCreateManyOutletInputEnvelope = {
    data: OutletScheduleCreateManyOutletInput | OutletScheduleCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type OrderHeaderCreateWithoutOutletsInput = {
    id?: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutOrderHeaderInput
    employees?: EmployeeCreateNestedOneWithoutOrderHeaderInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUncheckedCreateWithoutOutletsInput = {
    id?: string
    customerId: string
    handledById?: string | null
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderheaderInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderCreateOrConnectWithoutOutletsInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutOutletsInput, OrderHeaderUncheckedCreateWithoutOutletsInput>
  }

  export type OrderHeaderCreateManyOutletsInputEnvelope = {
    data: OrderHeaderCreateManyOutletsInput | OrderHeaderCreateManyOutletsInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskCreateWithoutOutletInput = {
    id?: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutAssignedTasksInput
    orderHeader?: OrderHeaderCreateNestedOneWithoutWorkerTasksInput
    orderItem?: OrderItemCreateNestedOneWithoutWorkerTasksInput
    shift: ShiftCreateNestedOneWithoutWorkerTasksInput
    workStation: WorkStationCreateNestedOneWithoutWorkerTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutOutletInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutOutletInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput>
  }

  export type EmployeeTaskCreateManyOutletInputEnvelope = {
    data: EmployeeTaskCreateManyOutletInput | EmployeeTaskCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type PickUpTaskCreateWithoutOutletsInput = {
    id?: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutPickUpDriverInput
    assignedBy?: EmployeeCreateNestedOneWithoutPickupAssignedByInput
    customerAddress: CustomerAddressCreateNestedOneWithoutPickUpTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutPickUpTaskInput
  }

  export type PickUpTaskUncheckedCreateWithoutOutletsInput = {
    id?: string
    driverId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskCreateOrConnectWithoutOutletsInput = {
    where: PickUpTaskWhereUniqueInput
    create: XOR<PickUpTaskCreateWithoutOutletsInput, PickUpTaskUncheckedCreateWithoutOutletsInput>
  }

  export type PickUpTaskCreateManyOutletsInputEnvelope = {
    data: PickUpTaskCreateManyOutletsInput | PickUpTaskCreateManyOutletsInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryTaskCreateWithoutOutletsInput = {
    id?: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutDeliveryDriverInput
    assignedBy?: EmployeeCreateNestedOneWithoutDeliveryAssignedByInput
    customerAddress: CustomerAddressCreateNestedOneWithoutDeliveryTaskInput
    orderHeader: OrderHeaderCreateNestedOneWithoutDeliveryTaskInput
  }

  export type DeliveryTaskUncheckedCreateWithoutOutletsInput = {
    id?: string
    driverId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateOrConnectWithoutOutletsInput = {
    where: DeliveryTaskWhereUniqueInput
    create: XOR<DeliveryTaskCreateWithoutOutletsInput, DeliveryTaskUncheckedCreateWithoutOutletsInput>
  }

  export type DeliveryTaskCreateManyOutletsInputEnvelope = {
    data: DeliveryTaskCreateManyOutletsInput | DeliveryTaskCreateManyOutletsInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutOutletsInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutOutletsInput, EmployeeUncheckedUpdateWithoutOutletsInput>
    create: XOR<EmployeeCreateWithoutOutletsInput, EmployeeUncheckedCreateWithoutOutletsInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutOutletsInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutOutletsInput, EmployeeUncheckedUpdateWithoutOutletsInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutOutletsInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutOutletsInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutOutletInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutOutletInput, AttendanceUncheckedUpdateWithoutOutletInput>
    create: XOR<AttendanceCreateWithoutOutletInput, AttendanceUncheckedCreateWithoutOutletInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutOutletInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutOutletInput, AttendanceUncheckedUpdateWithoutOutletInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutOutletInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutOutletInput>
  }

  export type OutletScheduleUpsertWithWhereUniqueWithoutOutletInput = {
    where: OutletScheduleWhereUniqueInput
    update: XOR<OutletScheduleUpdateWithoutOutletInput, OutletScheduleUncheckedUpdateWithoutOutletInput>
    create: XOR<OutletScheduleCreateWithoutOutletInput, OutletScheduleUncheckedCreateWithoutOutletInput>
  }

  export type OutletScheduleUpdateWithWhereUniqueWithoutOutletInput = {
    where: OutletScheduleWhereUniqueInput
    data: XOR<OutletScheduleUpdateWithoutOutletInput, OutletScheduleUncheckedUpdateWithoutOutletInput>
  }

  export type OutletScheduleUpdateManyWithWhereWithoutOutletInput = {
    where: OutletScheduleScalarWhereInput
    data: XOR<OutletScheduleUpdateManyMutationInput, OutletScheduleUncheckedUpdateManyWithoutOutletInput>
  }

  export type OutletScheduleScalarWhereInput = {
    AND?: OutletScheduleScalarWhereInput | OutletScheduleScalarWhereInput[]
    OR?: OutletScheduleScalarWhereInput[]
    NOT?: OutletScheduleScalarWhereInput | OutletScheduleScalarWhereInput[]
    id?: StringFilter<"OutletSchedule"> | string
    outletId?: StringFilter<"OutletSchedule"> | string
    detailDays?: StringFilter<"OutletSchedule"> | string
    openHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    closeHour?: DateTimeFilter<"OutletSchedule"> | Date | string
    createdAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OutletSchedule"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OutletSchedule"> | Date | string | null
  }

  export type OrderHeaderUpsertWithWhereUniqueWithoutOutletsInput = {
    where: OrderHeaderWhereUniqueInput
    update: XOR<OrderHeaderUpdateWithoutOutletsInput, OrderHeaderUncheckedUpdateWithoutOutletsInput>
    create: XOR<OrderHeaderCreateWithoutOutletsInput, OrderHeaderUncheckedCreateWithoutOutletsInput>
  }

  export type OrderHeaderUpdateWithWhereUniqueWithoutOutletsInput = {
    where: OrderHeaderWhereUniqueInput
    data: XOR<OrderHeaderUpdateWithoutOutletsInput, OrderHeaderUncheckedUpdateWithoutOutletsInput>
  }

  export type OrderHeaderUpdateManyWithWhereWithoutOutletsInput = {
    where: OrderHeaderScalarWhereInput
    data: XOR<OrderHeaderUpdateManyMutationInput, OrderHeaderUncheckedUpdateManyWithoutOutletsInput>
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutOutletInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutOutletInput, EmployeeTaskUncheckedUpdateWithoutOutletInput>
    create: XOR<EmployeeTaskCreateWithoutOutletInput, EmployeeTaskUncheckedCreateWithoutOutletInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutOutletInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutOutletInput, EmployeeTaskUncheckedUpdateWithoutOutletInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutOutletInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutOutletInput>
  }

  export type PickUpTaskUpsertWithWhereUniqueWithoutOutletsInput = {
    where: PickUpTaskWhereUniqueInput
    update: XOR<PickUpTaskUpdateWithoutOutletsInput, PickUpTaskUncheckedUpdateWithoutOutletsInput>
    create: XOR<PickUpTaskCreateWithoutOutletsInput, PickUpTaskUncheckedCreateWithoutOutletsInput>
  }

  export type PickUpTaskUpdateWithWhereUniqueWithoutOutletsInput = {
    where: PickUpTaskWhereUniqueInput
    data: XOR<PickUpTaskUpdateWithoutOutletsInput, PickUpTaskUncheckedUpdateWithoutOutletsInput>
  }

  export type PickUpTaskUpdateManyWithWhereWithoutOutletsInput = {
    where: PickUpTaskScalarWhereInput
    data: XOR<PickUpTaskUpdateManyMutationInput, PickUpTaskUncheckedUpdateManyWithoutOutletsInput>
  }

  export type DeliveryTaskUpsertWithWhereUniqueWithoutOutletsInput = {
    where: DeliveryTaskWhereUniqueInput
    update: XOR<DeliveryTaskUpdateWithoutOutletsInput, DeliveryTaskUncheckedUpdateWithoutOutletsInput>
    create: XOR<DeliveryTaskCreateWithoutOutletsInput, DeliveryTaskUncheckedCreateWithoutOutletsInput>
  }

  export type DeliveryTaskUpdateWithWhereUniqueWithoutOutletsInput = {
    where: DeliveryTaskWhereUniqueInput
    data: XOR<DeliveryTaskUpdateWithoutOutletsInput, DeliveryTaskUncheckedUpdateWithoutOutletsInput>
  }

  export type DeliveryTaskUpdateManyWithWhereWithoutOutletsInput = {
    where: DeliveryTaskScalarWhereInput
    data: XOR<DeliveryTaskUpdateManyMutationInput, DeliveryTaskUncheckedUpdateManyWithoutOutletsInput>
  }

  export type OutletCreateWithoutOutletScheduleInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOutletsInput
  }

  export type OutletUncheckedCreateWithoutOutletScheduleInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    orderHeader?: OrderHeaderUncheckedCreateNestedManyWithoutOutletsInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOutletsInput
  }

  export type OutletCreateOrConnectWithoutOutletScheduleInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutOutletScheduleInput, OutletUncheckedCreateWithoutOutletScheduleInput>
  }

  export type OutletUpsertWithoutOutletScheduleInput = {
    update: XOR<OutletUpdateWithoutOutletScheduleInput, OutletUncheckedUpdateWithoutOutletScheduleInput>
    create: XOR<OutletCreateWithoutOutletScheduleInput, OutletUncheckedCreateWithoutOutletScheduleInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutOutletScheduleInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutOutletScheduleInput, OutletUncheckedUpdateWithoutOutletScheduleInput>
  }

  export type OutletUpdateWithoutOutletScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOutletsNestedInput
  }

  export type OutletUncheckedUpdateWithoutOutletScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutOutletsNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOutletsNestedInput
  }

  export type ServiceCreateWithoutServiceCatIdInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    etaHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceCatIdInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    etaHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceCatIdInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceCatIdInput, ServiceUncheckedCreateWithoutServiceCatIdInput>
  }

  export type ServiceCreateManyServiceCatIdInputEnvelope = {
    data: ServiceCreateManyServiceCatIdInput | ServiceCreateManyServiceCatIdInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutServiceCatIdInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutServiceCatIdInput, ServiceUncheckedUpdateWithoutServiceCatIdInput>
    create: XOR<ServiceCreateWithoutServiceCatIdInput, ServiceUncheckedCreateWithoutServiceCatIdInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutServiceCatIdInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutServiceCatIdInput, ServiceUncheckedUpdateWithoutServiceCatIdInput>
  }

  export type ServiceUpdateManyWithWhereWithoutServiceCatIdInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServiceCatIdInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    serviceCategoryId?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    unit?: StringFilter<"Service"> | string
    basePrice?: IntFilter<"Service"> | number
    minQty?: IntFilter<"Service"> | number
    etaHours?: IntFilter<"Service"> | number
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
  }

  export type ServiceCategoryCreateWithoutServiceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceCategoryUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceCategoryCreateOrConnectWithoutServiceInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutServiceInput, ServiceCategoryUncheckedCreateWithoutServiceInput>
  }

  export type OrderItemCreateWithoutServiceInput = {
    id?: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orderheader: OrderHeaderCreateNestedOneWithoutOrderItemInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutServiceInput = {
    id?: string
    orderHeaderId: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutServiceInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput>
  }

  export type OrderItemCreateManyServiceInputEnvelope = {
    data: OrderItemCreateManyServiceInput | OrderItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCategoryUpsertWithoutServiceInput = {
    update: XOR<ServiceCategoryUpdateWithoutServiceInput, ServiceCategoryUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceCategoryCreateWithoutServiceInput, ServiceCategoryUncheckedCreateWithoutServiceInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutServiceInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutServiceInput, ServiceCategoryUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceCategoryUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCategoryUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutServiceInput, OrderItemUncheckedUpdateWithoutServiceInput>
    create: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutServiceInput, OrderItemUncheckedUpdateWithoutServiceInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutServiceInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderHeaderId?: StringFilter<"OrderItem"> | string
    serviceId?: StringFilter<"OrderItem"> | string
    qty?: IntFilter<"OrderItem"> | number
    unitPrice?: IntFilter<"OrderItem"> | number
    subTotal?: IntFilter<"OrderItem"> | number
    note?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    deletedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
  }

  export type CustomerCreateWithoutOrderHeaderInput = {
    id?: string
    role?: $Enums.Role
    name?: string | null
    email: string
    password?: string | null
    phoneNumber?: string | null
    photoUrl?: string | null
    isVerified?: boolean
    selectProvider?: $Enums.OAuthProvider | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiresAt?: Date | string | null
    verifyToken?: string | null
    verifyTokenExpiresAt?: Date | string | null
    pendingEmail?: string | null
    pendingEmailToken?: string | null
    pendingEmailTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerAddress?: CustomerAddressCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutOrderHeaderInput = {
    id?: string
    role?: $Enums.Role
    name?: string | null
    email: string
    password?: string | null
    phoneNumber?: string | null
    photoUrl?: string | null
    isVerified?: boolean
    selectProvider?: $Enums.OAuthProvider | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiresAt?: Date | string | null
    verifyToken?: string | null
    verifyTokenExpiresAt?: Date | string | null
    pendingEmail?: string | null
    pendingEmailToken?: string | null
    pendingEmailTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerAddress?: CustomerAddressUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutOrderHeaderInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrderHeaderInput, CustomerUncheckedCreateWithoutOrderHeaderInput>
  }

  export type EmployeeCreateWithoutOrderHeaderInput = {
    id?: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shifts: ShiftCreateNestedOneWithoutEmployeeInput
    outlets: OutletCreateNestedOneWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeUncheckedCreateWithoutOrderHeaderInput = {
    id?: string
    outletId: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeesInput
    WorkStation?: WorkStationUncheckedCreateNestedManyWithoutEmployeesInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutEmployeeInput
    assignedTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutAssignedByInput
    approvedAttendances?: AttendanceUncheckedCreateNestedManyWithoutApprovedByInput
    pickUpDriver?: PickUpTaskUncheckedCreateNestedManyWithoutDriverInput
    pickupAssignedBy?: PickUpTaskUncheckedCreateNestedManyWithoutAssignedByInput
    deliveryDriver?: DeliveryTaskUncheckedCreateNestedManyWithoutDriverInput
    deliveryAssignedBy?: DeliveryTaskUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type EmployeeCreateOrConnectWithoutOrderHeaderInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutOrderHeaderInput, EmployeeUncheckedCreateWithoutOrderHeaderInput>
  }

  export type OutletCreateWithoutOrderHeaderInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleCreateNestedManyWithoutOutletInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOutletsInput
  }

  export type OutletUncheckedCreateWithoutOrderHeaderInput = {
    id?: string
    name: string
    address: string
    phoneNumber: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    coverageArea: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Employee?: EmployeeUncheckedCreateNestedManyWithoutOutletsInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutOutletInput
    OutletSchedule?: OutletScheduleUncheckedCreateNestedManyWithoutOutletInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOutletInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOutletsInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOutletsInput
  }

  export type OutletCreateOrConnectWithoutOrderHeaderInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutOrderHeaderInput, OutletUncheckedCreateWithoutOrderHeaderInput>
  }

  export type OrderItemCreateWithoutOrderheaderInput = {
    id?: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    service: ServiceCreateNestedOneWithoutOrderItemInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderheaderInput = {
    id?: string
    serviceId: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderheaderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderheaderInput, OrderItemUncheckedCreateWithoutOrderheaderInput>
  }

  export type OrderItemCreateManyOrderheaderInputEnvelope = {
    data: OrderItemCreateManyOrderheaderInput | OrderItemCreateManyOrderheaderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderheaderInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: number
    status?: $Enums.PaymentStatus
    providerRef: string
    paidAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentUncheckedCreateWithoutOrderheaderInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: number
    status?: $Enums.PaymentStatus
    providerRef: string
    paidAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutOrderheaderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderheaderInput, PaymentUncheckedCreateWithoutOrderheaderInput>
  }

  export type PaymentCreateManyOrderheaderInputEnvelope = {
    data: PaymentCreateManyOrderheaderInput | PaymentCreateManyOrderheaderInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeTaskCreateWithoutOrderHeaderInput = {
    id?: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutAssignedTasksInput
    orderItem?: OrderItemCreateNestedOneWithoutWorkerTasksInput
    outlet: OutletCreateNestedOneWithoutWorkerTasksInput
    shift: ShiftCreateNestedOneWithoutWorkerTasksInput
    workStation: WorkStationCreateNestedOneWithoutWorkerTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutOrderHeaderInput = {
    id?: string
    employeeId: string
    orderItemId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutOrderHeaderInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutOrderHeaderInput, EmployeeTaskUncheckedCreateWithoutOrderHeaderInput>
  }

  export type EmployeeTaskCreateManyOrderHeaderInputEnvelope = {
    data: EmployeeTaskCreateManyOrderHeaderInput | EmployeeTaskCreateManyOrderHeaderInput[]
    skipDuplicates?: boolean
  }

  export type PickUpTaskCreateWithoutOrderHeaderInput = {
    id?: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutPickUpDriverInput
    assignedBy?: EmployeeCreateNestedOneWithoutPickupAssignedByInput
    outlets: OutletCreateNestedOneWithoutPickUpTaskInput
    customerAddress: CustomerAddressCreateNestedOneWithoutPickUpTaskInput
  }

  export type PickUpTaskUncheckedCreateWithoutOrderHeaderInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskCreateOrConnectWithoutOrderHeaderInput = {
    where: PickUpTaskWhereUniqueInput
    create: XOR<PickUpTaskCreateWithoutOrderHeaderInput, PickUpTaskUncheckedCreateWithoutOrderHeaderInput>
  }

  export type PickUpTaskCreateManyOrderHeaderInputEnvelope = {
    data: PickUpTaskCreateManyOrderHeaderInput | PickUpTaskCreateManyOrderHeaderInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryTaskCreateWithoutOrderHeaderInput = {
    id?: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    driver: EmployeeCreateNestedOneWithoutDeliveryDriverInput
    assignedBy?: EmployeeCreateNestedOneWithoutDeliveryAssignedByInput
    outlets: OutletCreateNestedOneWithoutDeliveryTaskInput
    customerAddress: CustomerAddressCreateNestedOneWithoutDeliveryTaskInput
  }

  export type DeliveryTaskUncheckedCreateWithoutOrderHeaderInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateOrConnectWithoutOrderHeaderInput = {
    where: DeliveryTaskWhereUniqueInput
    create: XOR<DeliveryTaskCreateWithoutOrderHeaderInput, DeliveryTaskUncheckedCreateWithoutOrderHeaderInput>
  }

  export type DeliveryTaskCreateManyOrderHeaderInputEnvelope = {
    data: DeliveryTaskCreateManyOrderHeaderInput | DeliveryTaskCreateManyOrderHeaderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutOrderHeaderInput = {
    update: XOR<CustomerUpdateWithoutOrderHeaderInput, CustomerUncheckedUpdateWithoutOrderHeaderInput>
    create: XOR<CustomerCreateWithoutOrderHeaderInput, CustomerUncheckedCreateWithoutOrderHeaderInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrderHeaderInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrderHeaderInput, CustomerUncheckedUpdateWithoutOrderHeaderInput>
  }

  export type CustomerUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    selectProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAddress?: CustomerAddressUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    selectProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    verifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    pendingEmailTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAddress?: CustomerAddressUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type EmployeeUpsertWithoutOrderHeaderInput = {
    update: XOR<EmployeeUpdateWithoutOrderHeaderInput, EmployeeUncheckedUpdateWithoutOrderHeaderInput>
    create: XOR<EmployeeCreateWithoutOrderHeaderInput, EmployeeUncheckedCreateWithoutOrderHeaderInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutOrderHeaderInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutOrderHeaderInput, EmployeeUncheckedUpdateWithoutOrderHeaderInput>
  }

  export type EmployeeUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type OutletUpsertWithoutOrderHeaderInput = {
    update: XOR<OutletUpdateWithoutOrderHeaderInput, OutletUncheckedUpdateWithoutOrderHeaderInput>
    create: XOR<OutletCreateWithoutOrderHeaderInput, OutletUncheckedCreateWithoutOrderHeaderInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutOrderHeaderInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutOrderHeaderInput, OutletUncheckedUpdateWithoutOrderHeaderInput>
  }

  export type OutletUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUpdateManyWithoutOutletNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOutletsNestedInput
  }

  export type OutletUncheckedUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    coverageArea?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUncheckedUpdateManyWithoutOutletsNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutOutletNestedInput
    OutletSchedule?: OutletScheduleUncheckedUpdateManyWithoutOutletNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOutletNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOutletsNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOutletsNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderheaderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderheaderInput, OrderItemUncheckedUpdateWithoutOrderheaderInput>
    create: XOR<OrderItemCreateWithoutOrderheaderInput, OrderItemUncheckedCreateWithoutOrderheaderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderheaderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderheaderInput, OrderItemUncheckedUpdateWithoutOrderheaderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderheaderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderheaderInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderheaderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderheaderInput, PaymentUncheckedUpdateWithoutOrderheaderInput>
    create: XOR<PaymentCreateWithoutOrderheaderInput, PaymentUncheckedCreateWithoutOrderheaderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderheaderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderheaderInput, PaymentUncheckedUpdateWithoutOrderheaderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderheaderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderheaderInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderHeaderId?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: IntFilter<"Payment"> | number
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    providerRef?: StringFilter<"Payment"> | string
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutOrderHeaderInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutOrderHeaderInput, EmployeeTaskUncheckedUpdateWithoutOrderHeaderInput>
    create: XOR<EmployeeTaskCreateWithoutOrderHeaderInput, EmployeeTaskUncheckedCreateWithoutOrderHeaderInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutOrderHeaderInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutOrderHeaderInput, EmployeeTaskUncheckedUpdateWithoutOrderHeaderInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutOrderHeaderInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderInput>
  }

  export type PickUpTaskUpsertWithWhereUniqueWithoutOrderHeaderInput = {
    where: PickUpTaskWhereUniqueInput
    update: XOR<PickUpTaskUpdateWithoutOrderHeaderInput, PickUpTaskUncheckedUpdateWithoutOrderHeaderInput>
    create: XOR<PickUpTaskCreateWithoutOrderHeaderInput, PickUpTaskUncheckedCreateWithoutOrderHeaderInput>
  }

  export type PickUpTaskUpdateWithWhereUniqueWithoutOrderHeaderInput = {
    where: PickUpTaskWhereUniqueInput
    data: XOR<PickUpTaskUpdateWithoutOrderHeaderInput, PickUpTaskUncheckedUpdateWithoutOrderHeaderInput>
  }

  export type PickUpTaskUpdateManyWithWhereWithoutOrderHeaderInput = {
    where: PickUpTaskScalarWhereInput
    data: XOR<PickUpTaskUpdateManyMutationInput, PickUpTaskUncheckedUpdateManyWithoutOrderHeaderInput>
  }

  export type DeliveryTaskUpsertWithWhereUniqueWithoutOrderHeaderInput = {
    where: DeliveryTaskWhereUniqueInput
    update: XOR<DeliveryTaskUpdateWithoutOrderHeaderInput, DeliveryTaskUncheckedUpdateWithoutOrderHeaderInput>
    create: XOR<DeliveryTaskCreateWithoutOrderHeaderInput, DeliveryTaskUncheckedCreateWithoutOrderHeaderInput>
  }

  export type DeliveryTaskUpdateWithWhereUniqueWithoutOrderHeaderInput = {
    where: DeliveryTaskWhereUniqueInput
    data: XOR<DeliveryTaskUpdateWithoutOrderHeaderInput, DeliveryTaskUncheckedUpdateWithoutOrderHeaderInput>
  }

  export type DeliveryTaskUpdateManyWithWhereWithoutOrderHeaderInput = {
    where: DeliveryTaskScalarWhereInput
    data: XOR<DeliveryTaskUpdateManyMutationInput, DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderInput>
  }

  export type OrderHeaderCreateWithoutOrderItemInput = {
    id?: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutOrderHeaderInput
    employees?: EmployeeCreateNestedOneWithoutOrderHeaderInput
    outlets: OutletCreateNestedOneWithoutOrderHeaderInput
    Payment?: PaymentCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUncheckedCreateWithoutOrderItemInput = {
    id?: string
    customerId: string
    handledById?: string | null
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Payment?: PaymentUncheckedCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderCreateOrConnectWithoutOrderItemInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutOrderItemInput, OrderHeaderUncheckedCreateWithoutOrderItemInput>
  }

  export type ServiceCreateWithoutOrderItemInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    etaHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    serviceCatId: ServiceCategoryCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutOrderItemInput = {
    id?: string
    serviceCategoryId: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    etaHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceCreateOrConnectWithoutOrderItemInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutOrderItemInput, ServiceUncheckedCreateWithoutOrderItemInput>
  }

  export type EmployeeTaskCreateWithoutOrderItemInput = {
    id?: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutWorkerTasksInput
    assignedBy?: EmployeeCreateNestedOneWithoutAssignedTasksInput
    orderHeader?: OrderHeaderCreateNestedOneWithoutWorkerTasksInput
    outlet: OutletCreateNestedOneWithoutWorkerTasksInput
    shift: ShiftCreateNestedOneWithoutWorkerTasksInput
    workStation: WorkStationCreateNestedOneWithoutWorkerTasksInput
  }

  export type EmployeeTaskUncheckedCreateWithoutOrderItemInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateOrConnectWithoutOrderItemInput = {
    where: EmployeeTaskWhereUniqueInput
    create: XOR<EmployeeTaskCreateWithoutOrderItemInput, EmployeeTaskUncheckedCreateWithoutOrderItemInput>
  }

  export type EmployeeTaskCreateManyOrderItemInputEnvelope = {
    data: EmployeeTaskCreateManyOrderItemInput | EmployeeTaskCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type OrderHeaderUpsertWithoutOrderItemInput = {
    update: XOR<OrderHeaderUpdateWithoutOrderItemInput, OrderHeaderUncheckedUpdateWithoutOrderItemInput>
    create: XOR<OrderHeaderCreateWithoutOrderItemInput, OrderHeaderUncheckedCreateWithoutOrderItemInput>
    where?: OrderHeaderWhereInput
  }

  export type OrderHeaderUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: OrderHeaderWhereInput
    data: XOR<OrderHeaderUpdateWithoutOrderItemInput, OrderHeaderUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderHeaderUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutOrderHeaderNestedInput
    employees?: EmployeeUpdateOneWithoutOrderHeaderNestedInput
    outlets?: OutletUpdateOneRequiredWithoutOrderHeaderNestedInput
    Payment?: PaymentUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Payment?: PaymentUncheckedUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
  }

  export type ServiceUpsertWithoutOrderItemInput = {
    update: XOR<ServiceUpdateWithoutOrderItemInput, ServiceUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ServiceCreateWithoutOrderItemInput, ServiceUncheckedCreateWithoutOrderItemInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutOrderItemInput, ServiceUncheckedUpdateWithoutOrderItemInput>
  }

  export type ServiceUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: IntFieldUpdateOperationsInput | number
    etaHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceCatId?: ServiceCategoryUpdateOneRequiredWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: IntFieldUpdateOperationsInput | number
    etaHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: EmployeeTaskWhereUniqueInput
    update: XOR<EmployeeTaskUpdateWithoutOrderItemInput, EmployeeTaskUncheckedUpdateWithoutOrderItemInput>
    create: XOR<EmployeeTaskCreateWithoutOrderItemInput, EmployeeTaskUncheckedCreateWithoutOrderItemInput>
  }

  export type EmployeeTaskUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: EmployeeTaskWhereUniqueInput
    data: XOR<EmployeeTaskUpdateWithoutOrderItemInput, EmployeeTaskUncheckedUpdateWithoutOrderItemInput>
  }

  export type EmployeeTaskUpdateManyWithWhereWithoutOrderItemInput = {
    where: EmployeeTaskScalarWhereInput
    data: XOR<EmployeeTaskUpdateManyMutationInput, EmployeeTaskUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type OrderHeaderCreateWithoutPaymentInput = {
    id?: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customers: CustomerCreateNestedOneWithoutOrderHeaderInput
    employees?: EmployeeCreateNestedOneWithoutOrderHeaderInput
    outlets: OutletCreateNestedOneWithoutOrderHeaderInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderUncheckedCreateWithoutPaymentInput = {
    id?: string
    customerId: string
    handledById?: string | null
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderheaderInput
    workerTasks?: EmployeeTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    PickUpTask?: PickUpTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
    DeliveryTask?: DeliveryTaskUncheckedCreateNestedManyWithoutOrderHeaderInput
  }

  export type OrderHeaderCreateOrConnectWithoutPaymentInput = {
    where: OrderHeaderWhereUniqueInput
    create: XOR<OrderHeaderCreateWithoutPaymentInput, OrderHeaderUncheckedCreateWithoutPaymentInput>
  }

  export type OrderHeaderUpsertWithoutPaymentInput = {
    update: XOR<OrderHeaderUpdateWithoutPaymentInput, OrderHeaderUncheckedUpdateWithoutPaymentInput>
    create: XOR<OrderHeaderCreateWithoutPaymentInput, OrderHeaderUncheckedCreateWithoutPaymentInput>
    where?: OrderHeaderWhereInput
  }

  export type OrderHeaderUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OrderHeaderWhereInput
    data: XOR<OrderHeaderUpdateWithoutPaymentInput, OrderHeaderUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderHeaderUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutOrderHeaderNestedInput
    employees?: EmployeeUpdateOneWithoutOrderHeaderNestedInput
    outlets?: OutletUpdateOneRequiredWithoutOrderHeaderNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
  }

  export type CustomerAddressCreateManyCustomersInput = {
    id?: string
    label: $Enums.Label
    address: string
    city: string
    postalCode: string
    latitude: number
    longitude: number
    notes?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderHeaderCreateManyCustomersInput = {
    id?: string
    handledById?: string | null
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerAddressUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PickUpTask?: PickUpTaskUpdateManyWithoutCustomerAddressNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutCustomerAddressNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutCustomerAddressNestedInput
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: EnumLabelFieldUpdateOperationsInput | $Enums.Label
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateOneWithoutOrderHeaderNestedInput
    outlets?: OutletUpdateOneRequiredWithoutOrderHeaderNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateManyWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskCreateManyCustomerAddressInput = {
    id?: string
    driverId: string
    outletId: string
    assignedByAdminId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateManyCustomerAddressInput = {
    id?: string
    driverId: string
    outletId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskUpdateWithoutCustomerAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutPickUpDriverNestedInput
    assignedBy?: EmployeeUpdateOneWithoutPickupAssignedByNestedInput
    outlets?: OutletUpdateOneRequiredWithoutPickUpTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutPickUpTaskNestedInput
  }

  export type PickUpTaskUncheckedUpdateWithoutCustomerAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUncheckedUpdateManyWithoutCustomerAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUpdateWithoutCustomerAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutDeliveryDriverNestedInput
    assignedBy?: EmployeeUpdateOneWithoutDeliveryAssignedByNestedInput
    outlets?: OutletUpdateOneRequiredWithoutDeliveryTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutDeliveryTaskNestedInput
  }

  export type DeliveryTaskUncheckedUpdateWithoutCustomerAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutCustomerAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateManyEmployeesInput = {
    id?: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderHeaderCreateManyEmployeesInput = {
    id?: string
    customerId: string
    outletId: string
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkStationCreateManyEmployeesInput = {
    id?: string
    station: $Enums.Station
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateManyEmployeeInput = {
    id?: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateManyAssignedByInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateManyApprovedByInput = {
    id?: string
    employeeId: string
    shiftId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskCreateManyDriverInput = {
    id?: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskCreateManyAssignedByInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateManyDriverInput = {
    id?: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateManyAssignedByInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlet?: OutletUpdateOneRequiredWithoutAttendanceNestedInput
    approvedBy?: EmployeeUpdateOneWithoutApprovedAttendancesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutOrderHeaderNestedInput
    outlets?: OutletUpdateOneRequiredWithoutOrderHeaderNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateManyWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkStationUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerTasks?: EmployeeTaskUpdateManyWithoutWorkStationNestedInput
  }

  export type WorkStationUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutWorkStationNestedInput
  }

  export type WorkStationUncheckedUpdateManyWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    station?: EnumStationFieldUpdateOperationsInput | $Enums.Station
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedBy?: EmployeeUpdateOneWithoutAssignedTasksNestedInput
    orderHeader?: OrderHeaderUpdateOneWithoutWorkerTasksNestedInput
    orderItem?: OrderItemUpdateOneWithoutWorkerTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutWorkerTasksNestedInput
    shift?: ShiftUpdateOneRequiredWithoutWorkerTasksNestedInput
    workStation?: WorkStationUpdateOneRequiredWithoutWorkerTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutWorkerTasksNestedInput
    orderHeader?: OrderHeaderUpdateOneWithoutWorkerTasksNestedInput
    orderItem?: OrderItemUpdateOneWithoutWorkerTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutWorkerTasksNestedInput
    shift?: ShiftUpdateOneRequiredWithoutWorkerTasksNestedInput
    workStation?: WorkStationUpdateOneRequiredWithoutWorkerTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateOneRequiredWithoutAttendanceNestedInput
    outlet?: OutletUpdateOneRequiredWithoutAttendanceNestedInput
    shift?: ShiftUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedBy?: EmployeeUpdateOneWithoutPickupAssignedByNestedInput
    outlets?: OutletUpdateOneRequiredWithoutPickUpTaskNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutPickUpTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutPickUpTaskNestedInput
  }

  export type PickUpTaskUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutPickUpDriverNestedInput
    outlets?: OutletUpdateOneRequiredWithoutPickUpTaskNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutPickUpTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutPickUpTaskNestedInput
  }

  export type PickUpTaskUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUncheckedUpdateManyWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedBy?: EmployeeUpdateOneWithoutDeliveryAssignedByNestedInput
    outlets?: OutletUpdateOneRequiredWithoutDeliveryTaskNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutDeliveryTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutDeliveryTaskNestedInput
  }

  export type DeliveryTaskUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutDeliveryDriverNestedInput
    outlets?: OutletUpdateOneRequiredWithoutDeliveryTaskNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutDeliveryTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutDeliveryTaskNestedInput
  }

  export type DeliveryTaskUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateManyShiftsInput = {
    id?: string
    outletId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateManyShiftInput = {
    id?: string
    employeeId: string
    outletId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateManyShiftInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outlets?: OutletUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateOneRequiredWithoutAttendanceNestedInput
    outlet?: OutletUpdateOneRequiredWithoutAttendanceNestedInput
    approvedBy?: EmployeeUpdateOneWithoutApprovedAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutAssignedTasksNestedInput
    orderHeader?: OrderHeaderUpdateOneWithoutWorkerTasksNestedInput
    orderItem?: OrderItemUpdateOneWithoutWorkerTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutWorkerTasksNestedInput
    workStation?: WorkStationUpdateOneRequiredWithoutWorkerTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskCreateManyWorkStationInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    outletId: string
    shiftId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskUpdateWithoutWorkStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutAssignedTasksNestedInput
    orderHeader?: OrderHeaderUpdateOneWithoutWorkerTasksNestedInput
    orderItem?: OrderItemUpdateOneWithoutWorkerTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutWorkerTasksNestedInput
    shift?: ShiftUpdateOneRequiredWithoutWorkerTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutWorkStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutWorkStationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateManyOutletsInput = {
    id?: string
    shiftId: string
    role: $Enums.Role
    name: string
    email: string
    password?: string | null
    phoneNumber: string
    address: string
    photoUrl?: string | null
    isActive?: boolean
    resetPasswordToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceCreateManyOutletInput = {
    id?: string
    employeeId: string
    shiftId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    clockInAt?: Date | string | null
    clockOutAt?: Date | string | null
    workMinutes?: number | null
    lateMinutes?: number | null
    earlyLeaveMin?: number | null
    notes?: string | null
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OutletScheduleCreateManyOutletInput = {
    id?: string
    detailDays: string
    openHour: Date | string
    closeHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderHeaderCreateManyOutletsInput = {
    id?: string
    customerId: string
    handledById?: string | null
    status?: $Enums.OrderStatus
    notes: string
    pickupAt: Date | string
    deliverAt: Date | string
    estHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateManyOutletInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    orderItemId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskCreateManyOutletsInput = {
    id?: string
    driverId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateManyOutletsInput = {
    id?: string
    driverId: string
    customerAddressId: string
    assignedByAdminId: string
    orderHeaderId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateOneRequiredWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeesNestedInput
    orderHeader?: OrderHeaderUncheckedUpdateManyWithoutEmployeesNestedInput
    WorkStation?: WorkStationUncheckedUpdateManyWithoutEmployeesNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutEmployeeNestedInput
    assignedTasks?: EmployeeTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    approvedAttendances?: AttendanceUncheckedUpdateManyWithoutApprovedByNestedInput
    pickUpDriver?: PickUpTaskUncheckedUpdateManyWithoutDriverNestedInput
    pickupAssignedBy?: PickUpTaskUncheckedUpdateManyWithoutAssignedByNestedInput
    deliveryDriver?: DeliveryTaskUncheckedUpdateManyWithoutDriverNestedInput
    deliveryAssignedBy?: DeliveryTaskUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateOneRequiredWithoutAttendanceNestedInput
    approvedBy?: EmployeeUpdateOneWithoutApprovedAttendancesNestedInput
    shift?: ShiftUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    clockInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyLeaveMin?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutletScheduleUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    detailDays?: StringFieldUpdateOperationsInput | string
    openHour?: DateTimeFieldUpdateOperationsInput | Date | string
    closeHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderHeaderUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: CustomerUpdateOneRequiredWithoutOrderHeaderNestedInput
    employees?: EmployeeUpdateOneWithoutOrderHeaderNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderheaderNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutOrderheaderNestedInput
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    PickUpTask?: PickUpTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
    DeliveryTask?: DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderNestedInput
  }

  export type OrderHeaderUncheckedUpdateManyWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: StringFieldUpdateOperationsInput | string
    pickupAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutAssignedTasksNestedInput
    orderHeader?: OrderHeaderUpdateOneWithoutWorkerTasksNestedInput
    orderItem?: OrderItemUpdateOneWithoutWorkerTasksNestedInput
    shift?: ShiftUpdateOneRequiredWithoutWorkerTasksNestedInput
    workStation?: WorkStationUpdateOneRequiredWithoutWorkerTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutPickUpDriverNestedInput
    assignedBy?: EmployeeUpdateOneWithoutPickupAssignedByNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutPickUpTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutPickUpTaskNestedInput
  }

  export type PickUpTaskUncheckedUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUncheckedUpdateManyWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutDeliveryDriverNestedInput
    assignedBy?: EmployeeUpdateOneWithoutDeliveryAssignedByNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutDeliveryTaskNestedInput
    orderHeader?: OrderHeaderUpdateOneRequiredWithoutDeliveryTaskNestedInput
  }

  export type DeliveryTaskUncheckedUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCreateManyServiceCatIdInput = {
    id?: string
    name: string
    unit: string
    basePrice: number
    minQty: number
    etaHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ServiceUpdateWithoutServiceCatIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: IntFieldUpdateOperationsInput | number
    etaHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceCatIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: IntFieldUpdateOperationsInput | number
    etaHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutServiceCatIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    minQty?: IntFieldUpdateOperationsInput | number
    etaHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateManyServiceInput = {
    id?: string
    orderHeaderId: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderheader?: OrderHeaderUpdateOneRequiredWithoutOrderItemNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateManyOrderheaderInput = {
    id?: string
    serviceId: string
    qty: number
    unitPrice: number
    subTotal: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentCreateManyOrderheaderInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: number
    status?: $Enums.PaymentStatus
    providerRef: string
    paidAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskCreateManyOrderHeaderInput = {
    id?: string
    employeeId: string
    orderItemId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PickUpTaskCreateManyOrderHeaderInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    status?: $Enums.PickupStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeliveryTaskCreateManyOrderHeaderInput = {
    id?: string
    driverId: string
    outletId: string
    customerAddressId: string
    assignedByAdminId: string
    status: $Enums.DeilveryStatus
    distance: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemUpdateWithoutOrderheaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service?: ServiceUpdateOneRequiredWithoutOrderItemNestedInput
    workerTasks?: EmployeeTaskUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderheaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerTasks?: EmployeeTaskUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderheaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    subTotal?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutOrderheaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    providerRef?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateWithoutOrderheaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    providerRef?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutOrderheaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    providerRef?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutAssignedTasksNestedInput
    orderItem?: OrderItemUpdateOneWithoutWorkerTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutWorkerTasksNestedInput
    shift?: ShiftUpdateOneRequiredWithoutWorkerTasksNestedInput
    workStation?: WorkStationUpdateOneRequiredWithoutWorkerTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutPickUpDriverNestedInput
    assignedBy?: EmployeeUpdateOneWithoutPickupAssignedByNestedInput
    outlets?: OutletUpdateOneRequiredWithoutPickUpTaskNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutPickUpTaskNestedInput
  }

  export type PickUpTaskUncheckedUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PickUpTaskUncheckedUpdateManyWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    status?: EnumPickupStatusFieldUpdateOperationsInput | $Enums.PickupStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    driver?: EmployeeUpdateOneRequiredWithoutDeliveryDriverNestedInput
    assignedBy?: EmployeeUpdateOneWithoutDeliveryAssignedByNestedInput
    outlets?: OutletUpdateOneRequiredWithoutDeliveryTaskNestedInput
    customerAddress?: CustomerAddressUpdateOneRequiredWithoutDeliveryTaskNestedInput
  }

  export type DeliveryTaskUncheckedUpdateWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryTaskUncheckedUpdateManyWithoutOrderHeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    customerAddressId?: StringFieldUpdateOperationsInput | string
    assignedByAdminId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeilveryStatusFieldUpdateOperationsInput | $Enums.DeilveryStatus
    distance?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskCreateManyOrderItemInput = {
    id?: string
    employeeId: string
    orderHeaderId: string
    outletId: string
    shiftId: string
    workStationId: string
    status?: $Enums.TaskStatus
    itemQty?: number | null
    itemUnit?: string | null
    bypassReqNote?: string | null
    bypassReq?: boolean | null
    isReqAprooved?: boolean | null
    itemPassedNote?: string | null
    assignedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeTaskUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutWorkerTasksNestedInput
    assignedBy?: EmployeeUpdateOneWithoutAssignedTasksNestedInput
    orderHeader?: OrderHeaderUpdateOneWithoutWorkerTasksNestedInput
    outlet?: OutletUpdateOneRequiredWithoutWorkerTasksNestedInput
    shift?: ShiftUpdateOneRequiredWithoutWorkerTasksNestedInput
    workStation?: WorkStationUpdateOneRequiredWithoutWorkerTasksNestedInput
  }

  export type EmployeeTaskUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeTaskUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    orderHeaderId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    workStationId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    itemQty?: NullableIntFieldUpdateOperationsInput | number | null
    itemUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReqNote?: NullableStringFieldUpdateOperationsInput | string | null
    bypassReq?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isReqAprooved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemPassedNote?: NullableStringFieldUpdateOperationsInput | string | null
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}